Patrick Powell Mon Aug 28 15:06:57 PDT 1995

How to set up NIS for LPRng use

This note is based on material sent to the plp@iona.ie mailing list by 
Paul Haldane <paul@ucs.ed.ac.uk>.  I have edited this information
and added the necessary comments in the script.  Note that the
[  ] entries are actuall [<space><tab>] that some mailers will
neatly remove;  you will have to edit them back in.

 # From: Paul Haldane <paul@ucs.ed.ac.uk>
 # To: plp@iona.ie
 # Subject: Re: Problem using plp with NIS
 # Sender: majordomo-owner@iona.ie
 # Precedence: bulk
 # Reply-To: plp@iona.ie
 # Status: RO
 # 
 # 
 # OK - I'll have a go - we generally don't use NIS for printcap files (we've
 # moved to hesiod) and we're running an old version of PLP but I can
 # show you what we've got.
 # 

The input to NIS is a normal printcap file...

# Classical printcap entry
lp23a|lp23|lp|main printhost printer - KB, EUCS front Door:\
        :lp=lp23a@printhost:\
        :sd=/usr/spool/lpr/lp23a:
 
#lprng printcap entry
lplabel|lpl|TEST - Labels printer:
        :lp=:rm=printhost:rp=lplabel:
        :sd=/usr/spool/lpr/lplabel:
        :rg=lpadm:mx#1:

To build the NIS printcap.byname map we add the following to 
the NIS makefile (along the other bits and pieces that the makefiel
needs to know about a new map).

PRINTCAP=$(DIR)/printcap
#PRINTCAP=/etc/printcap

# warning : [  ] is actually [<space><tab>] in the script

printcap.time: $(PRINTCAP) Makefile
	if [ -f $(PRINTCAP) ]; then \
		sed < $(PRINTCAP) \
			-e 's/[ 	][ 	]*$$//' -e '/\\$$/s/\\$$/ /' \
		| awk '$$1 ~ /^#/{next;} $$1 ~ /^[:|]/ {printf "%s", $$0; next;} \
				{printf "\n%s", $$0 }' \
		| sed -e 's/[ 	]*:[ 	]*:/:/g' -e 's/[ 	]*|[ 	]*/|/g' \
			-e '/^[ 	]*$$/d' > .printcap.$$$$; \
		cat .printcap.$$$$; \
		if [ $$? = 0 -a -s .printcap.$$$$ ]; then \
			awk <.printcap.$$$$ '{ FS=":"; OFS="\t"; } { \
					n = split($$1, names, "|"); \
					for (i=1; i<=n; i++) \
							if (length(names[i]) > 0 \
							&& names[i] !~ /[ \t]/) \
									print names[i], $$0; \
			}' | $(MAKEDBM) - $(YPDBDIR)/$(DOM)/printcap.byname; \
			awk <.printcap.$$$$ '{ FS=":"; OFS="\t"; } { \
					n = split($$1, names, "|"); \
					if (n && length(names[1]) > 0 && names[1] !~ /[ \t]/) \
							print names[1], $$0; \
			}' | $(MAKEDBM) - $(YPDBDIR)/$(DOM)/printcap.bykey; \
			rm -f .printcap.$$$$; \
			touch printcap.time; echo "updated printcap"; \
		fi \
	fi
	@if [ ! $(NOPUSH) -a -f $(PRINTCAP) ]; then \
			$(YPPUSH) printcap.byname; \
			$(YPPUSH) printcap.bykey; \
			touch printcap.time; echo "pushed printcap"; \
	fi

To specify that you want YP database rather than file access,
use the following entry in your /etc/lpd.conf file:

printcap_path |/usr/local/lib/pcfilter

Put the following shell script in /usr/local/lib/pcfilter

#!/bin/sh
#/usr/local/lib/pcfilter
read key
ypmatch "$key" printcap.byname

------------- ALTERNATE METHOD -----------------

 Date: Wed, 11 Sep 1996 00:11:02 +0200
 From: Sven Rudolph <sr1@os.inf.tu-dresden.de>
 To: plp@iona.ie
 Subject: Using :oh=server: with NIS

 When I use the oh feature in a cluster-wide printcap two entries for
 each printer will appear, e. g.:

 ---------- start of /etc/printcap snippet
 lp1
         :lp=lp1@server

 lp1
         :oh=server
         :sd=/var/spool/lpd/lp1
         :lp=/dev/lp1
         :sh:mx#0
 ---------- end of /etc/printcap snippet

When I create a NIS map out of this the printer name is used as a key
and must be unique. So NIS' makedbm decides to drop all but the last
entry for each printer. This makes the printer on the clients
unavailable.
I solved this by a hack where the second entry is called lp1.server
and the NIS client script has to request the right entry.

(For details I appended the notes for my "NIS for LPRng" solution
below. I wasn't aware of the script that Patrick Powell sent today, so
I did my own. Compared to the other one it has both disadvantages
(requires perl on the server, doesn't process the old printcap format)
and advantages (creates the "all" printcap entry, has the
above-mentioned hack).)

UPDATE: Sun Oct 27 17:58:41 PPET 1996

> Another solution is to call them
>   lp1, lp1_1, lp1_2 etc etc, and then request lp1, lp1_1, in the
>   database.  This is ugly,  but is the same  method you have come
>   up with.

This is better than my method. I actually use lp|1, lp|2 , because |
is guaranteed to not be part of a printer name.

I append my current notes below.

	Sven
-- 
Sven Rudolph <sr1@inf.tu-dresden.de> ; WWW : http://www.sax.de/~sr1/

Using NIS for printcap distribution with LPRng

Sven Rudolph <sr1@inf.tu-dresden.de>
Mon, 14 Oct 1996 16:41:49 +0200

0. Assumptions

Perl is available at the YP server in /usr/bin/perl .
A Bourne Shell is available at all clients in /bin/sh
The printcap that is to be exported is in /etc/printcap .
The printcap is written in the new format.

In the examples the printer is called lp1 .

1. Add the following to your YP Makefile (/var/yp/Makefile) on the YP
   server :

---------- start of /var/yp/Makefile snippet
PRINTCAP  = /etc/printcap

printcap: $(PRINTCAP)
        @echo "Updating $@..."
        $(CAT) $(PRINTCAP) | \
                /usr/lib/yp/normalize_printcap | $(DBLOAD) -i $(PRINTCAP) \
                                                -o $(YPMAPDIR)/$@ - $@
        @if [ ! $(NOPUSH) ]; then $(YPPUSH) -d $(DOMAIN) $@; fi
        @if [ ! $(NOPUSH) ]; then echo "Pushed $@ map." ; fi
---------- end of /var/yp/Makefile snippet

(These lines are for Debian GNU/Linux, other systems might require
other modifications)


2. Install the programs match_printcap and normalize_printcap to /usr/lib/yp.

normalize_printcap is only required on the YP server.

normalize_printcap processes only a specific printcap format. Entries
are delimited by ':' and a continuation line starts with a white space
:

---------- start of /etc/printcap snippet
lp1
	:lp=lp1@server

lp1
	:oh=server
	:sd=/var/spool/lpd/lp1
	:lp=/dev/lp1
	:sh:mx#0
---------- end of /etc/printcap snippet

---------- start of /usr/lib/yp/normalize_printcap
#! /usr/bin/perl

$debug = 0;

while (<>) {
    next if ( /^\#.*/ );
    strip;
    $cont = ( /^\s+\S/ );
    s/\t//g;
    s/\n//g;
    next if ( $_ eq '' );
    $new = $_;
    print "new: " . $_ . "\n" if $debug;;
    if ($cont) { # continuation line
	$line = $line.$new;
	print "continued: $line\n" if $debug;;
    } else {
	push(@lines, $line);
	$line = $new;
    }
}
push(@lines,$line);

foreach $line (@lines) {
    ($printers) = split(/\:/,$line);
    @printers = split(/\|/,$printers);
    foreach $printer (@printers) {
	$num{$printer}++;
	push(@allprinters,$printer);
	print "allprinters: @allprinters \n" if $debug;
	print "$printer|$num{$printer}\t$line\n";
    }
}

if ($#allprinters >=0) {
    print "all|1\tall:all=$allprinters[0]";
    shift(@allprinters);
    foreach $printer (@allprinters) {
	print ",$printer"; 
    }
    print "\n";
}

---------- end of /usr/lib/yp/normalize_printcap


---------- start of /usr/lib/yp/match_printcap
#! /bin/sh
read p

n=1

while ypmatch "$p|$n" printcap 2>/dev/null; do
    n=`expr $n + 1`
done
---------- end of /usr/lib/yp/match_printcap


3. Now test the YP arrangement:

$ cd /var/yp; make # this should create the printcap map
$ ypcat printcap # should provide the whole normalized printcap


4. Add the printcap_path entry to /etc/lpd.conf :

printcap_path | /usr/lib/yp/match_printcap


5. Test it.

$ lpq -Plp1 # shows the status of lp1

Try to print a file.

