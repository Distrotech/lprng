<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<TITLE> LPRng-HOWTO: The /etc/lpd.perms Permissions File</TITLE>
</HEAD>
<BODY>
<A HREF="LPRng-HOWTO-10.html">Next</A>
<A HREF="LPRng-HOWTO-8.html">Previous</A>
<A HREF="LPRng-HOWTO.html#toc9">Contents</A>
<HR>
<H2><A NAME="s9">9. The /etc/lpd.perms Permissions File</A></H2>

<P>This file is used to specify the restrictions on the use
of the LPRng software,
printers,
and other facilities.
The following is an example of a <CODE>lpd.perms</CODE> file.
<P>
<PRE>
# allow root on server to control jobs
ACCEPT SERVICE=C SERVER REMOTEUSER=root
REJECT SERVICE=C
#
# allow same user on originating host to remove a job
ACCEPT SERVICE=M SAMEHOST SAMEUSER
# allow root on server to remove a job
ACCEPT SERVICE=M SERVER REMOTEUSER=root
REJECT SERVICE=M
# all other operations allowed
DEFAULT ACCEPT
</PRE>
<P>The structure of the lpd.perms file was inspired by network
packet filter configuration files.
When the LPD server gets a request from a remote client program,
it performs the checks specified by the rules in the
<CODE>lpd.perms</CODE>
to decide whether to accept or reject the request.
<P>A rule will ACCEPT or REJECT a request
if all of the patterns specified in the rule match.
If there is a match failure,
the next rule in sequence will be applied.
If all of the rules are exhausted,
then the last specified default authorization will be used.
<P>The sense of a pattern match can be inverted using the NOT keyword.
For example,
the rules with
<CODE>ACCEPT NOT USER=john,bill</CODE>
succeeds only if USER is defined and the USER value
is not <CODE>john</CODE> or <CODE>bill</CODE>.
<P>The following patterns and matching are applied.
<P>
<CENTER><TABLE BORDER><TR><TD>
<BR>
Keyword</TD><TD>Match</TD></TR><TR><TD>
<CODE>DEFAULT</CODE></TD><TD>default result</TD></TR><TR><TD>
<CODE>SERVICE</CODE></TD><TD>lpC Status and User, lpR, lprM, lpQ request</TD></TR><TR><TD>
<CODE>USER</CODE></TD><TD>user name in print job</TD></TR><TR><TD>
<CODE>REMOTEUSER</CODE></TD><TD>user making request</TD></TR><TR><TD>
<CODE>HOST</CODE></TD><TD>host name in print job</TD></TR><TR><TD>
<CODE>REMOTEHOST</CODE></TD><TD>host making request</TD></TR><TR><TD>
<CODE>IP</CODE></TD><TD>IP address and mask of host in print job</TD></TR><TR><TD>
<CODE>REMOTEIP</CODE></TD><TD>IP address and mask of host making request</TD></TR><TR><TD>
<CODE>PORT</CODE></TD><TD>TCP/IP port of host making request</TD></TR><TR><TD>
<CODE>SAMEUSER</CODE></TD><TD>USER and REMOTEUSER same</TD></TR><TR><TD>
<CODE>SAMEHOST</CODE></TD><TD>HOST and REMOTEHOST same</TD></TR><TR><TD>
<CODE>SERVER</CODE></TD><TD>request originates on lpd server</TD></TR><TR><TD>
<CODE>FORWARD</CODE></TD><TD>destination of job is not host</TD></TR><TR><TD>
<CODE>GROUP</CODE></TD><TD>USER is in the particular group</TD></TR><TR><TD>
<CODE>REMOTEGROUP</CODE></TD><TD>REMOTEUSER is in the particular group</TD></TR><TR><TD>
<CODE>CONTROLLINE</CODE></TD><TD>match a line in control file</TD></TR><TR><TD>
<CODE>AUTH</CODE></TD><TD>authentication type</TD></TR><TR><TD>
<CODE>AUTHUSER</CODE></TD><TD>authenticated user</TD></TR><TR><TD>
<CODE>FWDUSER</CODE></TD><TD>authenticated forwarder</TD></TR><TR><TD>

</TD></TR></TABLE></CENTER>
<P>Most of the patterns can be lists of alternative values to match,
and can even contain wild cards.
The full details of the rules and keywords are detailed in
the <CODE>lpd.conf(5)</CODE> man page.
<H2><A NAME="ss9.1">9.1 Information for matching</A>
</H2>

<P>In order to do matching,
the <CODE>lpd</CODE> server obtains and sets up the following information:
<OL>
<LI>If the request is coming over a network connection,
then the IP address (REMOTEIP)
port (PORT) of the source of the connection and
FQDN of the remote host (REMOTEHOST) are obtained
and the indicated values are set.</LI>
<LI>If the request contains the name of the user,
then REMOTEUSER is assigned the name.</LI>
<LI>If the request contains the name of the printer,
then PRINTER is assigned the name.</LI>
<LI>If a print job is being printed,
then the USER, HOST, and PRINTER are set to the
user name, host, and printer information in the control file for the
print job.</LI>
<LI>If one of the optional authentication methods is being used,
(see
<A HREF="LPRng-HOWTO-11.html#authref">Authentication and Encryption</A>),
then AUTH is set to NONE,
USER,
or FWD,
depending on the type of operation and authentication present.
AUTHUSER to the authenticated originating user of the request
and FWDUSER is set to the forwarding servers authentication information
(if any).</LI>
</OL>
<H2><A NAME="ss9.2">9.2 Permission Checks</A>
</H2>

<P>When a connection is made to the <CODE>lpd</CODE> server,
the originating site's IP address and hostname are determined,
and a check with <CODE>SERVICE=X</CODE> is made.
The REMOTEHOST,
REMOTEIP,
and PORT will be defined for the purposes of this check.
<P>If the result is to accept the connection,
then the request is then read from the connection,
and the
SERVICE,
REMOTEUSER and PRINTER
will be defined.
A further check is performed to determine if the service request would
be accepted.
<P>While when performing a service activity and a particular job is to
be acted on,
the
USER, HOST, and other control file information will be available,
and a further check can be performed.
<P>If a rule is specified and the particular value is not defined,
then a rull will fail to match.
<H2><A NAME="ss9.3">9.3 Match Procedure</A>
</H2>

<P>
<PRE>
key=pattern                         substring match
key=pattern1,pattern2,pattern3,...  glob and exact
key=IP1/mask1,IP2/mask2,...         IP address
</PRE>
<P>Each of the indicated values is matched against a list of patterns.
The following types of matches are used:
<OL>
<LI>substring match.
The indicated entry is present as a substring in the pattern.</LI>
<LI>GLOB matches.
The pattern is interpreted as a GLOB style pattern,
where * matches 0 or more characters,
and ? matches a single character.</LI>
<LI>Exact string match.
There is no glob matching performed and the strings must match
exactly.</LI>
<LI>IP address match.  The address must be specified in the
standard <CODE>nn.nn.nn.nn</CODE> format.
The mask must be either an integer number
corresponding to the number of significant bits,
or in the standard <CODE>nn.nn.nn.nn</CODE> format.
The two addresses are compared by doing
<PRE>
( IPaddr XOR IP ) AND mask
</PRE>

<P>If the result is 0, then a match results.
</LI>
<LI>integer range match.
The pattern has the form <CODE>low-high</CODE>,
where low and high are integer numbers.
The match succeeds if the value is in the specified range.</LI>
</OL>
<H3>DEFAULT</H3>

<P>
<PRE>
DEFAULT ACCEPT
DEFAULT REJECT
</PRE>
<P>The DEFAULT rule specifies the default if no rule matches.
Normally,
there is one DEFAULT entry in a permissions file.
<A NAME="userlpc"></A> <H3>SERVICE</H3>

<P>Options used:
<UL>
<LI> <CODE>user_lpc=</CODE><EM>allow set of lpc actions on user files</EM></LI>
</UL>
<P>Match type: substring
<P>The SERVICE key is based on the type of request.
<CENTER><TABLE BORDER><TR><TD>
<BR>
Key</TD><TD>Request</TD></TR><TR><TD>
<CODE>C</CODE></TD><TD>LPC Control Request</TD></TR><TR><TD>
<CODE>M</CODE></TD><TD>LPRM Removal Request</TD></TR><TR><TD>
<CODE>P</CODE></TD><TD>Job Printing</TD></TR><TR><TD>
<CODE>Q</CODE></TD><TD>LPQ Status Request</TD></TR><TR><TD>
<CODE>R</CODE></TD><TD>LPR Job Transfer</TD></TR><TR><TD>
<CODE>S</CODE></TD><TD>LPC Status Request</TD></TR><TR><TD>
<CODE>U</CODE></TD><TD>LPC User File Request</TD></TR><TR><TD>
<CODE>X</CODE></TD><TD>Connection Request</TD></TR><TR><TD>

</TD></TR></TABLE></CENTER>
<P>Each of the above codes corresponds either directly to the user command,
or a set of subcommands.
<P>All the LPC subcommands are SERVICE=C;
status commands such as <CODE>lpc status, printcap, active, </CODE>
or <CODE>lpd</CODE> are SERVICE=S commands as well.
<P>The <CODE>user_lpc</CODE> configuration option can be used to specify a
set of control commands that can be applied to individual user files
in a spool queue.
These commands include <CODE>user_lpc=</CODE>
<CODE>hold</CODE>,
<CODE>release</CODE>,
<CODE>move</CODE>,
<CODE>topq</CODE>,
<CODE>kill</CODE>,
and
<CODE>abort</CODE>.
When the <CODE>user_lpc</CODE> specifies one of these commands,
the <CODE>lpd</CODE> program will delay rejecting a request until
the individual files in a queue are checked for permission.
This allows the following permissions line to be used:
<PRE>
#allow root on server all permissions
ACCEPT SERVICE=C SERVER REMOTEUSER=root
#allow all status commands
ACCEPT SERVICE=S
#allow same user on same host to use user_lpc commands
ACCEPT SERVICE=U SAMEUSER SAMEHOST
#note that this has effect for U only when file checks are performed
REJECT SERVICE=UCS
</PRE>
<P>The above permissions entry will allow users to perform the actions
specified by <CODE>user_lpc</CODE> on their files.
<H3>USER</H3>

<P>Match type: GLOB
<P>The USER information is taken from the <CODE>P</CODE> (person or logname)
information in the print job control file.
<H3>REMOTEUSER</H3>

<P>Match type: GLOB
<P>The REMOTEUSER information is taken from the user information sent
with a service request.
<P>Note that one of the deficiencies of
<A HREF="LPRng-HOWTO-2.html#rfc1179">RFC1179</A>
is that an LPQ (print status)
request does provide a REMOTEUSER name.
<H3>HOST</H3>

<P>Match type: GLOB
<P>The HOST information is taken from the <CODE>H</CODE> (host)
information in the print job control file.
<H3>REMOTEHOST</H3>

<P>Match type: GLOB
<P>The REMOTEHOST information is obtained by doing a reverse IP name lookup
on the remote host address.
If there is no FQDN available,
then the IP address in text form will be used.
<H3>PORT</H3>

<P>Match type: integer range
<P>The PORT value is obtained from the originating port of the TCP/IP
connection.
The match succeeds if it is in the specified range.
<H3>IP</H3>

<P>Match type: IPaddr
<P>The IP information is obtained by doing a DNS lookup on the
H (host) information in the control file.
If there is no host information, the IP address is undefined.
<H3>REMOTEIP</H3>

<P>Match type: IPaddr
<P>The REMOTEIP information is the IP address of the host making the
service request.
<H3>SAMEUSER</H3>

<P>Match type: exact string match
<P>Both the REMOTEUSER and USER information must be present and identical.
<H3>SAMEHOST</H3>

<P>Match type: exact string match on IP addresses
<P>One of the IP addresses found when doing a gethostbyname() lookup for
both HOST and REMOTEHOST must be identical.
<H3>SERVER</H3>

<P>Match type: exact string match on IP addresses
<P>One of the IP addresses of the <CODE>lpd</CODE> server host
and REMOTEHOST must be identical,
or REMOTEHOST must be <CODE>localhost</CODE>.
<H3>FORWARD</H3>

<P>Match type: exact string match
<P>Both the REMOTEHOST and HOST information must be present and different.
<P>This is usually the case when the <CODE>lpd</CODE> server is acting to
forward jobs from a server to a remote printer.
<H3>GROUP</H3>

<P>Match type: modified GLOB
<P>If the pattern does not start with a <CODE>@</CODE> character,
then the USER information must be present
and the USER must be present in
one of the groups in <CODE>/etc/group</CODE> or whatever permissions mechanism is used
to determine group ownership
which matches the GLOB pattern.
<P>If the pattern starts with a <CODE>@</CODE> character,
then the USER information must be present
and the user must be in the specified <CODE>netgroup</CODE>.
This match will be performed only if the <CODE>netgroup</CODE>
mechanism is supported on the system and the specified netgroup
exists.
No wildcard match will be done for netgroups.
<H3>REMOTEGROUP</H3>

<P>The same rules as for GROUP,
but using the REMOTEUSER value.
<H3>CONTROLLINE</H3>

<P>Match type: GLOB
<P>A <CODE>CONTROLLINE</CODE> pattern has the form
<PRE>
X=pattern1,pattern2,...
</PRE>
<P>X is a single upper case letter.
The corresponding line must be present in a control file,
and the pattern is applied to the line contents.
<P>This pattern can be used to select only files with specific control
file information for printing.
<H3>AUTH</H3>

<P>Match type: GLOB
<P>The AUTH value can be NONE,
indicating that no authentication was done.
If authentication was done,
then AUTH=USER checks to see if there was user information,
and AUTH=FWD checks to see if there was forwarding system identification.
<H3>AUTHUSER</H3>

<P>Match type: GLOB
<P>If AUTH=USER check succeeds,
the AUTHUSER rule will check to see if the user identification
matches the pattern.
<H3>FWDUSER</H3>

<P>Match type: GLOB
<P>If AUTH=FWD check succeeds,
the FWDUSER rule will check to see if the forwarding system identification
matches the pattern.
<H3>IFIP</H3>

<P>Match type: IPmatch, but for IPV6 as well as IPV4
<P>There is a subtle problem with names and IP addresses which are
obtained for 'multi-homed hosts', i.e. - those with multiple
ethernet interfaces,  and for IPV6 (IP Version 6),  in which a host
can have multiple addresses,  and for the normal host which can have
both a short name and a fully qualified domain name.
<P>The IFIP (interface IP) field can be used to check the IP address
of the origination of the request,  as reported by the information
returned by the accept() system call.  Note that this information may
be IPV4 or IPV6 information,  depending on the origination of the
system.  This information is used by gethostbyaddr() to obtain the
originating host fully qualified domain name (FQDN) and set of IP addresses.
Note that this FQDN will be for the originating interface,  and may
not be the cannonical host name.  Some systems which use the Domain Name Server
(DNS) system may add the cannonical system name as an alias.
<A NAME="permspath"></A> 
<A NAME="xu"></A> <H2><A NAME="ss9.4">9.4 Permission File Location</A>
</H2>

<P>Options used:
<UL>
<LI> <CODE>perms_path=</CODE><EM> directory path list</EM></LI>
<LI> <CODE>xu=</CODE><EM> additional permission file pathname</EM></LI>
</UL>
<P>The <CODE>perms_path=</CODE> configuration variable specifies the
location of the default permissions file.
The default value is:
<PRE>
perms_path=/etc/lpd.perms:/usr/etc/lpd.perms
</PRE>
<P>In addition the
<CODE>xu</CODE>
(extra permissions file) specifies an additional per-printer
permissions file to be used when checking permissions for a particular printer.
<P>The <CODE>lpd.perms</CODE> file can be obtained by running a program,
in a similar manner to the <CODE>/etc/printcap</CODE> file.
See
<A HREF="LPRng-HOWTO-5.html#secfilter">Filters</A> for details on how
the program would be invoked.
For example, assume the configuration information specified:
<PRE>
perms_path=|/usr/local/libexec/get_perms
</PRE>
<P>Then the <CODE>get_perms</CODE> program would be invoked with STDIN attached
to <CODE>/dev/null</CODE> and the complete set of permission information
would be read from its STDOUT.
<H2><A NAME="ss9.5">9.5 Example Permission File</A>
</H2>

<P>
<PRE>
# allow root on server to control jobs
ACCEPT SERVICE=C SERVER REMOTEUSER=root
REJECT SERVICE=C
#
# allow same user on originating host to remove a job
ACCEPT SERVICE=M SAMEHOST SAMEUSER
# allow root on server to remove a job
ACCEPT SERVICE=M SERVER REMOTEUSER=root
REJECT SERVICE=M
# all other operations allowed
DEFAULT ACCEPT
</PRE>
<P>In the above sample, we first specify that
lp<CODE>C</CODE>
commands from user <CODE>root</CODE> on the lpd server will be accepted.
This is traditionally the way that most lpc commands operate.
<P>Next,  we reject any other lpc requests.
<P>We accept
lpr<CODE>M</CODE>
requests from the host and user that submitted the job,
as well as from root on the server,
and reject any others.
<P>Finally,
all other types of commands (lpq, lpr) are allowed by default.
<H2><A NAME="ss9.6">9.6 Complex Permission Checking</A>
</H2>

<P>One of the more useful types of permission checking is to
restrict access to your printers from users outside your
networks.
The IP pattern can specify a list of IP addresses and netmasks
to apply to them.
<P>For example
<CODE>IP=10.3.4.0/24</CODE> would match all hosts with the IP
addresses
<CODE>IP=10.3.4.0</CODE> to
<CODE>IP=10.3.4.255</CODE>.
<P>Similarly, the HOST pattern can specify a set of hostnames
or patterns to match against based on the GLOB notation.
<P>For example
<CODE>REMOTEHOST=*.astart.com</CODE>
would match all hosts with a DNS entry which ended with
<CODE>astart.com</CODE>.
<P>The NOT keyword reverse the match sense.  For example
<CODE>REJECT NOT REMOTEHOST=*.astart.com,*.murpy.com</CODE>
would reject all requests from hosts which did not have a DNS entry
ending in
<CODE>astart.com</CODE>
or
<CODE>murphy.com</CODE>
as one of the host name components.
<H2><A NAME="ss9.7">9.7 More Examples</A>
</H2>

<P>The following is a more complex lpd.perms file.
<PRE>
# All operations allowed except those specifically forbidden
DEFAULT ACCEPT
#Reject connections which do not originate from hosts with an
# address on 130.191.0.0 or from localhost,
# or name is not assigned to Engineering pc's
  REJECT SERVICE=X NOT IFIP=130.191.0.0/16,127.0.0.1/32
  REJECT SERVICE=X NOT REMOTEHOST=engpc*
#Do not allow anybody but root or papowell on
#astart1.astart.com or the server to use control
#facilities.
  ACCEPT SERVICE=C SERVER REMOTEUSER=root
  ACCEPT SERVICE=C REMOTEHOST=astart1.astart.com REMOTEUSER=papowell
#Allow root on talker.astart.com to control printer hpjet
  ACCEPT SERVICE=C HOST=talker.astart.com PRINTER=hpjet REMOTEUSER=root
#Reject all others
  REJECT SERVICE=C
#Do not allow forwarded jobs or requests
  REJECT SERVICE=R,C,M FORWARD
# allow same user on originating host to remove a job
ACCEPT SERVICE=M SAMEHOST SAMEUSER
# allow root on server to remove a job
ACCEPT SERVICE=M SERVER REMOTEUSER=root
</PRE>
<HR>
<A HREF="LPRng-HOWTO-10.html">Next</A>
<A HREF="LPRng-HOWTO-8.html">Previous</A>
<A HREF="LPRng-HOWTO.html#toc9">Contents</A>
</BODY>
</HTML>
