<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
 <META NAME="GENERATOR" CONTENT="SGML-Tools 1.0.9">
 <TITLE> LPRng-HOWTO: Authentication and Encryption</TITLE>
 <LINK HREF="LPRng-HOWTO-17.html" REL=next>
 <LINK HREF="LPRng-HOWTO-15.html" REL=previous>
 <LINK HREF="LPRng-HOWTO.html#toc16" REL=contents>
</HEAD>
<BODY>
<A HREF="LPRng-HOWTO-17.html">Next</A>
<A HREF="LPRng-HOWTO-15.html">Previous</A>
<A HREF="LPRng-HOWTO.html#toc16">Contents</A>
<HR>
<H2><A NAME="authref"></A> <A NAME="s16">16. Authentication and Encryption</A></H2>

<P>One of the major problems in a print spooler system is providing
privacy and authentication services for users.  One method is to
construct a specific set of protocols which will be used for
providing the privacy or authentication;  another is to provide a
simple interface to a set of tools that will do the authentication
and/or encryption.
<P>LPRng provides native support for the LPR extensions used by MIT
and the Kerberos 4 implementation.
In addition,
it provides Kerberos 5 based authentication.
<P>LPRng also supports the use of the PGP (Pretty Good Privacy) program
and can sign and optionally encrypt command and responses between servers
and clients.
<P>Finally,
LPRng provide a general purpose interface allowing users to insert their
own authentication methods,
either at the program level or at the code level.
<H2><A NAME="ss16.1">16.1 Authentication</A>
</H2>

<P>A careful study of the authentication problem shows that it should be done
during reception of commands and/or jobs from a remote user and/or
spooler.  At this time the following must be done:
<OL>
<LI>The received command must be checked for consistency,  and the
remote user and host must be determined.</LI>
<LI>The remote user and host must be authenticated.</LI>
<LI>The command and/or spooling operation must be carried out.</LI>
<LI>The results must be returned to the remote system.</LI>
</OL>
<P>
<H2><A NAME="ss16.2">16.2 Identifiers</A>
</H2>

<P>When a user logs into a system,  they are assigned a user name
and a corresponding UserID.  This user name is used by the LPRng
software when transferring jobs to identify the user.
<P>When we look into the problem of authentication,  we will possibly
have a more global user identification to deal with, the
authentication identifier (AuthID).  One way to deal with this problem is to
give LPRng intimate knowledge of the UserID and AuthID relationship.
While this is possible,  it may be difficult to deal with in a
simple and extensible manner.  An alternate solution is to provide
a mapping service,  where the authentication procedure provides
a map between the UserID and AuthID.
<H2><A NAME="ss16.3">16.3 RFC1179 Protocol Extensions</A>
</H2>

<P>The RFC1179 protocol specifies that a LPD server command sent on
a connection has the form:
<BLOCKQUOTE><CODE>
<PRE>
\nnn[additional fields]\n
</PRE>
</CODE></BLOCKQUOTE>
<P><CODE>\nnn</CODE> is a one octet (byte) value with the following meaning:
<P>
<BLOCKQUOTE><CODE>
<PRE>
REQ_START   1    start printer
REQ_RECV    2    transfer a printer job
REQ_DSHORT  3    print short form of queue status
REQ_DLONG   4    print long form of queue status
REQ_REMOVE  5    remove jobs
</PRE>
</CODE></BLOCKQUOTE>
<P>The LPRng system extends the protocol with the following additional
types:
<BLOCKQUOTE><CODE>
<PRE>
REQ_CONTROL 6    do control operation
REQ_BLOCK   7    transfer a block format print job
REQ_SECURE  8    do operation with authentication
REQ_VERBOSE 9    verbose status information
REQ_LPSTAT 10    lpstat simulation
</PRE>
</CODE></BLOCKQUOTE>
<P>The REQ_CONTROL allows a remote user to send LPC commands to the
server.  The REQ_BLOCK provides an alternate method to transfer a
job.  Rather than transferring the control and data files individually,
this format transfers one file.  The REQ_AUTH provides a mechanism
for providing an authentication mechanism and is described in this
document.
<H2><A NAME="authserverid"></A> <A NAME="authclientfilter"></A> <A NAME="auth"></A> <A NAME="ss16.4">16.4 Client Operations for Client To lpd Server Authentication</A>
</H2>

<P>Options used:
<UL>
<LI> <CODE>auth=</CODE><EM>client to server authentication type</EM></LI>
<LI> <CODE>auth_client_filter=</CODE><EM>client to server transfer program</EM></LI>
<LI> <CODE>auth_forward=</CODE><EM>server to server authentication type</EM></LI>
<LI> <CODE>auth_forward_filter=</CODE><EM>server to server transfer program</EM></LI>
<LI> <CODE>auth_forward_id=</CODE><EM>Server identification</EM></LI>
<LI> <CODE>auth_receive_filter=</CODE><EM>server to server transfer program</EM></LI>
<LI> <CODE>auth_server_id=</CODE><EM>server identification</EM></LI>
</UL>
<P>This section describes the general purpose interface used for
client to server authentication.
<P>The LPRng client will generate a set of commands and place them in a file.
The file is then encrypted and/or signed by the appropriate authentication
method,
and is transferred to the server.
The server will then decrypt and/or check the signature,
perform the requested actions,
and in turn generate a file of status information.
This file is encrypted and/or signed by the server,
and sent to the client,
where it is in turn decrypted and/or checked for correct signature.
These activities are controlled by the following printcap or configuration
options.
<OL>
<LI>The <CODE> auth </CODE> option specifies the authentication type to be used
for client to server transfers.
For example,
<CODE>auth=pgp</CODE> would specify PGP authentication,
<CODE>auth=kerberos5</CODE> would specify Kerberos 5 authentication,
<CODE>auth=kerberos4</CODE> would specify Kerberos 4 authentication,
and
<CODE>auth=user</CODE> would specify using user provided filters for authentication.</LI>
<LI>For client to server operations,
the server id is the value of the
<CODE>auth_server_id</CODE> option.</LI>
<LI>The <CODE>auth_forward</CODE>> option specifies the authentication type to be used
for server to server transfers.</LI>
<LI>For server to server operations,
the id of the originating server
is specified by
<CODE>auth_server_id</CODE>.
and the remote server by
<CODE>auth_forward_id</CODE>.</LI>
<LI>When doing client to server transfers,
the originating user is determined by using the current UID
of the program as the search value for <CODE>getpwuid()</CODE>.</LI>
</OL>
<P>The LPRng client will open a connection to the server
and send a command with the following format:
<BLOCKQUOTE><CODE>
<PRE>
\008printer C userid auth\n         - for commands
\008printer C userid auth jobsize\n - for print jobs
</PRE>
</CODE></BLOCKQUOTE>
<P>Note that \008 is a one byte code indicating an authenticated
transfer.  Printer is the spool queue name, C in the character 'C'
indicating a client request, userid is the login id of the user,
auth is the the value of the <CODE>auth</CODE> option,
and jobsize is the size of the job file to be printed.
<P>On reception of this command,  the server will send a one byte
success code.
If an error is indicated by a non-zero response,
additional error status may follow
the non-zero success code byte.  At the end of this information
the connection will be terminated.
The values used by LPRng are:
<BLOCKQUOTE><CODE>
<PRE>
ACK_SUCCESS 0   success
ACK_STOP_Q  1   failed; no spooling to the remote queue
ACK_RETRY   2   failed; retry later
ACK_FAIL    3   failed; job rejected, no retry
</PRE>
</CODE></BLOCKQUOTE>
<P>If the success code is zero,
client will use the <CODE>auth_client_filter</CODE> to encrypt and/or sign
a data file to be transferred to the server.
The authentication program will have the following IO assignments:
<BLOCKQUOTE><CODE>
<PRE>
FD  Options Purpose
0  R/W     connection to remote host
1  W       output for returned status
2  W       errors
</PRE>
</CODE></BLOCKQUOTE>
<P>Command line arguments:
<BLOCKQUOTE><CODE>
<PRE>
program -C -Pprinter -nuser -Aauth -Rauth_server_id -Ttempfile
</PRE>
</CODE></BLOCKQUOTE>
<P>The <CODE> tempfile </CODE> will contain either a command line as would be
transferred using the standard RFC1179 protocol,
or a print job in block format.
See
<A HREF="LPRng-HOWTO-18.html#rfc1179ref">RFC1179 Protocol</A> for details.
The client authenticator program will open and transfer
the contents of <CODE>tempfile</CODE> to the server authenticator,
using FD 0
and a format compatible with the underlying authentication mechanism.
<P>If the transfer fails the client
authenticator will log error information on FD 2 and then exit
with error code JFAIL.
<P>The server will send the client authentication program
any error or logging information over the FD 0 connection,
in a form appropriate to the authentication operation.
The client authenticator will write this information to FD 1.
If data transfer or authentication fails,  the authenticator
will write an error message to FD 2 and exit with error code
JFAIL.
<P>If no error has occurred the client authenticator will
then exit with error code JSUCC.
<P>
<H2><A NAME="authforwardfilter"></A> <A NAME="authreceivefilter"></A> <A NAME="ss16.5">16.5 Server Operations for Client To lpd Server Authentication</A>
</H2>

<P>Options used:
<UL>
<LI> <CODE>auth_receive_filter=</CODE><EM>Server (lpd) authentication program</EM></LI>
<LI> <CODE>auth_server_id=</CODE><EM>Server identification</EM></LI>
</UL>
<P>When an authentication command arrives at the server,
it has the following form:
<BLOCKQUOTE><CODE>
<PRE>
\008printer C userid auth\n          - for commands
\008printer C userid auth jobsize\n - for print jobs
</PRE>
</CODE></BLOCKQUOTE>
<P>The server will attempt to find the printcap for the specified printer.
For some operations this printer will be a dummy entry;
this will simply cause the following operations to use the default
information in the <CODE>lpd</CODE> configuration.
<P>If a print job is being performed and the spool queue does not exist,
then the job will be rejected.
A non-zero error code will be written to the connection and the operation
will terminate.
<P>The <CODE>auth</CODE> value is used to set the
AUTHTYPE permission checking value.
If the AUTHTYPE is not built in,
and the <CODE>auth</CODE> value does not match the
printcap or configuration
<CODE>auth</CODE> option value then authentication will fail.
An error message will be logged to the server log file,
and a non-zero error code and message will be written to the connection
to the remote client program.
<P>Many authentication programs require that the
users provide some form of key or identification.
The <CODE>userid</CODE> option is used for this purpose.
<P>The server will start the server authenticator program and provide the
following open file descriptors for it.  The program
will run as the same UID as the <CODE>lpd</CODE> server.
If this is a print job transfer,
the current directory will be the spool directory of the print queue.
<BLOCKQUOTE><CODE>
<PRE>
FD  Options Purpose
0  R/W     socket connection to remote host (R/W)
1  W       pipe or file descriptor,  for information for server
2  W       error log
3  R       pipe or file descriptor,  for responses to client
</PRE>
</CODE></BLOCKQUOTE>
<P>Command line arguments:
<BLOCKQUOTE><CODE>
<PRE>
program -S -PPRINTER -nserver_auth_id -aAUTHTYPE -RUSERID -Ttempfile
</PRE>
</CODE></BLOCKQUOTE>
<P>The
<CODE>PRINTER</CODE>,
<CODE>USER</CODE>,
and
<CODE>AUTHTYPE</CODE>,
are obtained from the command sent to the server,
and are the
<CODE>printer</CODE>,
<CODE>user</CODE>,
and
<CODE>authtype</CODE>
values sent.
The
<CODE>server_auth_id</CODE>
is obtained from the printcap or configuration information for this
printer,
and should be identical to the value used by the sending program to
when it invoked the authenticator program.
<P>The authentication filter will read the file transferred by the
client authenticator,
decrypt it,
and place the decrypted values in the tempfile.
It will then write
a
<CODE>from_id</CODE>
string to FD 1,
which will be read by the LPD server
and used as the identification of the originating end of the connection.
<P>If the originating program is an LPRng client,
then the <CODE>from_id</CODE> value will be the user identification for the authentication protocol;
if the originating program is an LPRng server,
this value will be the server identification for the authentication protocol.
<P>After writing this value,
the transfer program will close FD 1.
At this point the LPD server will use the contents of the tempfile to perform
the various requested actions.
<P>If the transfer step or authentication fails,  then the server
authenticator
will write an error message to FD 2 and exit with error code
JFAIL.
<P>The <CODE>lpd</CODE> server will record the
authentication information returned by the server in the
AUTHUSER permissions key.
<P>The <CODE>lpd</CODE> server will perform the usual permissions checks,
with the addition of the indicated permission keys and associated values.
During this process,
any error messages or logging information normally returned to client
programs will be written to the authentication program FD 3.
<P>The <CODE>lpd</CODE> server will carry out either the commands or
print job specified in the temporary file.
During this process,
any error messages or logging information normally returned to client
programs will be written to the authentication program FD 3.
<P>At the end of the operations,
the FD 3 file descriptor will be closed and the <CODE>lpd</CODE> server
will wait for the authentication process to exit.
<P>The server authentication process will read
input from FD 3 until the end of input,
and then transfer the received information to the client
side authenticator.
It may use the tempfile to hold the information during the
reading and transfer process.
<P>If the transfer of the logging information fails,
then the authenticator process will exit with
error code JFAIL, otherwise it will exit with error code JSUCC.
<H2><A NAME="authforward"></A> <A NAME="authforwardid"></A> <A NAME="ss16.6">16.6 lpd Server to Server Authentication</A>
</H2>

<P>Options used:
<UL>
<LI> <CODE>auth_forward=</CODE><EM>Server to server authentication type</EM></LI>
<LI> <CODE>auth_forward_id=</CODE><EM>Destination server authentication id</EM></LI>
</UL>
<P>The Server to Server authentication procedure is used by one server
to forward jobs or commands to another server.  It should be noted
that this forwarding operation puts an implicit trust in the security
of the client to server to server chain.
The <CODE>lpd</CODE> server will perform an authenticated transfer to
another server when it either needs to transfer a job to a remote printer
or when it needs to propagate a
<CODE>lpq</CODE>,
<CODE>lprm</CODE>,
or
<CODE>lprc</CODE> operation.
<P>The procedure used to by the server to send commands and/or jobs
is identical to that used by a client,
with the minor modification that the server is identified as the
originating endpoint of the connection,
and the client authentication information is transferred in the file.
<P>When propagating a command,
the server uses the authentication information provided for the remote
user by the client to server authentication program.
When propagating or forwarding a job,
the server will use the authentication information stored in the job
control or hold file.
This information will be represented as AUTHUSER in the following discussion.
<P>The
<CODE>auth_forward</CODE> option value specifies the type of authentication
to be used to forward authentication,
and the sending server uses the <CODE>auth_server_id</CODE> as its identification,
and the <CODE>auth_forward_id</CODE> as the identification of the remote server.
If there is no user authentication information,
then a normal, non-authenticated transfer will be done.
<P>The <CODE>auth_forward_filter</CODE> will be used for the forwarding
operation.
<P>The sending server takes the part of the client, and will
transfer a job acting similar to a client.  The initial information
transfer from the sending server will have the format:
<BLOCKQUOTE><CODE>
<PRE>
\008printer F local_server_id authtype \n     - for commands
\008printer F local_server_id authtype size\n - for print jobs
</PRE>
</CODE></BLOCKQUOTE>
<P>The sending server will invoke its authenticator with the arguments:
<BLOCKQUOTE><CODE>
<PRE>
auth_forward_filter -F -Pprinter -nlocal_server_id -aauthtype \
-Rremote_server_id -Ttempfile
</PRE>
</CODE></BLOCKQUOTE>
<P>The tempfile containing the job or command information to be sent
will have the form:
<BLOCKQUOTE><CODE>
<PRE>
user_authentication_info\n
&lt;normal file contents>
</PRE>
</CODE></BLOCKQUOTE>

That is,
the user authentication information is placed in the tempfile.
<P>The tempfile will be transferred to the remote server in the same fashion
as for a user job.
Any error or logging information returned will either be written to the
<CODE>lpd</CODE> log file or to the previous <CODE>lpd</CODE> process in
the transfer chain.
<P>On the destination server the same operations
for receiving an authentication request from a client
is performed.
The AUTHUSER, AUTHFROM, and AUTHTYPE permission
checking values will be the derived from the
authentication request as for the client.
The AUTHSAMEUSER will compare the remote client authentication
information and the authentication information used to create the job.
<P>When the remote server receives the authentication request,
it will carry out the same actions as for a client to server transfer,
modified as follows:
<OL>
<LI>The <CODE>lpd</CODE> server will remove the first line of the transferred file,
which contains the user authentication information,
and set
AUTHUSER to this value.</LI>
<LI>Authentication is performed using the indicated values.</LI>
<LI>If authentication succeeds,
then the command line or print job control file is processed
in the normal manner.
This might now add more permissions values to tags,
but the authentication information will not be changed.</LI>
</OL>
<H2><A NAME="ss16.7">16.7 Permission Checking</A>
</H2>

<P>The following patterns and values can be used
to check that a particular type of authentication
has been used,
and what the authenticated user information is.
<UL>
<LI>AUTH - authentication is used</LI>
<LI>AUTHTYPE=globmatch<BR>
<P>This matches the type of authentication request.
Built in values include
<CODE>kerberos4</CODE>,
<CODE>kerberos5</CODE>,
and
<CODE>pgp</CODE>.
</LI>
<LI>AUTHUSER=globmatch<BR>
<P>The originating auth_user_id value.
</LI>
<LI>AUTHFROM=globmatch<BR>
<P>When a command received from a server (i.e.- forwarded by a server),
the value is the the forwarding servers authentication information,
otherwise it is NULL.
</LI>
<LI>AUTHSAMEUSER<BR>
<P>The originating auth_user_id value is compared to the value
used to create the job.
If they are identical,  the match succeeds.
</LI>
</UL>
<P>For example,  to reject non-authenticated operations, the following
line could be put in the permissions file.
<BLOCKQUOTE><CODE>
<PRE>
REJECT NOT AUTH
</PRE>
</CODE></BLOCKQUOTE>
<P>To reject server forwarded authentication as well, we use the following.
Note that the <CODE>?</CODE>  forces a value to be present.
<BLOCKQUOTE><CODE>
<PRE>
REJECT AUTH AUTHFROM=?*
</PRE>
</CODE></BLOCKQUOTE>
<P>If a remote server has id information FFEDBEEFDEAF,  then the
following will accept only forwarded jobs from this server.  Note
that AUTHFROM will only match on authenticated transfers;
FWDUSER will only match on forwarded transfers.
<BLOCKQUOTE><CODE>
<PRE>
ACCEPT AUTH AUTHFROM=FFEDBEEFDEAF
REJECT AUTH
REJECT NOT AUTH
</PRE>
</CODE></BLOCKQUOTE>
<P>To allow only authenticated users to remove jobs you can use:
<BLOCKQUOTE><CODE>
<PRE>
ACCEPT AUTH SERVICE=R,M,L,P AUTHSAMEUSER
REJECT AUTH
REJECT NOT AUTH
</PRE>
</CODE></BLOCKQUOTE>
<H2><A NAME="ss16.8">16.8 Using PGP for Authentication</A>
</H2>

<P>PGP is a well known encryption and authentication program.
For more details see the web site
<A HREF="http://www.pgp.net">http://www.pgp.net</A>
or the ftp site
<A HREF="ftp://ftp.pgp.net">ftp://ftp.pgp.net</A>.
<P>LPRng has greatly simplified the use of PGP for authentication
by building in support as follows.
<P>The LPD server usually runs as user <CODE>daemon</CODE>,
and opens files as
<CODE>daemon</CODE>.
The system administrator should establish a home directory for daemon,
and use the PGP key generation facility to create a public and private key
for the <CODE>daemon</CODE> user.
By default,
the PGP program puts the public and secret key rings in the
<CODE>$HOME/.pgp/</CODE> directory,
and sets them to be readable only by the user.
You should log in temporarily as
<CODE>daemon</CODE>,
run the
<CODE>pgp -kg</CODE>
command,
and then disable logins for <CODE>daemon</CODE>.
<P>The user id chosen for the LPD server should be easily used to identify
the server.
For example,
<CODE>lpr@hostname</CODE>,
where hostname is the fully qualified domain name of the server is useful.
<P>The next step is to place the passphrase in a file that is only readable by
<CODE>daemon</CODE>,
say
<CODE>~daemon/.pgp/serverkey</CODE>,
with owned by <CODE>daemon</CODE>,
and with <CODE>600</CODE> permissions (read/write only by <CODE>daemon</CODE>).
This is extremely important,
as if any other users can read this file then security will be severely compromised.
<P>The next step is to distribute the <CODE>lpr@hostname</CODE> public key to all users of the
LPRng server,
and to place the public keys of LPRng users in the <CODE>daemon</CODE> public key ring.
This can be done using:
<BLOCKQUOTE><CODE>
<PRE>
pgp -kxa userid destfile keyfile

Example:
> pgp -kxa lpr@astart /tmp/lprkey ~daemon/.pgp/pubring.pgp
Key for user ID: lpr@astart
512-bit key, key ID BB261B89, created 1999/01/01

Transport armor file: /tmp/lprkey.asc
Key extracted to file '/tmp/lprkey.asc'.
</PRE>
</CODE></BLOCKQUOTE>
<P>User can add the <CODE>lpr@astart</CODE> key to their public key rings using:
<BLOCKQUOTE><CODE>
<PRE>
pgp -ka /tmp/lprkey.asc
</PRE>
</CODE></BLOCKQUOTE>
<P>Finally,  the administrator will need to add users public keys to the
<CODE>daemon</CODE> users public key ring.  This can most easily be done by
copying all the keys (in ASCII text form) to a single file
(<CODE>/tmp/keyfile</CODE>)and using:
<BLOCKQUOTE><CODE>
<PRE>
pgp -ka /tmp/keyfile ~daemon/.pgp/pubring.pgp
</PRE>
</CODE></BLOCKQUOTE>
<H3><A NAME="pgpserverkey"></A> <A NAME="pgppassphrase"></A> <A NAME="pgppath"></A> PGP Configuration</H3>

<P>Options used:
<UL>
<LI><CODE>pgp_path=</CODE><EM>path to PGP program</EM></LI>
<LI><CODE>pgp_server_key=</CODE><EM>path to server passphrase file</EM></LI>
<LI><CODE>pgp_passphrasefile=</CODE><EM>user passphrase file in PGPPATH or $HOME/.pgp</EM></LI>
</UL>
<P>The <CODE>pgp_path</CODE> option is the path to the PGP program.
<P>The <CODE>pgp_server_key</CODE> is the path to the file containing the server passphrase.
This file will be read by <CODE>lpd</CODE> to get the passphrase to unlock the server's
keyring.
<P>The LPRng client software will check to see if the
<CODE>pgp_passphrasefile</CODE>  value (default <CODE>clientkey</CODE>) file in
<CODE>$PGPPATH</CODE>, and if not present,
then in <CODE>$HOME/.pgp</CODE>.
By default, the <CODE>pass_env</CODE> option is <CODE>pass_env=PGPPASS,PGPPATH,PGPPASSFD</CODE>
and will pass the values of the PGPPATH, PGPPASS,
and PGPPASSFD environment variables.  See below for a method to use these.
<P>Example printcap entry:
<BLOCKQUOTE><CODE>
<PRE>
pr: 
    :lp=pr@wayoff
    :auth=pgp
    :auth_server_id=lpr@wayoff.com
    :pgp_path=/usr/local/bin/pgp
    :pgp_passphrasefile=.mypass
</PRE>
</CODE></BLOCKQUOTE>
<P>One problem with using PGP is the need to have users input their
passphrases.
If the user is daring,  then the pass phrase can be put in the file:
<CODE>  ~/.pgp/clientkey </CODE>.  This file will be read by the
LPRng client program the contents passed to PGP as the passphrase.
This file MUST have 0400 permissions (read only by user)
and MUST owned by the user.
<P>A more subtle solution is to use the <CODE>PGPPASSFD</CODE> environment variable
facility.
This causes PGP to read the passphrase from a file descriptor.
If the user puts his passphrase in a file,  say
<CODE>$(HOME)/.pgp/.hidden</CODE>,
then the following shell script can be used.
<BLOCKQUOTE><CODE>
<PRE>
#!/bin/sh
#  /usr/local/bin/pgplpr script - passphrase in $(HOME)/.pgp/.hidden
#
PGPASSFD=3 3&lt;$(HOME)/.pgp/.hidden lpr "$@"
</PRE>
</CODE></BLOCKQUOTE>
<H3>Permissions</H3>

<P>If you wish to enforce the use of authentication,  then you
should modify the lpd.perms file.  Here are some examples.
<BLOCKQUOTE><CODE>
<PRE>
# force authentication
REJECT NO AUTH
REJECT NO AUTHTYPE=pgp
</PRE>
</CODE></BLOCKQUOTE>
<H3>Client Configuration</H3>

<P>One problem with using PGP is the need to have users input their
passphrases.
If the user is daring,  then the pass phrase can be put in the file:
<CODE>  ~/.pgp/clientkey </CODE>.  This file will be read by the
LPRng client program the contents passed to PGP as the passphrase.
This file MUST have 0400 permissions (read only by user)
and MUST owned by the user.
<P>A more subtle solution is to use the <CODE>PGPPASSFD</CODE> environment variable
facility.
This causes PGP to read the passphrase from a file descriptor.
If the user puts his passphrase in a file,  say
<CODE>$(HOME)/.pgp/.hidden</CODE>,
then the following shell script can be used.
<BLOCKQUOTE><CODE>
<PRE>
#!/bin/sh
#  /usr/local/bin/pgplpr script - passphrase in $(HOME)/.pgp/.hidden
#
PGPASSFD=3 3&lt;$(HOME)/.pgp/.hidden lpr "$@"
</PRE>
</CODE></BLOCKQUOTE>
<P>By using the -V (verbose) flag,  users can see the results of the
PGP interaction.
<H2><A NAME="ss16.9">16.9 Using Kerberos 5 for Authentication</A>
</H2>

<P>LPRng Kerberos 5 authentication is
based on the
Kerberos5-1.0.5 release as of March 28, 1999.  This was obtained
from MIT:
<OL>
<LI> ftp to ATHENA-DIST.MIT.EDU (18.159.0.42), login anonymous, password
your_email_address</LI>
<LI> Change into the directory '/pub/kerberos/</LI>
<LI> Get the README files and look at the details of using FTP to get
the distribution.  Note that there are also patches available
which you might want to use.</LI>
</OL>
<P>Note that the distribution has only the most superficial documentation.
There are no man pages for any of the support libraries, etc. etc.
<H3><A NAME="kerberosforwardprincipal"></A> <A NAME="kerberosserverprincipal"></A> <A NAME="kerberosservice"></A> <A NAME="kerberosrenew"></A> <A NAME="kerberoslife"></A> <A NAME="kerberoskeytab"></A> Kerberos Installation Procedure</H3>

<P>
<OL>
<LI> Get the Kerberos 5 distribution.</LI>
<LI> Compile and install the distribution.</LI>
<LI> Create the /etc/krb5.conf, /usr/local/var/krb5kdc/kdc.conf
files using templates from the src/conf-files subdirectory.
See the Installation notes and the System Administrators Guide.</LI>
<LI> Don't forget to create the /usr/local/var/krb5kdc/kdc.acl file;
I did and it took me HOURS to figure out what was wrong...</LI>
<LI> Start up the KDC and KADMIN servers - you might want to put
the following in your rc.local or equivalent file:
<BLOCKQUOTE><CODE>
<PRE>
if [ -f /etc/krb5.conf -a -f /usr/local/var/krb5kdc/kdc.conf  ]; then
    echo -n ' krb5kdc ';    /usr/local/sbin/krb5kdc;
    echo -n ' kadmind ';    /usr/local/sbin/kadmind;
fi
</PRE>
</CODE></BLOCKQUOTE>
</LI>
<LI> use kadmin (or kadmin.local) to create principals for your users.</LI>
<LI> Now you need to create principals for the lprng servers.  I have been
using
<CODE>lpr/hostname.REALM</CODE>
as a template-
i.e.
<CODE>lpr/astart1.astart.com@ASTART.COM</CODE>
for an example.
<P>Do this for all the servers.  You should use fully qualified domain names
for the principals.
</LI>
<LI> Now you need to extract the keytab for each of the servers:
<BLOCKQUOTE><CODE>
<PRE>
kadmin ...
ktadd -k file_for_host  lpr/hostname.REALM
</PRE>
</CODE></BLOCKQUOTE>

<P>The 'file_for_host' contains the keytab information, which is the
equivalent information for the server.
</LI>
<LI> Copy the 'file_for_host' to the server (you might want to encrypt
or use a secure transfer for this).  You need to put this in
<CODE>/etc/lpd.keytab</CODE>.
Make sure that this file is readable only by user <CODE>daemon</CODE>,
as it will try to read the file to get its server key.
<BLOCKQUOTE><CODE>
<PRE>
#> ls -l /etc/lpd.keytab
-rw-------  1 daemon  wheel  128 Jan 16 11:06 /etc/lpd.keytab
</PRE>
</CODE></BLOCKQUOTE>
</LI>
<LI> Modify (uncomment) the following entries in <CODE>/etc/lpd.conf</CODE>:
<BLOCKQUOTE><CODE>
<PRE>
auth=kerberos5
kerberos_keytab=/etc/lpd.keytab
kerberos_service=lpr
# optional - explicit prinicpal name for server, used by clients
#kerberos_server_principal=lpr/hostname@REALM
# optional - forwarding to another server with authentication
# kerberos_forward_principal=lpr/hostname@REALM
</PRE>
</CODE></BLOCKQUOTE>

<P>The
<CODE>kerberos_keytab</CODE>
entry is the location of the keytab file;
kerberos_service is the service that will be used to generate
a server principal name.
This is the
<CODE>lpr</CODE>
used in the above key generation operations.
<P>kerberos_life and kerberos_renew determine the lifetime and renewability
of Kerberos tickets.  The lifetime defaults to 10
hours,  and the ticket will be refreshed when it expires
if necessary.
</LI>
<LI>You might like to check out the authentication using the sclient and
sserver test programs.  These link in the kerberos authentication and
allow you to test it without all of LPD being involved.
<BLOCKQUOTE><CODE>
<PRE>
cd LPRng/src; make sserver sclient
usage: sserver [-D] [-p port] [-s service] [-S keytab] file
   -D turns debugging on
   1. opens TCP   port 'port' (default 1234)
   2. waits for a connection
   3. when a connection comes in,  uses 'service' to get the principal
       name of the server,  and looks up the key in keytab file.
   4. Goes through the kerberos authentication.
   5. Copies the input from remote server to 'file'
   6. exits.
 usage: sclient [-D] [-p port] [-s service] host file
   -D turns debugging on
   1. opens a connection to port on host (i.e. - host%port)
   2. does the authentication.  You must have done kinit to get
       for your ticket to be valid.
   3. sends the file to remote host.
</PRE>
</CODE></BLOCKQUOTE>

<P>To test this, start up sserver on one host/window, then run sclient.
The error messages are pretty straight forward,
and when in doubt,
look at the source code which has more than sufficient information.
</LI>
</OL>
<H3>Testing Transfers</H3>

<P>Restart the server,
and then try getting information using LPQ.
<P>You can turn on tracing at LPQ to see if authentication is being used
and is working:
<BLOCKQUOTE><CODE>
<PRE>
lpq -Dnetwork,database 
</PRE>
</CODE></BLOCKQUOTE>
<P>If the lpq works,
then try send a job and see if the transfer is successful.
<H3>Explicit Server Principal Name</H3>

<P>If you are using printers in different domains,  then you can
put the explicit principal name of the server in the printcap file,
using the server_principal entry.  For example:
<BLOCKQUOTE><CODE>
<PRE>
lp_offsite
    :lp=printer@erehwon.org
    :auth=kerberos5
    :auth_server_id=lpr/erehwon.org@BLUESKY.ORG
</PRE>
</CODE></BLOCKQUOTE>
<H2><A NAME="ss16.10">16.10 Using Kerberos 4 for Authentication</A>
</H2>

<P>LPRng has built-in support for the Project Athena extensions to the
RFC1179 protocol.
These provide an extremely simple authentication protocol
using an initial credential exchange.
After the initial exchange the usual RFC1179 protocol is used.
<P>To enable Kerberos 4 support,
you must modify the <CODE>LPRng/src/Makefile</CODE> and recompile
the LPRng code.
You should be aware that this is not a supported extension,
and is provided as a courtesy to MIT and Project Athena.
<HR>
<A HREF="LPRng-HOWTO-17.html">Next</A>
<A HREF="LPRng-HOWTO-15.html">Previous</A>
<A HREF="LPRng-HOWTO.html#toc16">Contents</A>
</BODY>
</HTML>
