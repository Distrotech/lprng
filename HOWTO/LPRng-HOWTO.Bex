\documentclass[a4paper]{article}
\usepackage{linuxdoc-sgml}
\usepackage{qwertz}
\usepackage{url}
\usepackage[latin1]{inputenc}
\usepackage{epsfig}
\usepackage{null}
\def\addbibtoc{
\addcontentsline{toc}{section}{\numberline{\mbox{}}\relax\bibname}
}%end-preamble
\title{ LPRng-HOWTO}
\author{Patrick Powell {\ttfamily \url{papowell@astart.com}}}
\date{ 1 Jan 1998 (For LPRng-3.4.1)}
\abstract{The LPRng software is an enhanced, extended, and portable implementation
of the Berkeley LPR print spooler functionality. While providing the same
interface and meeting RFC1179 requirements, the implementation is completely
new and provides support for the following features: lightweight (no databases
needed) lpr, lpc, and lprm programs; dynamic redirection of print queues;
automatic job holding; highly verbose diagnostics; multiple printers serving
a single queue; client programs do not need to run SUID root; greatly enhanced
security checks; and a greatly improved permission and authorization mechanism.
The source software compiles and runs on a wide variety of UNIX systems,
and is compatible with other print spoolers and network printers that use
the LPR interface and meet RFC1179 requirements. The package comes with filters for PostScript and HP printers, as well
as the usual 'dumb' printers. Note that the PostScript and HP filters do
page counting and produce accounting information accounting. In addition,
there are a wide variety of other filters that can do page formatting,
and produce banner pages. For users that require compatibility with the SVR4 lp and lpstat interface,
lpr and lpq will simulate this interface, eliminating the need for another
print spooler package. In addition, a publically available PCNFSD server
is distributed with LPRng, and interfaces with the PC/DOS/Windows based
NFS style print spoolers. For users that require secure and/or authenticated printing support,
LPRng supports Kerberos V and/or PGP authentication methods. Additional
authentication support is extremely simple to add. }


\begin{document}
\maketitle
\tableofcontents

\section{Introduction}

This document is an attempt to provide some simple guidelines to set
up LPRng. It is aimed at system managers who want to replace their
vendor's printer daemon and its clients by LPRng.

LPRng can be configured in many ways, making it suitable for a broad
range of applications. It has a large amount of options which are
explained in the extensive documentation.

Despite (or due to) the extent of the documenting files, many new
users experience problems in setting up the package. One of the
reasons is that most of the LPRng documentation
assumed that you already have a
working knowledge of a BSD-style printer spooler.

In this document,
I will first try to give some simple guidelines that
should enable you to put together a simple working configuration
without being overwhelmed by options.
Next, there are some detailed descriptions of the way that LPRng
does things.
Finally,
there are detailed discussions about various LPRng facilities that
try to encapsulate common configurations and operations
that administrators and users encounter.
\label{secfeatures}


\subsection{What is LPRng?}

Gordon Haverland ({\ttfamily haverlan@agric.gov.ab.ca}) put it this way:

\begin{quotation}
LPRng is a print spooling system. It was designed to mimic the
Berkeley (University of California - Berkeley) Line Printers (LPR)
package, first found on Berkeley derivatives of the Unix operating
system. The LPRng package supports users being able to print a
document with little or no knowledge of the content or special
processing required to print the document; on a stand-alone machine,
on a LAN, or remotely. New (as compared to Berkeley LPR) features
include: lightweight {\ttfamily lpr}, {\ttfamily lpc} and {\ttfamily lprm}
programs; dynamic redirection of print queues; automatic job holding;
highly verbose diagnostics; multiple printers per queue; and enhanced
security (SUID not required in most environments (Sun/Solaris is an
exception), improved file permissions, authorization checks, ...),
etc.
\end{quotation}


Patrick Powell
({\ttfamily $<$papowell@astart.com$>$}), the author of
LPRng, has the following comments:
\begin{quotation}
LPRng started life in 1986 as PLP (Public Line Printer),
a replacement for the original BSD LPD code.
This was a one-shot effort to develop code that could be freely redistributed
without the restrictions of the BSD/AT\&T license,
and would allow non-license sites to fix and patch problems that they were
having with print spooling.
(This was before the Free Software Foundation.)
From 1988 to 1992, various groups added features, hacked, and modified the
PLP code, coordinated largely by Justin Mason
({\ttfamily $<$jmason@iona.ie$>$}),
who also started and sponsors the LPRng mailing list (see below).

In 1992,  I redesigned and reimplemented the PLP code
and named the result LPRng.
The goals of the LPRng project were to build a server system that was as
close to user abuse proof as possible,
that would provide services limited only by the inherent capacities of the
support system,
RFC1179 compliant,
and with extensive debugging capabilities to allow
quick and easy diagnostics of problems.
Over the period from 1994-1997,
LPRng users have suggested extensions,
provided patches,
and
added facilities.
I have tried to incorporate these in a controlled and cautious manner.

As a side effect of this work,
many security problems that could develop were identified and steps
taken to ensure that they were not present in LPRng.
For example,
if you want, you can run LPRng clients
such as lpr, lprm, lpc, and lpq as a non-privileged user;
this reduces the chances of users exploiting faults in the code and
gaining root privileges.
Bounds checking is performed on all input and formatting (for example,
snprintf() rather
than sprintf() is used),
as well as other preventive measures where appropriate.

\end{quotation}


In most cases, LPRng is {\bfseries not}
a drop-in replacement for BSD LPR. For most installations, you will
need adaptations.
However,
most of the changes are minor,
and many of the LPRng facilities are backwards compatible with
existing BSD print spooler facilities.

\label{maillist}


\subsection{More Information}

Much of the material in the LPRng documentation has been
included in this document.
For example,
previous releases of LPRng had a large selection of README files;
most of these are now incorporated into the HOWTO document.

Current information
about LPRng and the latest release
can be found on the LPRng web page:
\url{http://www.astart.com/LPRng.html}

There is also a mailing list at {\ttfamily lprng@iona.com}. To subscribe,
send an email to {\ttfamily lprng-request@iona.com}. The body should contain
only the word `subscribe'. To get off the list later on, repeat the
same procedure, but use the word `unsubscribe'.

The LPRng distribution has a DOC directory that contains
several documents that are very helpful.
{\bfseries DOC/Intro.ps} (Intro.txt for a slightly less readable text version) gives
an overview of the BSD/LPRng printing model,
and describes how LPRng carries out the printing process.
{\bfseries DOC/Install.ps} (or Install.txt)
gives an overly detailed description of the LPRng installation and porting
procedures;  the README.installation file in the distribution is much shorter
and contains all of the information needed for the average installer.
The
{\bfseries DOC/Tutorial.ps} (or Tutorial.txt) is a very short tutorial that
uses the non-privileged mode of LPRng which was designed for testing and
tutorial purposes.

Several presentations of LPRng and print spooling software have been made
at the Large Scale Installation Administrator (LISA) conferences and
are in the LPRng distribution and available on web sites.
\url{LPRng - An Enhanced Printer Spooler System}
was presented at the LISA95 conference,
and is in the LPRng distribution as DOC/LPRng-LISA95.ps.
On a more general topic,
the slides for the LISA97 tutorial on
\url{Printers and Network Print Spooling}
are also in the LPRng distribution in the DOC/LISA97 directory.

The LPRng distribution also has a set of man pages (in the man/ directory)
that are the reference for the LPRng operation.
When in doubt, please consult them.


\subsection{Copyright}

Material included in this document from the LPRng distribution
Copyright Patrick Powell 1988-1997, where applicable.

The rights to distribute this document complete or in part are hereby
granted for non-commercial purposes. Partial reproductions must
acknowledge the source.

Permission to distribute this file together with LPRng and `derived
works' (as defined in the LPRng license) is explicitly granted. This
is allowed independent of the license under which the software is
distributed.

Citing the document is allowed as long as the source is acknowledged.


\subsection{Disclaimer}

{\bfseries THE MATERIAL IN THIS HOWTO IS PROVIDED WITHOUT FEE AND AS-IS WITH NO
WARRANTY REGARDING FITNESS OF USE FOR ANY PURPOSE. THE AUTHOR AND ALL
CONTRIBUTORS ARE NOT LIABLE FOR ANY DAMAGES, DIRECT OR INDIRECT,
RESULTING FROM THE USE OF INFORMATION PROVIDED IN THIS DOCUMENT.}


\subsection{Commercial Support}

\url{AStArt Technologies}
provides commercial support and enhancements for
the LPRng and other network software.
AStArt provides network and system consulting services for UNIX and NT
systems, as well as real time and network software.


\subsection{Web Site}

Web Page:
\url{http://www.astart.com/lprng.html}
\label{secftp}


\subsection{FTP Sites}

The software may be obtained from \\ 
\url{ftp://ftp.astart.com/pub/LPRng}(Main site)\\ 

Mirrors:\\ 
\url{ftp://ftp.iona.ie/pub/plp/LPRng}(IE)\\ 
\url{ftp://gwynne.cs.ualberta.ca/pub/LPRng}(Canada)\\ 
\url{ftp://ftp.informatik.uni-hamburg.de/pub/os/unix/utils/LPRng} (DE)\\ 
\url{ftp://ftp.uni-paderborn.de/pub/unix/printer/plp/LPRng}(DE)\\ 
\url{ftp://ftp.cs.umn.edu/pub/LPRng}(US)\\ 
\url{ftp://ftp.zod.wau.nl/pub/mirror/plp/LPRng}(AU/NZ)\\ 
\url{ftp://ftp.lps.ens.fr/pub/software/plp/LPRng}(FR)\\ 
\url{ftp://ftp.mono.org/pub/LPRng}(UK)\\ 


\subsection{Mailing List}

To join the LPRng mailing list, please send mail to
\url{lprng-request@iona.ie}with the word 'subscribe' in the BODY
\label{faqref}


\subsection{PGP Public Key}

The LPRng distributions have an MD5 checksum calculated,
which is then signed with a PGP public key.
Here is the key for validating the checksums:
\begin{verbatim}
Type Bits/KeyID    Date       User ID
pub  1024/00D95C9D 1997/01/31 Patrick A. Powell <papowell@astart.com>
                              Patrick A. Powell <papowell@sdsu.edu>

-----BEGIN PGP PUBLIC KEY BLOCK-----
Version: 2.6.3i

mQCNAzLygTQAAAEEANBW5fPYjN3wSAnP9xWOUc3CvsMUxjip0cN2sY5qrdoJyIhn
qbAspBopR+tGQfyp5T7C21yfWRRnfXmoJ3FVtgToAsJUYmzoSFY08eDx+rmSqCLe
rdJjX8aG8jVXpGipEo9U4QsUK+OKzx3/y/OaK4cizoWqKvy1l4lEzDsA2VydAAUT
tCdQYXRyaWNrIEEuIFBvd2VsbCA8cGFwb3dlbGxAYXN0YXJ0LmNvbT6JAJUDBRA0
XonoiUTMOwDZXJ0BAQ2cBAC7zU9Fn3sC3x0USJ+3vjhg/qA+Gjb5Fi1dJd4solc4
vJvtf0UL/1/rGipbR+A0XHpHzJUMP9ZfJzKZjaK/d0ZBNlS3i+JnypypeQiAqo9t
FV0OyUCwDfWybgAORuAa2V6UJnAhvj/7TpxMmCApolaIb4yFyKunHa8aBxN+17Ro
rrQlUGF0cmljayBBLiBQb3dlbGwgPHBhcG93ZWxsQHNkc3UuZWR1PokAlQMFEDLy
gTSJRMw7ANlcnQEBYBYD/0zTeoiDNnI+NjaIei6+6z6oakqO70qFVx0FG3aP3kRH
WlDhdtFaAuaMRh+RItHfFfcHhw5K7jiJdgKiTgGfj5Vt3OdHYkeeh/sddqgf9YnS
tpj0u5NfrotPTUw39n6YTgS5/aW0PQfO9dx7jVUcGeod1TGXTe9mIhDMwDJI4J14
=3Zbp
-----END PGP PUBLIC KEY BLOCK-----
\end{verbatim}



\section{The Most Frequently Asked Questions}

In this section, the Most Frequently Asked Questions
have been placed, together with their answers.
You may notice that some questions have the same answer,
but the symptoms appear differently.

Some of these answers will reference other material in this FAQ,
or the LPRng man pages.


\subsection{Why do I get malformed from address errors?}

This is the number one question asked by most LPRng users
who try to use LPRng with network printers or other systems
supporting
\ref{rfc1179} {(RFC1179)} printing.
For details about LPRng and RFC1179, see
\ref{rfc1179ref} {(RFC1179 and LPRng)}.

The
{\ttfamily  malformed from address } error is usually reported when
trying to send a print job from LPRng to other BSD LPR or RFC1179
LPR implementations, or with network connected printers
that have a built in LPR server.
This is due to the following RFC1179 rule:
\begin{quotation}
Servers originate a connection from ports in the range 721-731.
\end{quotation}


WHY?  These are a subset of the 'reserved' ports in UNIX, and normal users
cannot open connections from them.  This provides a small amount
of security from UNIX users on the host 'spoofing' a server.

IMPLICATION:  in order to do use a reserved port,  the program
must have root privileges.  This means the LPR, LPD, LPQ, etc.,
programs must be installed SUID root.  This can open up a can
of worms with regard to security,  but LPRng has been designed to
take as much paranoid care as possible to avoid problems.

WHAT TO DO:\\ 
When installing LPRng,  you will need to install the executables
SUID root.
In the src/Makefile,  you can remove the comment from the line
\begin{verbatim}
PERMS=SUID_ROOT_PERMS
\end{verbatim}

and then do {\ttfamily  make install}.
This will install the executables
SUID, and owned by root.


\subsection{It was working normally, then I get connection refused errors}

This message usually appears when you have been sending a large number
of jobs to a network printer or a remote system.
The reason for this is a combination the above port 721-731 restriction
and the TCP/IP timeouts.
For details, see
\ref{rfc1179ref} {(RFC1179 and LPRng)},
but here is a quick explanation.

A TCP/IP connection is usually specified as between
{\ttfamily srchost:srcport, desthost:destport},
although in practice the order of source (src) and destination
(dest) is not important.

When a connection is established,  each end of the connection
exchanges the necessary flow control and error control information.
When a connection is terminated,
each end of the connection will not accept another connection from
the same {\ttfamily host:port} that was previously active
for a specified timeout period,
usually 10 minutes.

Some TCP/IP implementations go further:  they will not allow
{\bfseries ANY} connection to be {\bfseries originated}
(via the {\ttfamily bind()} system call or API)
from a port that was active,
or accepted on a port that was active for this timeout period.

Now let us see what happens when we have a client program,
which must originate a connection on port 721-731, connect
to the server, which waits for a connection on port 515.
We first try to make a connection from host:port
{\ttfamily 1.1.1.1:721} to
{\ttfamily 1.1.1.2:515}.
The first time that we make the connection (or the first connection)
we succeed.
We can transfer a file, etc., and then close the connection.
When we try to reconnect from
{\ttfamily 1.1.1.1:721} to
{\ttfamily 1.1.1.2:515}
we get an error such as
"address already in use"
or "connection refused".

Luckily,  we can use port 722 to originate a connection,
and we can connect from
{\ttfamily 1.1.1.1:722} to
{\ttfamily 1.1.1.2:515}.
We continue on, until we come to port 731,
and then we need to wait for our timeouts.

SOLUTION:

It appears that most RFC1179 implementations do not check for the exact
port
range 721-731,  but only that the connection originates from a
reserved port,
i.e. - in the range 1-1023.
You can extend the range of ports used by LPRng by changing the
\begin{verbatim}
originate_port=721 731
\end{verbatim}

value in the defaults (src/common/defaults.c) file or in the lpd.conf
file.  I recommend the following:
\begin{verbatim}
originate_port=512 1022
\end{verbatim}

This is, in fact, now the default in LPRng software.
If you get the infamous
{\ttfamily malformed from address}
error message from your spooler, then
you will have to set originate\_port=721 731,  and live with
a delayed throughput.


\subsection{Job is not in print queue, but it gets printed!}

In the original BSD LPD implementation,
the LPR program copied users files to a special spool queue directory,
and then caused the LPD server to peek in the directory and print
the files.

This type of operation required spool directory space,
special SETUID programs,
and a slew of headaches in system security and management.

The LPR, LPQ, and other user programs in the LPRng suite use TCP/IP
connections and transfer jobs directly to a LPD server running on
a remote host,
or even the local host if appropriate.
Note that this type of operation does not require a LPD server to run
on each local machine.
In fact,  you can have a single host system performing all of your
printing.
This type of operation is very similar to a central mail server versus
individual systems, each having their own mail server and queues.

However,
some users require or want their jobs to be spooled on the local host system,
and then transferred to the remote printer.
This is usually the case when some type of processing (filtering)
is needed in order to print the job correctly.
There are several methods that can be used to force this.
Method 1: Explicit Printer Address

You can force a job to be sent directly to the {\ttfamily  pr }
serviced by the LPD server on
{\ttfamily host}
by using the form:
\begin{verbatim}
lpr -Ppr@host file
\end{verbatim}


You can also set the {\ttfamily PRINTER} environment variable to
a similar form, and get the same effect:
\begin{verbatim}
PRINTER=pr@host; export PRINTER;
lpr file
\end{verbatim}


Method 2: User and Server Printcap Entries

If you want to have the benefits of a printcap file,
i.e. - you can use aliases or abbreviations for the names of printers,
then here is a couple of hints.
First,
the LPRng software scans the {\ttfamily /etc/printcap} file for printcap
entries, combining information for the same printer into a single entry.
Information found later in the printcap file will override earlier
information.
In addition,
you can tag entries as either being used for all utilities or just
for the LPD server.
Here are a couple of examples:
\begin{verbatim}
# for all utilities
pr:lp=pr@host
# just for LPD
pr:server
  :lp=/dev/lp
# more information
pr:check_for_nonprintable@
# --- final result for LPR
pr:lp=pr@host:check_for_nonprintable@
# --- final result for LPD
pr:lp=/dev/lp:check_for_nonprintable@
\end{verbatim}


As you can see,
the {\ttfamily server}
keywork indicates that the printcap entry is only for the printer.
The LPR utility will send the job to the host, while the LPD server
will print it on {\ttfamily /dev/lp}.

Note that the {\ttfamily lp=...} information overrides the
{\ttfamily :rp:} (remote printer)
and
{\ttfamily :rm:} (remote machine) fields if they are present.
Method 3: Force sending to server on {\ttfamily localhost}

The
{\ttfamily force\_localhost}
printcap or configuration flag forces non-LPD applications to send all
requests and print jobs to the server running on the local host.

This method is similar to the previous one,
but has the benefit that it can be configured as a global (i.e. -
applies to all printers) rather than printer specific.
You can put this in the {\ttfamily /etc/lpd.conf} file for general
application,  or have a printcap entry of the following form:
\begin{verbatim}
# for all utilities
pr:lp=pr@host:force_localhost
\end{verbatim}


The LPD server will ignore the
{\ttfamily force\_localhost} flag,
and send jobs to the {\ttfamily pr} queue on the {\ttfamily host}
machine.
However, the LPR, LPQ, etc., utilities will send their requests to the
server running on the local host.


\subsection{Job disappears and is never printed, but lpr works}

This is a rather disconcerting problem,
and usually occurs when sending jobs to either a network printer or
a nonconforming
\ref{rfc1179} {(RFC1179)}.
print spooler.
For details about LPRng and RFC1179, see
\ref{rfc1179ref} {(RFC1179 and LPRng)},
but here is a quick explanation.

An LPD job consists of a control file,  which contains information
about the job,  and one or more data files.  RFC1179 is silent on the
order that jobs are sent;  however some implementations REQUIRE that
the data files be sent first,  followed by the control file.

SOLUTION:

Set the 'send\_data\_first' flag in the printcap for the particular
printer,  or in the lpd.conf configuration file.  This is:
\begin{verbatim}
:send_data_first:  (printcap)
send_data_first    (lpd.conf)
\end{verbatim}


Note that some printers/servers INSIST on the control file first;
You can clear the flag using {\ttfamily send\_job\_first@} if you need to.


\subsection{I get messages about bad control file format}

RFC1179 describes a set of fields that MAY appear in the control file.
It is silent if other ones can appear as well.
Unfortunately,  some implementations will reject jobs unless they contain
ONLY fields from a very small set.  In addition,  RFC1179 is silent
about the ORDER the fields can appear.

LPRng quite happily will accept jobs from poor or nonconforming RFC1179
spooler programs,
but may chatter about bad formats.
You can ignore these errors,  or even turn them off by modifying the
appropriate lines of code and recompiling.

If you are sending jobs to one of these spoolers,
you can force LPRng to send jobs with only the fields described
in RFC1179 and in the BSD LPD implementation by setting the
the {\ttfamily  :bk: } (BacKwards compatible) flag in the
printcap for your printer.
\label{rfc1179}


\subsection{What is RFC 1179, the Line Printer Daemon Protocol?}

RFC1179 defines a standard method by which print jobs can be transferred
using the TCP/IP protocol between hosts.
The standard was developed by simply detailing the way that
a version of the BSD LPD software did its job.

From the RFC Introduction:
\begin{quotation}
RFC 1179 describes a print server protocol widely used on
the Internet for communicating between line printer daemons (both
clients and servers).  RFC1179 is for informational purposes only,
and does not specify an Internet standard.
\end{quotation}


Having said this,
the RFC then goes on to describe the protocol used
by a particular implementation of LPD.
The problem was that the RFC did not provide
any way to put extensions to the operations into the system,
and failed to specify such interesting details as the order in which
print jobs and their components could be transferred.

Comment by Patrick Powell {\ttfamily  $<$papowell@astart.com{$>$} }:
\begin{quotation}
Since 1988,
there have been a large number of print spooling systems developed which
claim RFC1179 conformance,
but which are mutually incompatible.

Rather than live with the limited capabilities of the RFC1179 standard,
LPRng has extended them by adding capabilities to perform remote control
of print spoolers,
encrypted and authenticated data transfers,
and other operations missing from the RFC1179 specification.
However,
great effort was made to be backwards compatible with older and other LPD
based systems.

LPRng was developed in order to be able to both accept and provide
interactions with these systems.  It does so by allowing various options
to be used to {\itshape tune\/} how print jobs would be exchanged.
Currently,
LPRng can be configured to send and receive print jobs between a vast number
of the existing spooling systems.
It is flexible enough to act as a gateway between non-compatible systems,
and has provisions to transform jobs from one format to another in a dynamic
manner.

\end{quotation}


For a detailed explanation
about LPRng and RFC1179, see
\ref{rfc1179ref} {(RFC1179 and LPRng)}.


\subsection{I want to replace lp, lpstat, etc, but my programs need them}

LPRng was designed as a replacement the BSD printing system. As such,
it inherited its command names and options from the latter. As you
might know, System~V uses a totally different set of commands,
incompatible with the BSD ones.

The good news is that the LPRng binaries include an emulation for the
System~V commands.
(See
\ref{lpsimulation} {(lp Simulation)}
for details.
Briefly, you create links to the appropriate programs,
and invoke them by the link names.
{\itshape Actually, these links are installed by default in recent versions.\/}

\begin{verbatim}
ln -s lpr lp
ln -s lpq lpstat
ln -s lprm cancel
\end{verbatim}


If you make these links, calling {\ttfamily lp}, {\ttfamily lpstat} and
{\ttfamily cancel} will give you a (partial) SVR4 emulation. They have
their own man pages, which you should read if you need the emulation.

Since it is a {\bfseries partial} emulation, you shouldn't expect everything
to work. In particular, I would guess that any script which relies on
the output format of one of your system binaries will break.
Again, see
\ref{lpsimulation} {(lp Simulation)}
for more details or additional suggestions.


\subsection{What are the drawbacks to LPRng?}

There are many reasons to run LPRng, and most of them are related to
the extra features it has, compared to vanilla BSD LPR. A short list
is given in section
\ref{secfeatures} {(What is LPRng?)}. (A
more elaborate description can be found in the LPRng package itself.)

On the other hand, there are also reasons {\bfseries not} to switch to LPRng:
\begin{itemize}
\item It is a complex system, and you'll probably need a lot of time
to get it working.
\item Switching from a System~V system will require even more work.
On the other hand,
getting System~V printing to work correctly for you may be even more work.
\item You don't need any of the enhanced features,
and are not worried about security issues.
\item While there are many resources and books devoted to the old BSD
printer daemon, documentation for LPRng is rather limited: apart from
the
Introduction documents in the distribution package,
there's only this HOWTO
(at least, to the best of my knowledge).
\end{itemize}


You should take these elements into account while deciding whether to
stick with your old software or not. If you do not decide in favor of
LPRng, you can stop reading here.
\label{installref}


\section{Installing your printer}

In the following text, I will assume that your printer itself is
working properly. I.e., you are able to send data to the printer in
such a way that it responds by - well, printing the text :)

How to ensure this, is highly system-dependent, and falls outside the
scope of this document.
However,  here are some hints.


\subsection{Parallel Printers}

Gordon Haverland
{\ttfamily $<$haverlan@agric.gov.ab.ca}$>$ supplied this little script,
that will put you on the right track:
\begin{verbatim}
#!/bin/sh
#set -v -x              # uncomment for debugging
PATH=/bin:/usr/bin
printer=
for $i in $*;
do
    case $i in
        /dev/*) printer=$i ;;
        *) ;;
    esac
done

if test -z "$printer";
then
    echo USAGE: $0 device_name ;
    exit 1;
fi;

echo PRINTER TEST to $printer 1>&2
for i in 1 2 3 4 5 6 7 8 9;
do
    echo $i > $printer;
done
echo -e \\r\\f > $printer
exit 0;
\end{verbatim}


If your printer is connected to the device name you provided,
then you should get a page of something out.  If the output
suffers from the ``staircase'' effect, you will see the numbers
``marching'' across the page, otherwise the numbers will all be in
a single column.
\label{secserial}


\subsection{Serial Printers}

If your printer is attached by a serial line,
then you may need to set the serial line characteristictics before sending
the job to the printer.
Here are a set of guidelines to following when attaching a serial port printer
to a serial line.

1. Check to make sure that the line is not enabled for login.
Logins are usually managed by the
{\ttfamily getty} (BSD)
or
{\ttfamily ttymon} (Solaris, SystemV).
Check your system documentation and make sure that these daemons are not
managing the serial line.

2. Check the permissions and ownership of the serial line.
For the most easy testing,
set the permissions to 0666 (everybody can open for reading and writing).
After you have made sure that you can send jobs to the printer,
you might want to change the ownership of the serial line to the LPD server
and change the permissions to 0600.

3. Make sure that you can print a test file on the printer via the
serial port.
This may require setting the line characteristictics and then sending
a file to the printer.
You should try to use 8 bit, no parity, with hardware flow control
and no special character interpretation,
and definitely no LF to CR/LF translation.
The problem is that different versions of UNIX systems have different
sets of stty(1) commands to do this.
The following simple test script can help in this.
\begin{verbatim}
#!/bin/sh
# 9600, no echo, no CR
FLAGS= 9600 -raw -parenb cs8 crtscts
DEV= /dev/tty01
(stty $FLAGS; stty 1>&2; cat $1 ) <$DEV >$DEV
\end{verbatim}


This shows using stty to set the flags,
then to print the current settings, and then using
cat a file to the output.
If you attach a dumb terminal to the serial port,
you can even use this script to ensure that input from the device
is echoed to the output with the correct speed, parity,
etc.
\label{fc}
\label{fs}
\label{xc}
\label{xs}
\label{secconvert}


\subsubsection{Converting BSD fc,fs,xc,xs To LPRng sy}

Justin Mason
{\ttfamily $<$jmason@iona.ie{$>$}}
and Updated by Patrick Powell
{\ttfamily $<$papowell@sdsu.edu{$>$}}

One of the worst things about old LPDs is that they expected you
to give it line characteristictics as octal numbers, using the
fc,fs,xc,xs printcap parameters. There are a number of disadvantages
to this, compared to using the "ty" parameter.

The sy format is portable, as it is supported on all UNIXes, rather
than simply BSD-derived ones; it's also \_much\_ easier to understand
than the fc,fs,xc,xs format -- compare the two:
\begin{verbatim}
# new format
    :sy=pass8 -parity tabs litout nl:
# old format
    :fc#0000374:fs#0000003:xc#0:xs#0040040:
\end{verbatim}


Note, also, that "sy" uses the same symbolic names as the "stty"
command, which is (relatively) well documented.

Anyway, assuming you have a set of printcaps which use the fc,fs,xc,xs
method, you can convert them to "sy" strings using the following
table.

Each parameter is an octal number, composed by logical-or'ing the
bits for the desired parameters together.  The bit patterns below
have been worked out from SunOS 4.1.2 /usr/include/sys/ttold.h.
For example, the following fc,fs,xc,xs set:

\begin{verbatim}
:fc#0000374:fs#0000003:xc#0:xs#0040040:
\end{verbatim}

converts to the following sy string:
\begin{verbatim}
:sy=-parity -echo -crmod -raw -lcase tandem cbreak litout decctq:
\end{verbatim}


Quite often, the resulting strings seem a little complicated, but
usually they can be broken down using combination modes. See the
printcap(5) manual page for details of which combination modes
PLP supports.

In order to help you,  the 'xlate' program can be used to translate from the old
to the new form.
For example:
\begin{verbatim}
#> xlate ":fc#0000374:fs#0000003:xc#0:xs#0040040:"
fc = 374
  clear LCASE (simulate lower case) try '-lcase'
  clear ECHO (echo input) try '-echo'
  clear CRMOD (map \r to \r\n on output) try '-crmod'
  clear RAW (no i/o processing) try '-raw'
  clear ODDP (get/send odd parity) try '-oddp'
  clear EVENP (get/send even parity) try '-evenp'
  clear ANYP (get any parity/send none) try '-parity? anyp? pass8? (caution)'
fs = 3
  set TANDEM (send stopc on out q full) try 'tandem'
  set CBREAK (half-cooked mode) try 'cbreak'
xc = 0
xs = 40040
  set LITOUT (literal output) try 'litout'
  set DECCTQ (only ^Q starts after ^S) try 'decctlq'
\end{verbatim}


Note that when you clear odd and even parity,  then you get
no parity or any parity.  You should use -parity to be compatible.
You might also want to add 'pass8' as well.
Thus, using the xlate output, you would try:
\begin{verbatim}
   :sy=-lcase -echo -crmod -raw -parity pass8 tandem cbreak litout decctlq:
\end{verbatim}


Bits used in the fc, fs parameters:
\begin{verbatim}
TANDEM    00000001    /* send stopc on out q full */
CBREAK    00000002    /* half-cooked mode */
LCASE     00000004    /* simulate lower case */
ECHO      00000010    /* echo input */
CRMOD     00000020    /* map \r to \r\n on output */
RAW       00000040    /* no i/o processing */
ODDP      00000100    /* get/send odd parity */
EVENP     00000200    /* get/send even parity */
ANYP      00000300    /* get any parity/send none */
NLDELAY   00001400    /* \n delay */
NL0       00000000
NL1       00000400    /* tty 37 */
NL2       00001000    /* vt05 */
NL3       00001400
TBDELAY   00006000    /* horizontal tab delay */
  TAB0    00000000
  TAB1    00002000    /* tty 37 */
  TAB2    00004000
XTABS     00006000    /* expand tabs on output */
CRDELAY   00030000    /* \r delay */
    CR0   00000000
    CR1   00010000    /* tn 300 */
    CR2   00020000    /* tty 37 */
    CR3   00030000    /* concept 100 */
VTDELAY   00040000    /* vertical tab delay */
    FF0   00000000
    FF1   00040000    /* tty 37 */
BSDELAY   00100000    /* \b delay */
    BS0   00000000
    BS1   00100000
ALLDELAY  00177400
\end{verbatim}


Bits used in the xc, xs parameters:
\begin{verbatim}
CRTBS     00000001    /* do backspacing for crt */
PRTERA    00000002    /* \ ... / erase */
CRTERA    00000004    /* " \b " to wipe out char */
TILDE     00000010    /* hazeltine tilde kludge */
MDMBUF    00000020    /* start/stop output on carrier intr */
LITOUT    00000040    /* literal output */
TOSTOP    00000100    /* SIGSTOP on background output */
FLUSHO    00000200    /* flush output to terminal */
NOHANG    00000400    /* no SIGHUP on carrier drop */
CRTKIL    00002000    /* kill line with " \b " */
PASS8     00004000    /* pass 8 bits */
CTLECH    00010000    /* echo control chars as ^X */
PENDIN    00020000    /* tp->t_rawq needs reread */
DECCTQ    00040000    /* only ^Q starts after ^S */
NOFLSH    00100000    /* no output flush on signal */
\end{verbatim}


The following program translates the various bits to {\ttfamily stty}
flags.
\begin{verbatim}
#include <stdio.h>
#include <string.h>
struct bits{
  char *name;
  int bitfields;
  char *comment;
  char *try;
  int mask;
};
/* f flags - used with the TIOCGET and the struct sgttyb.sg_flags field */
struct bits tiocget[] = {
{ "TANDEM",00000001, "send stopc on out q full", "tandem" },
{ "CBREAK",00000002, "half-cooked mode", "cbreak" },
{ "LCASE",00000004, "simulate lower case", "lcase" },
{ "ECHO",00000010, "echo input", "echo" },
{ "CRMOD",00000020, "map \\r to \\r\\n on output", "crmod" },
{ "RAW",00000040, "no i/o processing", "raw" },
{ "ODDP",00000100, "get/send odd parity", "oddp" },
{ "EVENP",00000200, "get/send even parity", "evenp" },
{ "ANYP",00000300, "get any parity/send none", "parity? anyp? pass8? (caution)" },
{ "NL0",0000000, "new line delay", "nl??",00001400 },
{ "NL1",00000400, "new line delay tty 37", "nl??",00001400  },
{ "NL2",00001000, "new line delay vt05", "nl??",00001400  },
{ "NL3",00001400, "new line delay", "nl??",00001400  },
{ "TAB0",00000000, "tab expansion delay", "tab??",00006000 },
{ "TAB1",00002000, "tab expansion delay tty 37", "tab??",00006000  },
{ "TAB2",00004000, "tab expansion delay", "tab??",00006000  },
{ "XTABS",00006000, "expand tabs on output", "tabs" },
{ "CR0",00000000, "cr??", "",00030000 },
{ "CR1",00010000, "tn 300", "cr??",00030000 },
{ "CR2",00020000, "tty 37", "cr??",00030000 },
{ "CR3",00030000, "concept 100", "cr??",00030000},
{ "FF1",00040000, "form feed delay tty 37", "ff??" },
{ "BS1",0010000, "backspace timing", "bs??" },
{ 0 } };
/* x flags - used with the TIOCLGET and the struct sgttyb.sg_flags field */
struct bits tiolget[] = {
{ "CRTBS",00000001, "do backspacing for crt", "crterase" },
{ "PRTERA",00000002, "\\ ... / erase", "prterase" },
{ "CRTERA",00000004, "\"\\b\" to wipe out char", "crterase" },
{ "TILDE",00000010, "hazeltine tilde kludge", "don't even think about this" },
{ "MDMBUF",00000020, "start/stop output on carrier intr", "crtscts" },
{ "LITOUT",00000040, "literal output", "litout" },
{ "TOSTOP",00000100, "SIGSTOP on background output", "tostop" },
{ "FLUSHO",00000200, "flush output to terminal", "noflsh?? (caution)" },
{ "NOHANG",00000400, "no SIGHUP on carrier drop", "nohand" },
{ "CRTKIL",00002000, "kill line with \"\\b\"", "crtkill" },
{ "PASS8",00004000, "pass 8 bits", "pass8" },
{ "CTLECH",00010000, "echo control chars as ^X", "echok" },
{ "PENDIN",00020000, "tp->t_rawq needs reread", "don't even think about this" },
{ "DECCTQ",00040000, "only ^Q starts after ^S", "decctlq? -ixany? (caution)" },
{ "NOFLSH",00100000, "no output flush on signal", "noflsh" },
{ 0 } };
char *msg[] = {
 "xlate optionstrings",
 "  Example",
 "  xlate \":fc#0000374:fs#0000003:xc#0:xs#0040040:\"",
    0
};
usage()
{
    char **m;
    for( m = msg; *m; ++m ){ fprintf( stderr, "%s\n", *m ); }
    exit( 1 );
}
main( argc, argv )
    int argc;
    char *argv[];
{
    char *s, *end, *value;
    int c, v, set;
    struct bits *table;
    if( argc != 2 ) usage();
    for( s = argv[1]; s && *s; s = end ){
        end = strchr( s, ':' );
        if( end ){
            *end++ = 0;
        }
        while( (c = *s) && isspace( c ) ) ++s;
        if( c == 0 ) continue;
        /* now translate option */
        value = strchr( s, '#' );
        if( value == 0 ) usage();
        *value++ = 0;
        v = strtol( value, (char **)0, 0 );
        printf( "%s = %o\n", s, v);
        switch( s[0] ){
            case 'f': table = tiocget; break;
            case 'x': table = tiolget; break;
            default: usage();
        }
        switch( s[1] ){
            case 's': set = 1; break;
            case 'c': set = 0; break;
            default: usage();
        }
        /* now we scan down the values */
        for(; table->name; ++table ){
            if( (table->bitfields & v)
                && ( ((table->bitfields & v) ^ table->bitfields)
            & (table->mask?table->mask:~0) ) == 0 ){
                printf( "  %s %s (%s) try '%s%s'\n",
                    set?"set":"clear",
                    table->name, table->comment,
                    set? "":"-", table->try );
            }
        }
    }
}
\end{verbatim}



\subsection{Network Printers}

If you have a network printer,
then you may have several options.
First,
your printer may have built-in LPD server support.
However,
this may not function as expected.
It has been observed that most of these builtin servers do not handle
large jobs or jobs with complex PJL, PCL, or PostScript with binary
information well.

On the other hand,
your printer may have a TCP/IP port that connects directly to the
print engine.
For example,
on the HP JetDirect cards, sending a print file to port 9100  will cause
the print engine to process and print it.
In addition,
this channel may provide status and other information during the printing
process.
You can use the
\url{netcat}
utility by Hobbit can be used to simply send files directly to the printer.
The simplest and easiest way to print a file to a network printer appears
to be: {\ttfamily  nc printer.ip.addr 9100 $<$ file }.
\label{installingprograms}


\section{Installing the programs}

The basic components of the LPRng system are the executables
and the database files.
This section deals with generating and installing the executable
files.


\subsection{Files and Setup}

The LPRng system can run in several different manners.
However,
for most users it will require the executables
for the server {\ttfamily lpd}, and the client applications for
job submission - {\ttfamily lpr},
job status - {\ttfamily lpq},
job removal - {\ttfamily lprm},
and server management - {\ttfamily lprc},
and the {\ttfamily /etc/lpd.conf}
and {\ttfamily /etc/printcap} files.

By default,
all the LPRng executables are installed in
{\ttfamily /usr/local/bin},
which differs from other UNIX lpr systems,
which scatter them in various hidden and arcane locations.

The
{\ttfamily \ref{lpdconf} {(/etc/lpd.conf)}}
file contains the configuration
information for the server and application programs.
The LPRng system has a compiled in set of defaults that should be
suitable for most user applications.
In fact,  the default
{\ttfamily /etc/lpd.conf} does not override any of the precompiled values.

The
{\ttfamily \ref{printcapref} {(/etc/printcap)}}
file contains the printer database information.
This information can override the defaults in
{\ttfamily /etc/lpd.conf}

By default,
the LPRng executables are installed in
{\ttfamily /usr/local/bin}.
Note that the BSD LPD executables are located in various places and will
need to be removed and renamed.


\subsection{Source Code and Installation}

If you have a binary distribution, you can skip this section. However,
since LPRng is a rapidly evolving package, I would advise you to check
whether there is a newer stable version available on one of the
\ref{secftp} {(FTP sites.)}
There should be a link to this stable version called
{\ttfamily LPRng-stable.tar.gz}.

You should also look at the
\ref{sysdep} {(System specific notes)}
to see if there are any special things that you need to do for your system.


\subsubsection{Building the software}

Before you start to build the software,
you should read the
{\ttfamily README.1st} and {\ttfamily README.installation}
files in the distribution.
If you have GNU Make, do:
\begin{verbatim}
./configure;
  #if you want internationalization,
  # ./configure --enable-nls
make clean all;
su   # you must do the following commands as root
make install
# if  you have not installed LPRng before,
# install default lpd.perms and lpd.conf file in /etc
if [ ! -f /etc/lpd.perms ]; then
    make default;
fi;
# update permissions,  create files needed for LPRng, check
# /etc/printcap file for problems.  Do as root:
./src/checkpc -f
\end{verbatim}


If you have BSD make do:
\begin{verbatim}
./configure;
  #if you want internationalization,
  # ./configure --enable-nls
make -f Makefile.bsd clean all;
su   # you must do the following commands as root
make -f Makefile.bsd install
# if  you have not installed LPRng before,
# install default lpd.perms and lpd.conf file in /etc
if [ ! -f /etc/lpd.perms ]; then
    make -f Makefile.bsd default;
fi;
# update permissions,  create files needed for LPRng, check
# /etc/printcap file for problems.  Do as root:
./src/checkpc -f
\end{verbatim}


Use the configure
{\ttfamily --bindir} option to specify
the location of the binaries,
or edit {\ttfamily src/Makefile} or
{\ttfamily src/Makefile.bsd}
after running configure.
The lines you have to change are:
\begin{verbatim}
INSTALL_BIN =     ${exec_prefix}/bin
# where daemons are installed: lpd
#INSTALL_LIB =     ${prefix}/lib
INSTALL_LIB =     ${prefix}/sbin
# where maintenance commands are installed: checkpc, setstatus
INSTALL_MAINT =   ${exec_prefix}/sbin
\end{verbatim}


By default, all LPRng executables are placed in
{\ttfamily /usr/local/bin.}


\subsubsection{Problems with compilation}

If you have problems compiling the package, you can try these things:
\begin{enumerate}
\item Try {\ttfamily gcc} instead of your vendor's C compiler.
This is the standard compiler used for LPRng.
Almost without exception,
if you have a ANSI C compatible compiler and libraries
a POSIX compatible standard set of system support routines,
LPRng will compile and run out of the box.
The main problems are with missing or modified system support routines,
but configure will usually detect this and set flags to use
suitable alternatives.
\item The {\ttfamily configure} and the {\ttfamily make} should be run on
the target host,
especially if the target host has a different version of the operating system.
This is extremely important for SunOS or Solaris,
where
there tend to be changes in the system's include files between
versions
as well as support libraries.
\item {\ttfamily configure}
and the LPRng software tends to make the assumption that newer versions will not
have the same problems that older versions have had.
\end{enumerate}


If you are not familiar with GNU configure, read the file
{\ttfamily INSTALL} for instructions.

Also read the notes for your OS in section
\ref{sysdep} {(System-dependent notes)}
for specific installation help (if any).
\label{installation}


\subsection{Preparing to run the daemon}

Don't be too impatient. Take your time to completely read through this
HOWTO. Things will be a lot easier when you first set up the
configuration files, and then start the new lpd.

During the course of this steps, you will have to change some files.
Whatever you do: keep a copy of the original files!


\subsubsection{Removing Existing Facilities}

Here is a summary and some scripts
to help you prepare your site for
running the server.
\begin{enumerate}
\item Kill off the old server.
\begin{verbatim}
BSD:
  ps -aux |grep lpd
  kill (pid of lpd server)
System V or Linux:
  ps -ea |grep lpd
  kill (pid of lpd server)
\end{verbatim}
\item You should remove or rename the existing print system executables.
Use the following script and
examine the {\ttfamily /tmp/candidates} file for possible programs.
Remove or rename the non-LPRng versions of the programs.
\begin{verbatim}
# you might want to track down the old lpr, lpq, lprm binaries
find /usr -type file -name lp\* \; -print >/tmp/candidates
find /sbin -type file -name lp\* \; -print >>/tmp/candidates

# example rename
mv /usr/libexec/lpd /usr/libexec/lpd.orig
# example link
ln -s /usr/local/bin/lpd /usr/libexec/lpd
\end{verbatim}
\item Try starting and running {\ttfamily lpd} before permanently installing it.
You should do the next steps as {\bfseries root}.
\begin{verbatim}
/usr/local/bin/lpd;    # start up LPD
lpq;    # test it with LPQ
\end{verbatim}
\end{enumerate}

\label{startup}


\subsubsection{Startup Scripts}

Don't forget to modify your system print startup files,
i.e. - the {\ttfamily /etc/rc} file in most BSD based UNIX systems,
or those in {\ttfamily /etc/init.d} on System V and Linux.
You will need to have them reference the LPRng {\ttfamily lpd}
and not the original system executable.

Here is the core of a typical UNIX SystemV or LINUX startup file
that can be used to start up and shut down the server.
Note that you will most likely need to modify the
{\ttfamily echo} lines.
\begin{verbatim}
#!/bin/sh
case "$1" in
  start) # Start daemons.
    echo "Starting lpd: \c"; /usr/local/bin/lpd; bin/echo;
    ;;
  stop) # Stop daemons.
    echo "Shutting down lpd: \c"
    server=`/usr/local/bin/lpc -Pany@localhost lpd \
    | awk '{for(i=1;i<=NF;++i){v=$i+0;if(v>1){ print v;exit;}}}'`
    if [ -n "$server" ]; then
      echo " server pid $server";
      kill $server;
    else
       echo " no server active";
    fi;
    ;;
    *)
       echo "Usage: lpd {start|stop}"
       exit 1
     ;;
esac
\end{verbatim}

\label{lpsimulation}


\subsection{Replacing UNIX SystemV lp, lpstat Printing Services}

Many UNIX utilities in the Solaris and HP UNIX environment use the
UNIX System V {\ttfamily lp} and {\ttfamily lpstat}
programs.
It is almost impossible to modify their operation to use the
LPRng {\ttfamily lpr} or {\ttfamily lpq} programs,
as they depend on various return codes and information.

Here is Patrick Powell's comments on this:
\begin{quotation}
After fighting with LP simulation,  I finally decided to make the
interface part of the LPR/LPQ package.  If LPR is invoked as LP,
then it will 'act' like a 'semi-compatible' LP; similarly for LPQ and LPSTAT,
and LPRM and CANCEL.
\end{quotation}


To get this functionality, you need to either make a symbolic link
or a hard link to the appropriate executable.
\begin{verbatim}
cd /usr/local/bin
ln -s lpr lp
ln -s lpq lpstat
ln -s lprm cancel
cd /usr/sbin
ln -s /usr/local/bin/lpr lp
ln -s /usr/local/bin/lpq lpstat
ln -s /usr/local/bin/lprm cancel
\end{verbatim}


See the man pages for lp, lpstat, and cancel in the LPRng/man directory.
Note that not all the functions of the original
lp programs are supported.
These man pages should be installed to replace the normal
lp, etc, man pages.

For some purposes,  the rather rugged {\ttfamily lpstat}
simulation provided by this method does not work.
\url{Garrett D'Amore {$<$}tt{$>$}$<$garrett@qualcomm.com$>${$<$}/tt{$>$}}
has written some much improved versions;
take a look at
\url{http://people.qualcomm.com/garrett/}
for details.
\label{user}
\label{group}


\subsection{Setuid ROOT and Security Issues}

By default,
LPRng executables are installed setuid ROOT.
When running,
they normally perform all operations with the user's effective UID,
and perform all other operations set to the user and group specified by the
{\ttfamily user=daemon}
and
{\ttfamily group=daemon}
printcap entries,
except for a very few places where they take extreme precautions against
actions that could cause security breaches,
change the EUID to ROOT,
and then immediately change back to the normal operation.

As a scan of the various CERT Security Advisories will indicate,
many programs that run SUID root can be serious security loopholes.
While LPRng has been designed and implemented with security and
paranoia in mind,
there is still the possibility that user level or LPD processes
can have an exposed security loophole.

To reduce the risk,
the user level utilities such as lpr, lprm, lpq, and lpc can be installed
non-setuid.
This effectively closes several possible security loopholes.
To install the executables as non-setuid,
the distribution {\ttfamily src/Makefile}
must have the following lines commented out,
and then LPRng reinstalled:
\begin{verbatim}
edit src/Makefile
   # comment out the next line to have LPRng installed non-setuid
   PERMS=$(SUID_ROOT_PERMS)
make install
\end{verbatim}

\label{sysdep}


\subsection{System specific notes}

The following are a set of suggestions and recommendations for
specific systems.
\label{solarisinstall}


\subsubsection{Solaris 2.4, 2.5, 2.6}

The Sun Solaris operating system is derived from the System V UNIX
baseline.
Use the following installation procedure.
\begin{enumerate}
\item First,
install the LPRng software
and then rename all of the existing Solaris print facilities.
See the
\ref{installation} {(Installation)} section for details.
You should especially look out for
{\ttfamily lp},
{\ttfamily lpstat},
{\ttfamily lpsched},
{\ttfamily lpadmin},
and other executables used by Solaris for print support.
\item Next,
make sure you update the {\ttfamily /etc/rc} startup files.
During the startup or initialization,
Solaris will invoke a set of individual startup files.
You will find that the startupfile files are usually links to a
common one in the {\ttfamily /etc/init.d} directory.
\begin{verbatim}
># grep -l lpsched /etc/rc* /etc/rc*/* init.d/* init.d/*/*
/etc/rc0.d/K20lp
/etc/rc2.d/K20lp
/etc/rc2.d/S80lp
/etc/init.d/lp
># ls -l /etc/rc0.d/K20lp
lrwxrwxr-x  1 root  bin  1 Dec 29 23:39 /etc/rc0.d/K20lp -> ../../init.d/lp
\end{verbatim}
\item Replace the existing lp startup file with one similar to the
\ref{startup} {(startup script)} in the previous section.
\item Check the {\ttfamily /etc/inetd.conf} file for a line like:
\begin{verbatim}
printer stream tcp nowait root /usr/lib/print/in.lpd in.lpd
\end{verbatim}

and remove it if it is present.
You will need signal the {\ttfamily inetd} process to reread the
configuration file.
This is usually done using a {\ttfamily kill -HUP pid} command,
where {\ttfamily pid} is the {\ttfamily inetd} process id.

\item If you don't want to reboot, you may need to use the nlsadmin(1M)
command to remove the network listeners on your printer port.  Even
after doing an lpshut, there is still a little devil hanging on.
For instance, on our systems it looked like so:
\begin{verbatim}
# nlsadmin -v tcp
lpd  \x00020203000000000000000000000000  ENABLED  \
  NORPC  root  NOMODULES  /var/spool/lp/fifos/listenBSD  #  
0  \x00020ACE000000000000000000000000  ENABLED    \
  NORPC  root  NOMODULES  /usr/lib/saf/nlps_server  #  
lp  NOADDR  ENABLED  NORPC  root  NOMODULES \
  /var/spool/lp/fifos/listenS5  #  
\end{verbatim}

To remove them do:
\begin{verbatim}
# nlsadmin -r lpd tcp
# nlsadmin -r lp tcp
\end{verbatim}
\item You can then start lpd by typing
\begin{verbatim}
# /etc/init.d/lp start
\end{verbatim}
\end{enumerate}



\subsubsection{Solaris, Newsprint and FrameMaker}

The following is a guide to using LPRng and
Sun Microsystems Newsprint by
Christopher Hylands, Ptolemy Project Manager
of the University of California.

The Sun Newsprint printer is actualy
an OEM version of the  Textronix PhaserII;
Sun Microsystems appears to have dropped support for Newsprint,
and the recommended migration path is to buy a PostScript printer.
If you want more information on using the Newsprint system,
notes are available via
{\ttfamily http://ptolemy.eecs.berkeley.edu/\~{}cxh/lprng.html}.

Looking through the mailing list logs, it looks like everyone was
having a hard time getting lprng to work with Sun's braindead
newsprinters.  I tried using ghostscript, but the fonts were, IMHO,
ugly, so I spent a little time getting the newsprint fonts to work.

The key thing was to grab the file
{\ttfamily /usr/newsprint/lpd/if}
from a SunOS4.1.3 newsprint installation.
If you cannot get this code,
then the installation will be extremely difficult.

To install lprng on a Solaris2.x machine,
you need to first stop the existing print services and install the
startup scripts for LPRng.
Note that if there is a local printer, you may have
to also fix the permissions of the device. Typical commands are:
\begin{verbatim}
chown daemon /devices/sbus@1,f8000000/SUNW,lpvi@1,300000:lpvi0
\end{verbatim}


We use the following simple {\ttfamily if} script.
\begin{verbatim}
#/bin/sh
# extremely simple filter script
/bin/cat
\end{verbatim}


The Sparcprinters use licensed fonts from NeWSprint. To use the
licensed fonts, you must have the lprng spool directory for the
sparcprinter in the same location as spool directory of the brain
dead Solaris lp system.  If your printer is named xsp524, then this
directory would be {\ttfamily  /etc/lp/printers/xsp524}.

The printcap entry looks like:
\begin{verbatim}
sp524|524:
    :mx#0:sf:sh:sb:
    :lp=:rm=doppler:rp=xsp524:mx#0:
    :sd=/var/spool/lpd/sp524d:
    :lf=/var/spool/lpd/sp524d/log:
xsp524|Sun SPARCprinter NeWSprint printer:
    :mx#0:sf:sb:sh:rs:
    :lp=/dev/lpvi0:
    :sd=/etc/lp/printers/xsp524:
    :lf=/etc/lp/printers/xsp524/log:
    :af=/var/spool/lpd/xsp524/acct:
    :if=/usr/local/lib/newsprint/if:
\end{verbatim}


The
{\ttfamily /usr/local/lib/newsprint/if}
was copied from
{\ttfamily /usr/newsprint/lpd/if}
in a SunOS4.x installation of the newsprint
software.
Unfortunately, the newsprint engine is so brain dead that it
needs many environment variables set, so it is fairly difficult to
come up with a clean script to start the engine. I made the following
changes to the file.
\begin{enumerate}
\item First, set the path in the script.
You may also need to change defaults to suit your preferences:
\begin{verbatim}
PATH=/usr/ucb:/usr/bin:/etc:/usr/etc:/opt/NeWSprint/bin:/opt/NeWSprint/np/bin:
PATH=$PATH:$NPHOME/pl.$ARCH/bin:$NPHOME/np/bin; export PATH
\end{verbatim}
\item You will also need a
{\ttfamily /etc/lp/printers/printername/.params}
file. If you
are using the same spooler directory as the directory that the Solaris
lp system uses, then the .param file should appear there. If you are
using a different spooler directory, then you will need to copy
the .param file from elsewhere and edit it accordingly.
\item If you are going to move a license to a new printer, you should
probably save the .param file in the old printer spooler directory.
Run /opt/NeWSprint/bin/fp\_install and remove the license from the
old printer and assign it to the new printer.
You could run /opt/NeWSprint/bin/rm\_np\_printer and remove the printer,
but that will get rid of the .param file
\item FrameMaker under Solaris2.x uses the lp command. The fix is to edit
\$FMHOME/fminit/FMlpr and comment out the lp line and add an lpr line
\begin{verbatim}
sunxm.s5.sparc)
    lpr -P"$PRINTER" "$FILE"
    #lp -c -d"$PRINTER" "$FILE"
\end{verbatim}
\end{enumerate}

\begin{verbatim}
Christopher Hylands, Ptolemy Project Manager  University of California
cxh@eecs.berkeley.edu                 US Mail: 558 Cory Hall #1770
ph: (510)643-9841 fax:(510)642-2739       Berkeley, CA 94720-1770
home: (510)526-4010 (if busy -4068)       (Office: 493 Cory)
\end{verbatim}



\subsubsection{Linux}

At the time of writing (Jan 1998),
the three major Linux
distributions (Slackware, Red Hat and Debian) carry an older version
of LPRng. Users of those systems should download the
latest stable release, and install that instead of the distributed
binaries.

This is mostly important for Slackware 3.2 users, as this version
installs LPRng by default.
Patrick Volkerding changed the default back to
BSD LPR in Slackware 3.3,
as many users had experienced problems
because they didn't realize they weren't using the BSD software.

Debian's {\ttfamily dselect} utility lets you choose between all
packages. Amongst these are LPRng, as well as the traditional LPR
software.

You have to make sure your kernel is configured correctly. The
documentation for the kernel sources in
{\ttfamily /usr/src/linux/Documentation/} and the {\ttfamily Kernel-HOWTO}
will help you to generate a new kernel if needed. You will need to set
the following options:
\begin{itemize}
\item Networking support ({\ttfamily CONFIG\_NET})
\item TCP/IP support ({\ttfamily CONFIG\_INET})
\item If your printer is connected to a parallel port, you will also
need the `Parallel Printer Support' ({\ttfamily CONFIG\_PRINTER}).
You can use this as a module if you want.
\item For a serial printer, answer `Yes' when asked if you want
`Support for serial devices' ({\ttfamily CONFIG\_SERIAL}). This is
also available as a module.
\end{itemize}


Once you have done this,
the current releases of LPRng will install and run without
problems.
See the
\ref{installingprograms} {(Installing the programs)}
section for details on how to install LPRng and
deactivate the existing print support.

You may need to update the printcap file and filters.
See \ref{printcapref} {(/etc/printcap Print Spool Database File)}
for details.


\subsubsection{AIX}

This information was supplied by
\url{Dirk Nitschke,}
as of August 1997,
and describes how to install the LPRng package on a workstation
running AIX 4.1.x and possibly 3.x.x as well.
Dirk would be interested in any comments or corrections.

Printing on AIX systems is different. AIX provides a general
queueing facility and printing is only one way to use it. You submit a
print job to a print queue using one of the commands
{\ttfamily qprt}, {\ttfamily enq}. You can use the BSD or
System V printing commands {\ttfamily lpr} or {\ttfamily lp}, too. The
qdaemon watches all (general) queues and knows how to handle your
job. A (general) queue is defined in the file
{\ttfamily /etc/qconfig}. The format of this file is different from
the {\ttfamily printcap} format.

OK, how to replace the AIX printing system? There is no group
{\ttfamily daemon} on AIX. Therefore you have to change the default
group for file ownership and process permissions. We decided to use
the {\ttfamily printq} group. The user {\ttfamily daemon} exists on
AIX but we have chosen {\ttfamily lpd} as the user who runs
{\ttfamily lpd} and all filters and owns the spooling directories.
You can change the values for {\ttfamily group},
{\ttfamily server\_user} and {\ttfamily user} in your
{\ttfamily lpd.conf} file or in the sources
{\ttfamily src/common/default.c}. This is an example for
{\ttfamily lpd.conf}:
\begin{verbatim}
# lpd.conf for AIX (change group, server_user and user)
group=printq
server_user=lpd
user=lpd
\end{verbatim}

Compile and install the LPRng package. Create your
{\ttfamily printcap}, spooling directories, accounting and logfiles
and so on.
Don't forget to use
\ref{checkpc} {(checkpc)} to make sure that all the
permissions are set correctly and the necessary files
are created.

Then stop all print queues defined on your workstation. Use
\begin{verbatim}
# chque -q queuename -a "up = FALSE"
\end{verbatim}

for this (yes, blanks around {\ttfamily =} are needed).

If you have local printers attached to your system you will have an
{\ttfamily lpd} running. Stop this daemon using SMIT (Print Spooling,
Manage Print Server, Stop the Print Server Subsystem). Choosing
{\ttfamily both} also removes {\ttfamily lpd} from
{\ttfamily /etc/inittab}. Maybe it's faster to do this by hand:
\begin{verbatim}
# stopsrc -p'pid of /usr/sbin/lpd'
# rmitab "lpd"
\end{verbatim}


Now delete all print queues (managed by qdaemon) defined on your
system. You can use SMIT for this or the commands
{\ttfamily $\{$mk,ch,rm$\}$que}, {\ttfamily $\{$mk,ch,rm$\}$quedev},
{\ttfamily $\{$mk,ch,rm$\}$virprt}. The SMIT fast path is {\ttfamily smit
rmpq}.

To start the new {\ttfamily lpd} at system startup you have to add
an entry to {\ttfamily /etc/inittab}:
\begin{verbatim}
# mkitab "lpd:2:once:/full/path/lpd"
\end{verbatim}


Some work has to be done if have have a local printer attached to
your workstation. You have to create a device file like
{\ttfamily /dev/lp0}. The SMIT fast path for this is {\ttfamily smit
mkdev}. Choose {\ttfamily Printer/Plotter} and then
{\ttfamily Printer/Plotter Devices}. Now {\ttfamily Add a
Printer/Plotter}. To create a parallel
printer device select the following:
\begin{verbatim}
Plotter type:              opp Other parallel printer
Printer/Plotter Interface: parallel
Parent Adapter:            ppa0 Available
\end{verbatim}

Now define the characteristictics of the device:
\begin{verbatim}
Port Number: p
\end{verbatim}

({\ttfamily p} is for parallel).
Go to the field
\begin{verbatim}
Send all characters to printer UNMODIFIED   no
\end{verbatim}

and select {\ttfamily yes}! We have had a lot of trouble with
{\ttfamily no}.  This is very important! Expect erroneous output if
you choose {\ttfamily no}. If you have already created a device
file, change the characteristictics! SMIT's fast path is {\ttfamily smit
chdev}.

Finally remove all AIX printing commands like {\ttfamily qprt},
{\ttfamily lp}, {\ttfamily cancel}, {\ttfamily lpr},
{\ttfamily lprm}. You will find a lot of them in
{\ttfamily /usr/bin}. Do not remove {\ttfamily enq} and friends if
you want to use the general queueing facility.

Now you can start your new {\ttfamily lpd}.


\subsection{Appletalk Support}

Netatalk is used to communicate from TCP/IP to
Appletalk printers and vice versa.
The netalk distribution FAQ is at:
\url{http://www.umich.edu/\~{}rsug/netatalk}

There are two issues with using netatalk.  The first issue
has to do with printing to LPRng-served printers from Macs.
The second issue has to do with printing from LPRng to
network printers that speak AppleTalk.




\subsubsection{Apple to LPRng Printing}

After you have installed and gotten netatalk working,
you can use the following configuration file to print
from a Macintosh to an LPRng printer.
\begin{verbatim}
From edan@mtu.edu Mon Sep 29 21:31:25 1997
Date: Tue, 30 Sep 1997 00:04:58 -0400 (EDT)
From: Edan Idzerda <edan@mtu.edu>
To: lprng@iona.com
Subject: Re: [LPRng] Netatalk configuration file
> Somebody posted a very nice Netatalk papd.conf file
> that showed the setup for LPRng.  If anybody has this
> handy could you post it?
Well, *I* use:
Your 32 Character Printer Name:\
        :pr=|/your/path/to/lpr -Pprintername
        :ppd=/your/path/to/ppd/files/yourprinter.ppd
--
Edan Idzerda    <edan@mtu.edu>
System Administrator -- Michigan Technological University, Houghton MI USA
\end{verbatim}



\subsubsection{LPRng to Appletalk Printing}

The netatalk package comes with a PostScript filter called psf.  After
compilation, it is in (e.g.) netatalk-1.4b2/etc/psf and will be installed
in (e.g.) /usr/local/atalk/etc/.  After installation, there will also
be a directory /usr/local/atalk/etc/filters that contains ifpap, ofpap,
et al.  These are just symlinks to psf, and psf will do the appropriate
thing based on how it was invoked.  If there's a 'pap' in the name,
psf uses AppleTalk to talk to the printer.  See psf(8) for more information.

A printcap entry for a network printer looks like the following:
\begin{verbatim}
dave|Dave's 32 Character Printer Name:\
    :sd=/var/spool/dave:\
    :lf=/var/adm/lpd-errs:\
    :lo=lock:\
    :if=/usr/local/atalk/etc/filters/ifpap:\
    :of=/usr/local/atalk/etc/filters/ofpap:\
    :lp=/var/spool/dave/null
\end{verbatim}


There are three caveats to using netatalk this way.
\begin{enumerate}
\item The first is that
psf (i.e., the filters) need to run as root.  You can accomplish this
in one of two ways.  The first is to uncomment the following line in
src/Makefile and recompile:
\begin{verbatim}
# ROOT_CFLAG=-DROOT_PERMS_TO_FILTER_SECURITY_LOOPHOLE
\end{verbatim}

The filter lines then need to look like the following:
\begin{verbatim}
    :if=ROOT /usr/local/atalk/etc/filters/ifpap:\
    :of=ROOT /usr/local/atalk/etc/filters/ofpap:\
\end{verbatim}


The alternative is to make psf setuid root.  To minimize the risk,
you may want to make psf executable only by group daemon.  (I haven't
tested the first option.  I'm currently using the second option.)



\item The second caveat is that each network printer needs a .paprc in its
spool directory.  For instance, /var/spool/dave/.paprc looks like this:
\begin{verbatim}
Dave's 32 Character Printer Name:LaserWriter@Your AppleTalk Zone
\end{verbatim}

See psf(8) and pap(1) for more information.



\item The third caveat concerns the lp line in the printcap entry.  For a
single printer, this can be /dev/null.  If the host spools to more
than one AppleTalk printer, you shouldn't use /dev/null for lp.  You
should use mknod to create a null device for each printer.  See psf(8).
\end{enumerate}

\begin{verbatim}
Chad Mynhier <mynhier@cs.utk.edu>
Lab Engineer, CS Department        
University of Tennessee, Knoxville                   
\end{verbatim}



\subsection{SAMBA Support}

From the
\url{http://samba.canberra.edu.au/pub/samba/}
Web Site.




\subsubsection{What is SMB}

This is a big question.

The very short answer is that it is the protocol by which a lot of
PC-related machines share files and printers and other information
such as lists of available files and printers. Operating systems that
support this natively include Windows NT, OS/2, and Linux and add on
packages that achieve the same thing are available for DOS, Windows,
VMS, Unix of all kinds, MVS, and more. There is no reason why Apple
Macs and indeed any Web browser should not be able to speak this
protocol, and current development (in which the Samba team is heavily
involved) is aimed at exactly that. Alternatives to SMB include
Netware, NFS, Appletalk, Banyan Vines, Decnet etc; many of these have
advantages but none are both public specifications and widely
implemented in desktop machines by default.

The Common Internet Filesystem is what the new SMB initiative is
called. For details watch
\url{http://samba.anu.edu.au/cifs}.

{\bfseries WHAT CAN SAMBA DO?}

Here is a very short list of what samba includes, and what it does.
\begin{itemize}
\item  a SMB server, to provide Windows NT and LAN Manager-style file and print
services to SMB clients such as Windows 95, Warp Server, smbfs and others.
\item  a Netbios (rfc1001/1002) nameserver, which among other things gives
browsing support. Samba can be the master browser on your LAN if you wish.
\item  a ftp-like SMB client so you can access PC resources (disks and
printers) from unix, Netware and other operating systems
\item  a tar extension to the client for backing up PCs
\end{itemize}


For a much better overview have a look at the web site at
\url{http://samba.canberra.edu.au/pub/samba}
and browse the user survey.

Related packages include:
\begin{itemize}
\item  smbfs, a linux-only filesystem allowing you to mount remote SMB
filesystems from PCs on your linux box. This is included as standard with
Linux 2.0 and later.
\item  tcpdump-smb, a extension to tcpdump to allow you to investigate SMB
networking problems over netbeui and tcp/ip.
\item  smblib, a library of smb functions which are designed to make it
easy to smb-ise any particular application. See
ftp://samba.anu.edu.au/pub/samba/smblib.
\end{itemize}


{\bfseries FTP SITE}

The main anonymous ftp distribution site for this software is
samba.anu.edu.au in the directory pub/samba/.
{\bfseries WEB SITE}

A Samba WWW site has been setup with lots of useful info. Connect to:

\url{http://samba.canberra.edu.au/pub/samba/}

As well as general information and documentation, this also has searchable
archives of the mailing list and a user survey that shows who else is using
this package. Have you registered with the survey yet? :-)

It is maintained by Paul Blackman (thanks Paul!). You can contact him
at ictinus@lake.canberra.edu.au.


\subsubsection{Samba and LPRng}

The SAMBA code is very easy to configure.  See the SAMBA
documentation for details,  but you only need to modify
the samba.conf file and put in the pathnames of the LPRng
facilities.  The following is a sample.

\begin{verbatim}
From: Sascha Ottolski <alzhimer@cs.tu-berlin.de>
To: lprng@iona.com
Subject: Re: [LPRng] lprng-3.2.6 and smb on Linux
webnut@conc.tds.net said:
> I have samba sending print from Win95 machines to LPRng.  The key to
> making it work is in the samba.conf file in the [global] section:
>    printing = lprng
>    print command = /usr/local/bin/lpr  -P%p %s -r
>    lpq command   = /usr/local/bin/lpq  -P%p
>    lprm command  = /usr/local/bin/lprm -P%p %j
>    printcap name = /etc/printcap
>    load printers = no 
\end{verbatim}

\begin{verbatim}
Reply-To: "Pascal A. Dupuis" <dupuis@lei.ucl.ac.be>
To: papowell@astart2.astart.com
Subject: Re: LPRng-3.2.10
\end{verbatim}


I include the smbprint script used to send stdin to a NetBEUI printer.
\begin{verbatim}
#!/bin/sh -x
# This script is an input filter for printcap printing on a unix machine. It
# uses the smbclient program to print the file to the specified smb-based 
# server and service.
# For example you could have a printcap entry like this
#
# smb:lp=/dev/null:sd=/usr/spool/smb:sh:if=/usr/local/samba/smbprint
#
# which would create a unix printer called "smb" that will print via this 
# script. You will need to create the spool directory /usr/spool/smb with
# appropriate permissions and ownerships for your system.
#
# The /usr/spool/smb/.config file should contain:
#   server=PC_SERVER
#   service=PR_SHARENAME
#   password="password"
#
# Set these to the server and service you wish to print to 
# In this example I have a WfWg PC called "lapland" that has a printer 
# exported called "printer" with no password.
#
# E.g.
#   server=PAULS_PC
#   service=CJET_371
#   password=""
# Should read the following variables set in the config file:
#   server, service, password
config_file=.config
eval `cat $config_file`
# echo "server $server, service $service" 2>&1
(
# NOTE You may wish to add the line `echo translate' if you want automatic
# CR/LF translation when printing.
#       echo translate
    echo "print -"
    cat
) | /usr/local/bin/smbclient "\\\\$server\\$service" \
   $password -U $server -N -P
# comment preceeding line and uncomment following 
# to just test for correct filter working
#) | cat > /dev/null
\end{verbatim}

\label{printspec}


\subsection{Printer Specific notes}

This is a small collection of miscellaneous notes about printers
and applications.


\subsubsection{HP Deskjet}

\begin{verbatim}
From: jarausch@igpm.rwth-aachen.de (Helmut Jarausch)
Subject: Re: Using gs (ghostscript) as a filter? 
To: lprng@iona.com
Cc: Rick Gaine <rgaine@nbcs.rutgers.edu>
Sender: majordomo-owner@iona.com
Reply-To: lprng@iona.com
>> 
>> Hello All:
>> 
>> I would like to use LPRng 3.1.4 with an HP LaserJet 4P.  I'd like to be
>> able to use gs to convert PostScript files so that I can print them on my
>> HP 4P.  Can I do this with LPRng?  If so, could someone semd me a printcap
>> entry?  I'd appreciate it.  I am not sure how I will be cconnecting the
>> printer yet, but I am thinking either serial or network.  Probably serial
>> though.  Thanks for any help.
\end{verbatim}


This printcap works for my Deskjet:
\begin{verbatim}
djps
        :cm=Local Deskjet(GhostScript)
        :sd=/var/spool/djps:sf:sh:mx#0
        :lp=/dev/plp
        :if=/usr/LOCAL/bin/LPRng/ps_to_deskjet:
\end{verbatim}


and this is the script /usr/LOCAL/bin/LPRng/ps\_to\_deskjet
\begin{verbatim}
#!/bin/sh
nice -19 /usr/LOCAL/bin/gs -sDEVICE=cdj550 -sPAPERSIZE=a4 -sOutputFile=- -q -r300 - 
\end{verbatim}

\begin{verbatim}
Helmut Jarausch
Lehrstuhl f. Numerische Mathematik
Institute of Technology
RWTH Aachen
D 52056 Aachen, Germany
\end{verbatim}



\subsubsection{HP Deskjet 1600CM}

The following printcap entry was posted by
Olaf Lotzkat (Sysadm), Faculty of Computer Science, TU Dresden, Germany
{\ttfamily $>$Olaf\_Lotzkat@inf.tu-dresden.de$<$}.
\begin{verbatim}
# HP DeskJet 1600CM
tinte|:
    :lp=dj1600cm%9100:
    :mx#0:
    :rw:
    :sf:
    :ps=status:
    :af=acct:
    :lf=log:
    :fx=flpv:
    :if=/usr/local/lib/filters/ifhp \
     -Tpagecount=off,forcepagecount=on,infostatus=off,sync=off:
    :of=/usr/local/lib/filters/ofhp \
     -Tpagecount=off,forcepagecount=on,infostatus=off,sync=off,banner=off:
    :vf=/usr/local/lib/filters/ifhp -c:
    :bp=/usr/local/lib/filters/psbanner:
    :sd=/lpspool/tinte:
\end{verbatim}



\subsubsection{Duplex Printing}

Duplex printing is when you print on both sides of a page.
Some printers which do duplex printing require that you
send them special commands to force this mode.  This is
usually done by the FILTERS.  The CTI-ifhp (for HP PJL printers)
and psfilter (for PostScript Printers) make a stab at sending
the PJL or PostScript commands to the printer.  Many people have
reported problems doing duplex printing,  so  here is a check
list.
\begin{enumerate}
\item Make sure you have enough memory for the worst case
print job.  Usually the printer has to rasterize both
pages before it can produce an impression.  It may require
much more memory than you expect.
\item Check your printer manual to discover the EXACT form of the
{\ttfamily enter duplex mode} command and make sure that either the command
is part of the job (PJL language at the start of the job,
postscript header, etc), or that the filter generates the
correct form.
Note there is a PostScript Printer Description file (PPD) for
most printers that support PostScript,  and they even have the
PJL and PostScript code for this in the PPD file.

\item It has been observed that even with what would apparently be
sufficient memory,  that many duplex jobs print 'oddly',
that they are not aligned on the same side in the same way,
etc etc.  This may not be the fault of the software,  but of the
support for duplex operation.
\item Get the source code for psfilter or CTI-ifhp filter,  and modify the
appropriate lines to send the appropriate "turn on duplex" strings
to the printer.
\end{enumerate}


I know this is painful,  but until there is a uniform way to get the
correct commands extracted from either PPD or some other database then
this appears to be the only way to do it.
\begin{quotation}
{\itshape Patrick Powell\/}
\end{quotation}



\subsection{TESTVERSION  and Portability Testing}

The LPRng code has the ability to run as non-setuid software,
and to use the non-default TCP/IP ports for communication.
This facility allows a {\itshape TESTVERSION\/} to be run in parallel with the
normal LPRng software.

To simplify testing and portability issues,
a simple test version of the spool queues and jobs has been supplied with the
LPRng distribution.
These queues can be placed in a suitable location
({\ttfamily /tmp} is common) and the LPRng software tested.

The test version of the software will use the {\ttfamily LPD\_CONF}
environment variable to specify the location of the configuration file.
It will read this configuration file on startup and use the values
to override the normal defaults.
Since a user could maliciously set up their own configuration files
with values that could compromise system security,
it is strongly recommended that the test version is not made SETUID root.
In fact,
the LPRng code will chatter messages when the LPD\_CONF ability is enabled
and it is run as root.


\subsubsection{Compiling the TESTVERSION}

The TESTVERSION of the software can be compiled in two ways:
\begin{enumerate}
\item Remove the {\ttfamily vars.o} file,
and then explicitly request the generation of the test version:
\begin{verbatim}
cd src
rm ./vars.o 
make TESTVERSION=yes
\end{verbatim}
\item Edit {\ttfamily src/Makefile}, and uncomment the indicated line.
Then run {\ttfamily make} to regenerate the distribution.
This is the preferred method of generating the software.
\begin{verbatim}
#### ****** TESTING AND SECURITY LOOPHOLE ******************************
# Define TESTVERSION and GETENV to allow the LPD_CONFIG environment
#  variable to be used as the name of a configuration file.  In non-testing
#  systems,  this is a security loophole.
# TESTVERSION=yes
\end{verbatim}
\end{enumerate}



\subsubsection{Setting up the TESTVERSION Spool Queues}

The LPRng {\ttfamily TESTSUPPORT} directory contains a set of shell scripts
and files that need to be installed in the appropriate directory.
The following steps are used.
\begin{enumerate}
\item First,
you need to set up your {\ttfamily HOST} environment variable to the fully
qualified domain name of your host
and your {\ttfamily USER} environment variable to your user name.
This is done in order to get values to put into the TESTVERSION configuration files.
\item In the {\ttfamily TESTSUPPORT} directory,
edit the {\ttfamily Makefile},
and specify the location of the {\ttfamily TESTVERSION} spool queues.
The default location is {\ttfamily /tmp};
since on most systems these files are deleted or are available to everybody,
a more secure location should most likely be used.
{\bfseries DO NOT USE THE RAW TESTFILE DIRECTORY}.
These files need to be copied and placed in another directory.
\item The {\ttfamily LPD\_CONF} environment variable should be set to the
location of the installed lpd.conf file.
\item In the {\ttfamily TESTSUPPORT} directory,
run {\ttfamily make}.
This will copy and install the necessary files.
\end{enumerate}


Example:
\begin{verbatim}
  CSH:
    setenv HOST {fully qualified domain name};
    setenv USER `whoami`
    setenv LPD_CONF /tmp/LPD/lpd.conf
    set path=( /tmp/LPD $path )
    unsetenv PRINTER
   Example:
      setenv HOST astart1.astart.com
      setenv USER papowell
      setenv LPD_CONF /tmp/LPD/lpd.conf
      set path=( /tmp/LPD $path )
      unsetenv PRINTER
  Bourne Shell:
    HOST={fully qualified domain name}; export HOST;
    USER='whoami'; export USER
    LPD_CONF=/tmp/LPD/lpd.conf.$HOST; export LPD_CONF
    PATH=/tmp/LPD:$PATH; export PATH
    PRINTER=; export PRINTER
   Example: 
      HOST=astart1.astart.com; export HOST
      USER=papowell; export USER
      LPD_CONF=/tmp/LPD/lpd.conf.$HOST; export LPD_CONF
      PATH=/tmp/LPD:$PATH; export PATH
      PRINTER=; export PRINTER
  cd TESTSUPPORT
  make
\end{verbatim}



\subsubsection{Portability Testing}

You should ignore the information in this section UNLESS you are
trying to do a port to a new or whacko version of a UNIX system.
LPRng has been tested on just about every version of UNIX that supports
POSIX capabilities,
and if it is having problems then most likely it is due to non-portability
issues.
However,
if you feel that your system is not POSIX compatible,
or you are having serious problems due to LPRng's use of the system facilities,
feel free to try the following tests.

Needless to say,
if you identify problems,  please inform the developers and they will
most likely assist you in resolving them.

Set your current directory to the location of the compiled {\ttfamily TESTVERSION}
executables.
Execute the various executables using {\ttfamily ./cmd},
or set {\ttfamily .} {\bfseries  as the first entry in the PATH }.
If it is not the first entry,
then the standard system executables will be used.
\begin{enumerate}
\item  Run {\ttfamily ./checkpc -T /tmp/a}.
This will perform a limited set of tests of the LPRng functionality.
Note that some of them will fail as checkpc is not running SUID ROOT
and the {\ttfamily /tmp/a} is not a serial device.
ALL of the non-SUID related messages should indicate success.
\item  Set {\ttfamily checkpc} to setuid ROOT, and then rerun the tests.
\begin{verbatim}
chown root checkpc
chmod u+s checkpc
./checkpc -T /tmp/a
\end{verbatim}

The SETUID tests should now succeed.
If they do not,
then you have a VERY odd UNIX system,
and you are on your own on this one.
See the comments in {\ttfamily src/common/setuid.c} for help.

\item Now run tests for serial line control and locking:
\begin{verbatim}
./checkpc -T /dev/ttya   # or an appropriate UNUSED tty device
\end{verbatim}

You most likely will have to attach a terminal or modem to the serial device
in order to cause the {\ttfamily open()} to succeed,
as most serial device drivers block when {\ttfamily DSR} is not enabled.
Check the messages concerning the {\ttfamily stty} actions.
Make sure that the appropriate changes have taken place.

You may get errors about {\itshape device lock\/} failing.
This is due to whacko differences in the ways that different UNIX systems
(or versions of the same UNIX system) implement serial device locking.
My advice is to ignore this problem unless you INSIST on having multiple users
of the same serial printing port,
in which case you are asking for serious trouble,
and you are on your own.
I am not interested in patches or queries on problems on serial device locking
problems.
In fact,
this facility is only used if the {\ttfamily lk} printcap flag is TRUE
(default FALSE).

\end{enumerate}



\subsubsection{Running the TESTVERSION Software}

Set your current directory to the location of the compiled {\ttfamily TESTVERSION}
executables.
Execute the various executables using {\ttfamily ./cmd},
or set {\ttfamily .} {\bfseries  as the first entry in the PATH }.
If it is not the first entry,
then the standard system executables will be used.
\begin{enumerate}
\item  Run {\ttfamily ./checkpc}.
this will print out the various values for the spool queues in the {\ttfamily TESTVERSION}
setup.
If the {\ttfamily t1}, {\ttfamily t2},... spool queues are not displayed,
make sure that the LPD\_CONF environment variable is set correctly and that you
are using the {\ttfamily TESTVERSION} executable.
\item Run {\ttfamily ./checkpc -f}.
This will fix up the (deliberately introduced) problems in the spool queues.
\item Next,  run {\ttfamily ./lpd -F} in one window,
and then run {\ttfamily ./lpq -a } in another window.
This will check that the server is working.
\item You can now amuse yourself by sending jobs,
setting up permissions checking,
and other chores.
\item When everything appears to be working correctly,
you can then remove the {\ttfamily TESTVERSION} flag from the
{\ttfamily src/Makefile}, recompile,
and install the LPRng software.
\end{enumerate}

\label{printcapref}


\section{/etc/printcap Print Spool Database File}

The heart of the LPRng system is the file {\ttfamily /etc/printcap}. This
file contains a list of printer definitions. I'll describe a few
simple configurations.
I would advise you to read through all of them, as I will introduce
several features gradually throughout this section.

For details about individual printcap
items, see the {\ttfamily printcap(5)}
man page from the LPRng distribution,
or entries in the
\ref{index} {(index)} section.
\label{index}
\label{options}


\subsection{Index To All The Options}

\begin{table}[tbp]
\begin{center}
\begin{tabular}{{$|$}l{$|$}l{$|$}}
Option& Meaning\\ 
{\ttfamily \ref{ab} {(ab)}}& always print banner, ignore lpr -h option\\ 
{\ttfamily \ref{achk} {(achk)}}& query accounting server when connected\\ 
{\ttfamily \ref{ae} {(ae)}}& accounting at end (see also af, la, ar, as)\\ 
{\ttfamily \ref{af} {(af)}}& name of accounting file (see also la, ar)\\ 
{\ttfamily \ref{ah} {(ah)}}& automatically hold all jobs\\ 
{\ttfamily \ref{allowduplicateargs} {(allow\_duplicate\_args)}}& Allow duplicate command line arguments (legacy requirement)\\ 
{\ttfamily \ref{allowgetenv} {(allow\_getenv)}}& Allow use of LPD\_CONF\\ 
{\ttfamily \ref{allowuserlogging} {(allow\_user\_logging)}}& allow users to request logging info using lpr -mhost\%port\\ 
{\ttfamily \ref{ar} {(ar)}}& enable remote transfer accounting (if af is set)\\ 
{\ttfamily \ref{as} {(as)}}& accounting at start (see also af, la, ar)\\ 
{\ttfamily \ref{be} {(be)}}& Banner at End Generation Program\\ 
{\ttfamily \ref{bk} {(bk)}}& Berkeley LPD job file format\\ 
{\ttfamily \ref{bkfilteroptions} {(bk\_filter\_options)}}& Berkeley LPD filter options\\ 
{\ttfamily \ref{bkoffilteroptions} {(bk\_of\_filter\_options)}}& Berkeley LPD OF filter options\\ 
{\ttfamily \ref{bkf} {(bkf)}}& backwards-compatible filters: use simple paramters\\ 
{\ttfamily \ref{bl} {(bl)}}& short banner line sent to banner printer\\ 
{\ttfamily \ref{bp} {(bp)}}& Banner Generation Program (see bs, be)\\ 
{\ttfamily \ref{bq} {(bq)}}& Use filters on bounce queue jobs\\ 
{\ttfamily \ref{br} {(br)}}& Serial port bit rate (see ty)\\ 
{\ttfamily \ref{breakclassnameprioritylink} {(break\_classname\_priority\_link)}}& Don't default priority from classname (legacy requirement)\\ 
{\ttfamily \ref{bs} {(bs)}}& Banner at Start Generation Program\\ 
{\ttfamily \ref{cd} {(cd)}}& control directory\\ 
{\ttfamily \ref{checkfornonprintable} {(check\_for\_nonprintable)}}& LPR checks for nonprintable file\\ 
{\ttfamily \ref{checkidle} {(check\_idle)}}& program used to check for idle printer\\ 
{\ttfamily \ref{classnamelength} {(classname\_length)}}& Maximum length of classname argument (legacy requirement)\\ 
{\ttfamily \ref{cm} {(cm)}}& comment identifying printer (LPQ)\\ 
{\ttfamily \ref{co} {(co)}}& cost in dollars per thousand pages\\ 
{\ttfamily \ref{configfile} {(config\_file)}}& configuration file\\ 
{\ttfamily \ref{connectgrace} {(connect\_grace)}}& connection control for remote printers\\ 
{\ttfamily \ref{connectinterval} {(connect\_interval)}}& connection control for remote printers\\ 
{\ttfamily \ref{connecttimeout} {(connect\_timeout)}}& connection control for remote printers\\ 
{\ttfamily \ref{connecttry} {(connect\_try)}}& connection control for remote printers\\ 
{\ttfamily \ref{controlfilterbk} {(control\_filter)}}& control file filter\\ 
{\ttfamily \ref{db} {(db)}}& debug options for queue\\ 
{\ttfamily \ref{defaultauth} {(default\_auth)}}& default authentication\\ 
{\ttfamily \ref{defaultformat} {(default\_format)}}& default job format\\ 
{\ttfamily \ref{defaultloggerport} {(default\_logger\_port)}}& default port for logging info\\ 
{\ttfamily \ref{defaultloggerprotocol} {(default\_logger\_protocol)}}& default protocol for logging info\\ 
{\ttfamily \ref{defaultpermission} {(default\_permission)}}& default permission for files\\ 
{\ttfamily \ref{defaultprinter} {(default\_printer)}}& default printer\\ 
{\ttfamily \ref{defaultpriority} {(default\_priority)}}& default job priority\\ 
{\ttfamily \ref{defaultremotehost} {(default\_remote\_host)}}& default remote host\\ 
{\ttfamily \ref{defaulttmpdir} {(default\_tmp\_dir)}}& default directory for temp files\\ 
{\ttfamily \ref{destinations} {(destinations)}}& printers that a route filter may return and we should query\\ 
{\ttfamily \ref{directread} {(direct\_read)}}& filter input is direct from data file\\ 
{\ttfamily \ref{fc} {(fc)}}& OBSOLETE, see sy\\ 
{\ttfamily \ref{fd} {(fd)}}& forwarded jobs not accepted\\ 
{\ttfamily \ref{ff} {(ff)}}& string to send for a form feed\\ 
{\ttfamily \ref{filterldpath} {(filter\_ld\_path)}}& filter LD\_LIBRARY\_PATH value\\ 
{\ttfamily \ref{filteroptions} {(filter\_options)}}& filter options\\ 
{\ttfamily \ref{filterpath} {(filter\_path)}}& filter PATH environment variable\\ 
{\ttfamily \ref{fixbadjob} {(fix\_bad\_job)}}& fix bad job files\\ 
{\ttfamily \ref{fo} {(fo)}}& send form feed when device is opened\\ 
{\ttfamily \ref{forcelocalhost} {(force\_localhost)}}& force clients to send all requests to localhost\\ 
{\ttfamily \ref{forcequeuename} {(force\_queuename)}}& force use of this queuename if none provided\\ 
{\ttfamily \ref{forwardauth} {(forward\_auth)}}& do server to server authentication if authenticated by user\\ 
{\ttfamily \ref{fq} {(fq)}}& send form feed when device is closed\\ 
{\ttfamily \ref{fs} {(fs)}}& OBSOLETE (see sy)\\ 
{\ttfamily \ref{fulltime} {(full\_time)}}& use extended time format\\ 
{\ttfamily \ref{fx} {(fx)}}& valid output filter formats\\ 
{\ttfamily \ref{generatebanner} {(generate\_banner)}}& force a banner to be generated\\ 
{\ttfamily \ref{group} {(group)}}& Effective Group ID (EGID) for SUID ROOT programs\\ 
{\ttfamily \ref{hl} {(hl)}}& Header (banner) last, at end of job\\ 
{\ttfamily \ref{if} {(if)}}& default (f, l) filter program\\ 
{\ttfamily \ref{ipv6} {(ipv6)}}& using IPV6 conventions\\ 
{\ttfamily \ref{kerberoskeytab} {(kerberos\_keytab)}}& kerberos keytab file location\\ 
{\ttfamily \ref{kerberoslife} {(kerberos\_life)}}& kerberos key lifetime\\ 
{\ttfamily \ref{kerberosrenew} {(kerberos\_renew)}}& kerberos key renewal time\\ 
{\ttfamily \ref{kerberosserverprinciple} {(kerberos\_server\_principle)}}& kerberos remote server principle name\\ 
{\ttfamily \ref{kerberosservice} {(kerberos\_service)}}& kerberos default service\\ 
{\ttfamily \ref{la} {(la)}}& enable local printer accounting (if af is set)\\ 
{\ttfamily \ref{ld} {(ld)}}& leader string sent on printer open\\ 
{\ttfamily \ref{lf} {(lf)}}& error log file for spool queue\\ 
{\ttfamily \ref{lk} {(lk)}}& lock the IO device\\ 
{\ttfamily \ref{localhost} {(localhost)}}& localhost name for DNS queries\\ 
{\ttfamily \ref{lockfile} {(lockfile)}}& lpd lock file\\ 
{\ttfamily \ref{logfile} {(logfile)}}& lpd log file\\ 
{\ttfamily \ref{loggerdestination} {(logger\_destination)}}& additional destination for logging information\\ 
{\ttfamily \ref{longnumber} {(longnumber)}}& use long job number when a job is submitted\\ 
{\ttfamily \ref{lp} {(lp)}}& printer device name or specification\\ 
{\ttfamily \ref{lpdforcepoll} {(lpd\_force\_poll)}}& force lpd to poll idle printers\\ 
{\ttfamily \ref{lpdpolltime} {(lpd\_poll\_time)}}& interval between lpd printer polls\\ 
{\ttfamily \ref{lpdport} {(lpd\_port)}}& lpd listening port\\ 
{\ttfamily \ref{lpdprintcappath} {(lpd\_printcap\_path)}}& lpd printcap path\\ 
{\ttfamily \ref{lprbounce} {(lpr\_bounce)}}& lpr does filtering as in bounce queue\\ 
\end{tabular}
\end{center}
\end{table}

\begin{table}[tbp]
\begin{center}
\begin{tabular}{{$|$}l{$|$}l{$|$}}
{\ttfamily \ref{mailoperatoronerror} {(mail\_operator\_on\_error)}}& mail to this operator on error\\ 
{\ttfamily \ref{maxconnectinterval} {(max\_connect\_interval)}}& maximum time between connection attempts\\ 
{\ttfamily \ref{maxserversactive} {(max\_servers\_active)}}& maximum number of lpd queue servers that can be active\\ 
{\ttfamily \ref{maxstatusline} {(max\_status\_line)}}& maximum length of status line\\ 
{\ttfamily \ref{maxstatussize} {(max\_status\_size)}}& maximum size (in K) of status file\\ 
{\ttfamily \ref{mc} {(mc)}}& maximum copies allowed\\ 
{\ttfamily \ref{mi} {(mi)}}& minimum space (Kb) to be left in spool filesystem\\ 
{\ttfamily \ref{minstatussize} {(min\_status\_size)}}& minimum size to reduce status file to\\ 
{\ttfamily \ref{minfree} {(minfree)}}& minimum amount of free space needed\\ 
{\ttfamily \ref{ml} {(ml)}}& minimum number of printable characters for printable check\\ 
{\ttfamily \ref{mstimeresolution} {(ms\_time\_resolution)}}& millisecond time resolution\\ 
{\ttfamily \ref{mx} {(mx)}}& maximum job size (1Kb blocks, 0 = unlimited)\\ 
{\ttfamily \ref{nb} {(nb)}}& use nonblocking device open\\ 
{\ttfamily \ref{networkconnectgrace} {(network\_connect\_grace)}}& pause between transferring jobs to remote printer\\ 
{\ttfamily \ref{nw} {(nw)}}& spool dir is on an NFS file system\\ 
{\ttfamily \ref{of} {(of)}}& banner output filter\\ 
{\ttfamily \ref{offilteroptions} {(of\_filter\_options)}}& OF filter options\\ 
{\ttfamily \ref{originateport} {(originate\_port)}}& originate connections from these ports\\ 
{\ttfamily \ref{passenv} {(pass\_env)}}& clients pass these environment variables to filters\\ 
{\ttfamily \ref{permspath} {(perms\_path)}}& lpd.perms files\\ 
{\ttfamily \ref{pl} {(pl)}}& page length (in lines)\\ 
{\ttfamily \ref{pr} {(pr)}}& pr program for p format\\ 
{\ttfamily \ref{printcappath} {(printcap\_path)}}& /etc/printcap files\\ 
{\ttfamily \ref{ps} {(ps)}}& printer status file name\\ 
{\ttfamily \ref{pw} {(pw)}}& page width (in characters)\\ 
{\ttfamily \ref{px} {(px)}}& page width in pixels (horizontal)\\ 
{\ttfamily \ref{py} {(py)}}& page length in pixels (vertical)\\ 
{\ttfamily \ref{qq} {(qq)}}& put queue name in control file\\ 
{\ttfamily \ref{remotesupport} {(remote\_support)}}& operations allowed to remote host\\ 
{\ttfamily \ref{remoteuser} {(remote\_user)}}& remote-queue machine (hostname) (with rm)\\ 
{\ttfamily \ref{retryeconnrefused} {(retry\_econnrefused)}}& Retry on connect ECONNREFUSED errors\\ 
{\ttfamily \ref{retrynolink} {(retry\_nolink)}}& Retry device open or connect failures\\ 
{\ttfamily \ref{returnshortstatus} {(return\_short\_status)}}& return short lpq status when request arrives from specified host\\ 
{\ttfamily \ref{reuseaddr} {(reuse\_addr)}}& set SO\_REUSEADDR on outgoing ports\\ 
{\ttfamily \ref{reverselpqformat} {(reverse\_lpq\_format)}}& reverse lpq format when request arrives from specified host\\ 
{\ttfamily \ref{rg} {(rg)}}& clients allow only users in this group access to printer\\ 
{\ttfamily \ref{rm} {(rm)}}& remote machine (hostname) (with rp)\\ 
{\ttfamily \ref{router} {(router)}}& routing filter, returns destinations\\ 
{\ttfamily \ref{rp} {(rp)}}& remote printer name (with rm)\\ 
{\ttfamily \ref{rt} {(rt)}}& number of times to (re)try printing or transfer (0=infinite)\\ 
{\ttfamily \ref{rw} {(rw)}}& open printer for reading and writing\\ 
{\ttfamily \ref{safechars} {(safe\_chars)}}& additional safe characters in control file lines\\ 
{\ttfamily \ref{saveonerror} {(save\_on\_error)}}& save job when an error\\ 
{\ttfamily \ref{savewhendone} {(save\_when\_done)}}& save job when done\\ 
{\ttfamily \ref{sb} {(sb)}}& short banner (one line only)\\ 
{\ttfamily \ref{sc} {(sc)}}& suppress multiple copies\\ 
{\ttfamily \ref{sd} {(sd)}}& spool directory pathname\\ 
{\ttfamily \ref{sendblockformat} {(send\_block\_format)}}& send block of data, rather than individual files\\ 
{\ttfamily \ref{senddatafirst} {(send\_data\_first)}}& send data files first in job transfer\\ 
{\ttfamily \ref{sendfailureaction} {(send\_failure\_action)}}& failure action to take after send\_try attempts failed\\ 
{\ttfamily \ref{sendjobrwtimeout} {(send\_job\_rw\_timeout)}}& print job read/write timeout\\ 
{\ttfamily \ref{sendqueryrwtimeout} {(send\_query\_rw\_timeout)}}& status query operation read/write timeout\\ 
{\ttfamily \ref{sendtry} {(send\_try)}}& (alias for rt)\\ 
{\ttfamily \ref{sendmail} {(sendmail)}}& sendmail program\\ 
{\ttfamily \ref{serverauthcommand} {(server\_auth\_command)}}& server authenticate transfer program\\ 
{\ttfamily \ref{servertmpdir} {(server\_tmp\_dir)}}& server temporary file directory\\ 
{\ttfamily \ref{serveruser} {(server\_user)}}& server user name for authentication\\ 
{\ttfamily \ref{sf} {(sf)}}& suppress form feeds separating data files in job\\ 
{\ttfamily \ref{sh} {(sh)}}& suppress header (banner) pages\\ 
{\ttfamily \ref{shortstatuslength} {(short\_status\_length)}}& short lpq status length in lines\\ 
{\ttfamily \ref{socketlinger} {(socket\_linger)}}& set the SO\_LINGER socket option\\ 
{\ttfamily \ref{spooldirperms} {(spool\_dir\_perms)}}& spool directory permissions\\ 
{\ttfamily \ref{spoolfileperms} {(spool\_file\_perms)}}& spool file permissions\\ 
{\ttfamily \ref{spreadjobs} {(spread\_jobs)}}& amount to spread jobs to avoid collisions\\ 
{\ttfamily \ref{ss} {(ss)}}& name of queue that server serves (with sv)\\ 
{\ttfamily \ref{stalledtime} {(stalled\_time)}}& time after which to report active job stalled\\ 
{\ttfamily \ref{stoponabort} {(stop\_on\_abort)}}& stop processing queue on filter abort\\ 
{\ttfamily \ref{sv} {(sv)}}& names of servers for queue (with ss)\\ 
{\ttfamily \ref{sy} {(sy)}}& stty commands to set output line characteristictics\\ 
{\ttfamily \ref{syslogdevice} {(syslog\_device)}}& name of syslog device\\ 
{\ttfamily \ref{tr} {(tr)}}& trailer string to send before closing printer\\ 
{\ttfamily \ref{translateformat} {(translate\_format)}}& translate data format in control file\\ 
{\ttfamily \ref{ty} {(ty)}}& stty commands to set serial line characteristictics\\ 
{\ttfamily \ref{useauth} {(use\_auth)}}& authentication type to use\\ 
{\ttfamily \ref{usedate} {(use\_date)}}& force date in control file\\ 
{\ttfamily \ref{useidentifier} {(use\_identifier)}}& force identifier in control file\\ 
{\ttfamily \ref{useinfocache} {(use\_info\_cache)}}& read and cache information\\ 
{\ttfamily \ref{usequeuename} {(use\_queuename)}}& put queue name in control file (alias for qq)\\ 
{\ttfamily \ref{useshorthost} {(use\_shorthost)}}& Use short hostname for lpr control and data file names\\ 
{\ttfamily \ref{user} {(user)}}& Effective User ID (EUID) for SUID ROOT programs\\ 
{\ttfamily \ref{userauthcommand} {(user\_auth\_command)}}& client side authentication program\\ 
{\ttfamily \ref{userlpc} {(user\_lpc)}}& allow selected lpc commands on user files\\ 
{\ttfamily \ref{xc} {(xc)}}& OBSOLETE (see sy)\\ 
{\ttfamily \ref{xs} {(xs)}}& OBSOLETE (see ty)\\ 
{\ttfamily \ref{xt} {(xt)}}& formats supported on printer\\ 
{\ttfamily \ref{xu} {(xu)}}& additional permissions file for this queue\\ 
\end{tabular}
\end{center}
\end{table}

\label{cm}
\label{mx}
\label{secprintcap}


\subsection{A very simple example}

Options used:
\begin{itemize}
\item  {\ttfamily cm=}{\itshape comment for status\/}
\item  {\ttfamily if=}{\itshape default job file filter \/}
\item  {\ttfamily lf=}{\itshape log file \/}
\item  {\ttfamily mx\#}{\itshape maximum job size\/}
\item  {\ttfamily lp=}{\itshape output device\/}
\item  {\ttfamily sd=}{\itshape spool directory file \/}
\item  {\ttfamily sh}{\itshape ~~suppress headers (banners) \/}
\item  {\ttfamily sf}{\itshape ~~suppress form feeds between files\/}
\end{itemize}


The easiest configuration is this: a local printer directly connected
to a printer port.

\begin{verbatim}
# Local ASCII printer
lp1|printer
  # alias is printer or lp
  |lp
  :lp=/dev/lp1
  :cm=Dumb printer
  :sd=/var/spool/lpd/lp1
  :lf=log:af=acct
  :if=/usr/local/sbin/lpf
  :mx#0:sh:sf
\end{verbatim}


I'll use this simple example to explain the basics of the LPRng
printcap format.

Lines starting with a `\#' sign are comments, and all
leading and trailing {\itshape whitespace\/},
i.e. - spaces, tabs, etc, are ignored.
Empty lines are ignored as well.

Note that you are not required to use continuation backslashes
({\ttfamily $\backslash$}) as
would be needed for an BSD LPR style printcap file in the printcap entries.
You are allowed to use them, however: this comes in handy if you happen to
have a BSD LPR printcap file.
The backslash will cause the next line to be appended to the
current line;
watch out for comments and ends of printcap entries if you use this.

A printer (printcap entry) definition starts with the printer
{\itshape name\/},
followed by one or more {\itshape aliases\/},
followed by a list of options.
The name for a printer will be used be in LPRng
status output to identify the printer.

The colon (:) is used to start
the definition of an option or flag values.
The definition continues to the end of the line or until the
next colon.
If an option value contains a colon, then use
{\ttfamily $\backslash$:} to escape the value.
Options take the form of a
keyword/value pair.
Options and values are case sensitive;
for example
{\ttfamily Ts} and
{\ttfamily ts} refer to different options.
Numerical values are indicated by a `\#'
separator, while a `=' indicates a string value. Boolean switches
or flags are
set TRUE if no value follows the keyword and FALSE by
appending a `@'.
For example
{\ttfamily sh}
will set the
{\ttfamily sh} flag to TRUE and
{\ttfamily sh@} to FALSE.

There may be several options on the same line, separated
by colons.
However, this does make the file less readable. The next tip was
supplied by James H. Young $<${\ttfamily jhy@gsu.edu}$>$:

\begin{quotation}
My personal preference for readability is to always put each
option on its own line.  Putting each option on its own line is
worth the trouble even though it detracts from the usability
of certain grepping techniques when trying to maintain these
types of files.
\end{quotation}


Let's go over the options used in this example:

\begin{enumerate}
\item  First of all, there's the {\ttfamily lp} entry. It specifies the
file (or location) to which data is sent.
Here, it is the device {\ttfamily /dev/lp1}.
(This is system-dependent---check your vendor's manual for
information on devices.) The absolute
pathname indicates we have a local printer or file.
\item The {\ttfamily cm} field can be used to supply a comment to
be used as a header in {\ttfamily lpq} output.
\item {\ttfamily sd} specifies the spool directory.
This is where files
are stored until they are printed.
\item  The {\ttfamily lf} and {\ttfamily af} options specify the location
for the log and accounting files, respectively. They are not strictly
needed for the printer to function, but a log file is highly
recommended, in case things go wrong.
One special point to note: if these files don't exist, they will not
be created, and no logging or accounting will be done. You will
need to create them manually (e.g., by using {\ttfamily touch})
or by using the
\ref{checkpc} {( {$<$}tt{$>$}checkpc{$<$}/tt{$>$})}
program.
LPRng is very fussy about permissions - you should run
{\bfseries checkpc} to make sure that the log and status files have the
correct ownership and permissions.
\item The if entry specifies a `filter' for the `text' format. The
filter will be applied to any incoming job (of a certain format), even
the ones coming from another host. Filters and print formats are
discussed in section
\ref{secfilter} {(Filters)}. This
particular filter would translate UNIX LF line endings to DOS CR/LF,
to prevent the `staircase effect'
and expand tabs to spaces.
As this problem also occurs with
other printing daemons, it is likely that your system has a similar
utility.
\item {\ttfamily mx} indicates the maximum file size for a print job.
Supplying 0 here means that there is no limit.
\item Finally, I have given the {\ttfamily sh} (suppress headers) flag. This will
inhibit banner pages.
\end{enumerate}

\label{br}
\label{sy}
\label{ty}


\subsection{A serial printer queue}

Options used:
\begin{itemize}
\item  {\ttfamily br\#}{\itshape serial port bit rate\/}
\item  {\ttfamily sy=}{\itshape stty options for serial port configuration\/}
\item  {\ttfamily ty=}{\itshape (alias for sy)\/}
\end{itemize}


When connecting to a serial printer, you need to set up the
serial line so that it will pass data without any additional processing.
This will allow binary files to be transferred safely.
The {\ttfamily sy} printcap entry specifies a set of {\ttfamily stty(1)}
flags and line speed that will be used to set up the serial line.
(See
\ref{secserial} {(Serial Printers)}
for details)
The {\ttfamily br} (bit rate) option
can be used to specify the line speed as well.
The following is a typical printcap for a serial printer.
\begin{verbatim}
# Local Serial ASCII printer
lp2
  :lp=/dev/ttya
  :cm=Serial printer
  :sd=/var/spool/lpd/lp2
  :sy=9600 -echo -crmod -raw -oddp -evenp pass8 cbreak ixon
  :if=/usr/local/sbin/lpf
  :mx#0:sh
\end{verbatim}



\subsection{A remote printer queue}

Options used:
\begin{itemize}
\item  {\ttfamily lp=}{\itshape destination\/}
\item  {\ttfamily rm=}{\itshape remote host (machine)\/}
\item  {\ttfamily rp=}{\itshape remote printer (machine)\/}
\end{itemize}


LPRng will allow you to print over a TCP/IP network,
just like the BSD LPR software.
The machine from which you are printing is called the
{\bfseries  local } or {\bfseries  client } host.
You run the {\ttfamily lpr} program on the client host
to send print jobs to
the
{\ttfamily lpd}
daemon or server process running on
the remote {\bfseries server} host.
The
{\ttfamily lpd} daemon
accepts jobs for printing,
puts them in its print queue,
and processes them for printing on a printer.

This operation of having a user (client) program send requests or jobs
to another (server) program which does the actual work is called the
client/server model of computing.
The
{\ttfamily lpd}
daemon process is the server,
and the {\ttfamily lpr},
{\ttfamily lpq},
{\ttfamily lprm},
and
{\ttfamily lpc} are client programs.
The clients send either jobs or
service requests to the server using the
\ref{rfc1179} {(RFC1179)}
protocol.

One of the major ways that LPRng differs from the BSD LPD software is
that the client programs are vastly more powerful and flexible.
The BSD LPR software
client programs transferred print jobs
to spool (queue) directories on the client's host machine;
the
{\ttfamily lpd}
server
running on the client machine would then take these files
and transfer them to the remote
{\ttfamily lpd}
server.
This meant that every host
was required to run an
{\ttfamily lpd} daemon process and to have spool queues for every printer
that the user could possibly use.

Imagine the problems that exist in a facility with literally thousands
of printers,
many of which are being added or removed from service on a daily basis.
This would require the system administrators to either create spool directories
on each host.
The LPRng software eliminates these problems
by allowing client programs to directly transfer jobs
to a remote
{\ttfamily lpd} daemon or printer over a TCP/IP network connection.
This eliminates both the need for a
{\ttfamily lpd} daemon as well as the print spool directories
on the local host.

To send a job to a printer or remote
`{\ttfamily lpd}' daemon
all you need to do is specify the printer name and server hostname or
IP address.
This can be done using:
\begin{verbatim}
lpr -Ppr@server printfile
\end{verbatim}


This will cause the lpr program to transfer the printfile to the lpd daemon
running on the server host,
and spool it for the pr printer.
If you set the {\ttfamily  PRINTER } environment variable,
then you can simply do the following:
\begin{verbatim}
PRINTER=pr@server; export PRINTER;
lpr printfile
\end{verbatim}



\subsection{Network Printing With /etc/printcap}

While the above method is the simplest way to use the LPRng software
for network printing,
some users discover that they need the full power of a lpd server
running on their local host to support printing,
or need more than the simple transfer and network capabilities of the
client programs.
Another problem is that they sometimes need to have
{\itshape  aliases \/} for their printer names,
or want to be able to specify just the name of the printer
and have the remote server for it supplied by the printing software.

This type of operation requires setting up an /etc/printcap file
and using the printcap configuration information.
Both the client programs (lpr, lpc, lprm, lpq)
and the lpd daemon use the information in the /etc/printcap file
to specify how they will process print jobs.
While the same printcap file is used by both client programs and the lpd daemon,
but will use different parts of the information.

There are several possibilities for specifying network printers.
{\itshape I'm showing some different
syntaxes for the entries here.
This is the information that clients will need to have to send a job
to the network printer.\/}

\begin{verbatim}
# This is LPRng specific
remote|Remote Printer
   :lp=raw@server
# Convention from `old' BSD spooler
remote:Old Format:\
    :rp=raw:rm=server
# Sometimes you have to connect to a non-standard port
special:lp=lp@server%2000
\end{verbatim}


All the above printcap entries will make the lpr print client
connect to the remote host
{\ttfamily server},
and send the file to the {\ttfamily  raw } printer.
You can specify the remote printer and remote host using the
{\ttfamily :rp}
and
{\ttfamily :rm}
entries, or the LPRng extension {\ttfamily lp=rp@rm}.

Note that we don't need a spool directory for this kind of printers,
nor do we need to run {\ttfamily lpd} on the client host machine,
as the job will be transferred directly to the remote host.

Many printers now come equipped with a network support card that
has a built in LPD print spooler.
If this is the case you can print directly to the printer and do not
need to spool your print job to a server.
\label{forcelocalhost}
\label{localhost}


\subsection{Spooling To Local Server}

Options used:
\begin{itemize}
\item  {\ttfamily force\_localhost}{\itshape ~~force clients to send requests to localhost \/}
\item  {\ttfamily localhost=}{\itshape localhost name\/}
\end{itemize}


Some users may not want to send a print job directly to a remote printer.
The printer may need the more powerful management
functions of a print spooler to handle problems such as paper feed errors,
multiple users,
etc,
or needs to run special
\ref{secfilter} {(filters)}
to process the print job.
In this case,  they want the print job sent to a
{\ttfamily lpd} server on the local host,
which in turn will spool the job and send it to the remote printer.
This can be done in several ways.
\begin{verbatim}
# Method 1: force client transfer to localhost
#    have server send to real printer
#    both client and server will see the following information
remote|Spool to localhost
   :lp=lp@localhost
# Note that only the server will see the following information
lp:server:lp=lp@remote:sd=/usr/spool/lp
# Method 2: force client transfer to localhost
#    both client and server will see the following information
remote|Spool to localhost
   :force_localhost
   :lp=lp@remote:sd=/usr/spool/lp
# Method 3: force a bounce queue with no effect
remote|Spool to localhost
   :lp=lp@localhost
   :bq=lp@remote:sd=/usr/spool/lp
\end{verbatim}


In the first method,
we have the clients send jobs to the lp printer on the localhost;
localhost is the 'cannonical' network name for the host on which the
program is running.
The lpd server on the localhost will get the print job, store it in the
spool directory {\ttfamily /usr/spool/lp} and then forward the job to the
lp printer on the remote host.
The
{\ttfamily server} tag indicates that a printcap entry is to be used only
by the
{\ttfamily lpd} daemon (server) process, and the information is ignored by
the client.
The {\ttfamily server} tag is discussed in detail in the
\ref{secserver} {(Shared printcap files)} section.

One of the problems is finding the name of the local host.
On some implementations which are not using a Domain Name Server,
it is necessary to specify the local host name by using the
{\ttfamily localhost} configuration variable.

The second method is slightly different.
The {\ttfamily force\_localhost} flag
has meaning only for the client application programs,
and forces them to send the job to the localhost.
The server will then send the job to the remote host.

The third method is useful when you want the print job to be modified
{\itshape en passant\/} as it passes through the spool queue.
The LPD server will see the
\ref{secfilter} {(Filters)}
discussions.
\label{secserver}


\subsection{Shared printcap files}

When both the client host and server host are the same machine,
then the same /etc/printcap file will be used by both the lpr and lpd daemon
programs.
When LPRng programs read the /etc/printcap file,  they accumulate information
in the printcap file on individual printer entries.  For example,
the following printcap entries would result in the indicated information:
\begin{verbatim}
#/etc/printcap file
pr:lp=pr@host
pr:lp=/dev/lp:sh
#resulting printcap information:
pr:lp=/dev/lp:sh
\end{verbatim}


This allows us to split up the printcap information into different blocks,
and has been used to manage complex printcap entries on large sites with
many printers.

We can use the {\ttfamily server} tag to specify that specific
printcap information is only for use by the lpd daemon.
For example:
\begin{verbatim}
#/etc/printcap file
pr:lp=pr@host
pr:server:lp=/dev/lp:sh
#resulting printcap information for client
pr:lp=pr@host
#resulting printcap information for lpd daemon
pr:lp=/dev/lp:sh
\end{verbatim}


Many administrators at large sites will split up their printcap files
so that the information needed to tell clients where the servers are
for a printer is located at the start of the /etc/printcap file,
and the actual information needed by the lpd daemon is at the end.
Here is a sample:
\begin{verbatim}
#/etc/printcap file
pr1:lp=pr1@serverhost
pr2:lp=pr2@serverhost
pr1:server:lp=/dev/lp:tc=.common
pr2:server:lp=/dev/lp:tc=.common
.common:sd=/usr/local/lpd/%P
  :cm=Dumb printer %P
  :lf=log:af=acct
  :if=/usr/local/sbin/lpf
  :mx#0:sh
\end{verbatim}


This printcap entry also shows the use of the
{\ttfamily tc} option,
which corresponds to the
C Compiler Preprocessor (cpp)
{\ttfamily \#include} directive.
Printcap entries starting with periods or underscores ({\ttfamily \_})
are treated as dummy printcap information and can only be referenced
by the {\ttfamily tc}.

When the printcap information is read,
the LPRng code will substitute the cannonical printer name for any
{\ttfamily \%P} tokens that it finds in the printcap.
After processing the information in the printcap entry, the clients and
lpd daemon will see the following:
\begin{verbatim}
# clients
pr1:lp=pr1@serverhost
pr2:lp=pr2@serverhost
# server
pr1:lp=/dev/lp
  :sd=/usr/local/lpd/pr1
  :cm=Dumb printer pr1
  :lf=log:af=acct
  :if=/usr/local/sbin/lpf
  :mx#0:sh
pr2:server:lp=/dev/lp:
  :sd=/usr/local/lpd/pr1
  :cm=Dumb printer pr1
  :lf=log:af=acct
  :if=/usr/local/sbin/lpf
  :mx#0:sh
\end{verbatim}

\label{secoh}


\subsection{Master Printcap Files}

One of the major problems faced by administrators of large sites is how
to distribute printcap information.
They would like to have a single printcap file either distributed by
a file server (NFS) or by some other method such as rdist.

By using the
{\ttfamily server}
tag,
information for the lpd daemons can be separated out from the information
needed by the lpr print client.
The
{\ttfamily oh=pattern}
specifies that this information is only to be used by a specified host.
For example:
\begin{verbatim}
#/etc/printcap file
pr1:lp=pr1@serverhost1:oh=*.eng.site.com,130.191.12.0/24
pr2:lp=pr1@serverhost1:oh=*.eng.site.com,130.191.12.0/24
pr1:lp=pr2@serverhost2:oh=*.admin.site.com
pr2:lp=pr2@serverhost2:oh=*.admin.site.com
pr1:server:oh=serverhost1.eng.com:lp=/dev/lp:tc=.common
pr2:server:oh=serverhost2.admin.com:lp=/dev/lp:tc=.common
.common:sd=/usr/local/lpd/%P
\end{verbatim}


The above example is a total abuse of the use of
{\ttfamily oh}
tag,
but has some interesting effects.
The {\ttfamily pattern} is used as a {\itshape glob\/} pattern
and is applied to the fully qualified domain name (FQDN) of the
host reading the printcap file.
For example,
{\ttfamily *.eng.site.com} would match host
{\ttfamily h1.eng.site.com}
but would not match
{\ttfamily h1.admin.site.com}.
Thus, the effects of the first couple of entries would be to
specify that the
{\ttfamily pr1} and {\ttfamily pr2} printers on the
{\ttfamily eng} hosts would be {\ttfamily pr1@serverhost1},
and on the
{\ttfamily admin} hosts would be {\ttfamily pr2@serverhost2},

Also,
the lpd daemons on
{\ttfamily serverhost1}
and
{\ttfamily serverhost2}
would only extract the additional
information for
{\ttfamily pr1}
and
{\ttfamily pr2} respectively.

You can also specify network addresses and subnet masks as well.
In this case, if the host matches the network address then it
will use the information.


\subsection{Printcap options for lpr, lpq, lprm, and lpc}

These programs are used by users to connect to the {\ttfamily lpd}
server and send print jobs or a request.
For details about the way that this is done,
see
\ref{rfc1179ref} {(LPRng and RFC1179)} for details.

The following options and configuration variables are used by the
various programs to control how they will generate jobs and send
them to the server.
\label{lp}
\label{rm}
\label{rp}
\label{PRINTER}
\label{defaulthost}
\label{defaultprinter}


\subsubsection{lp, rm and rp}

The {\ttfamily rm} (remote machine or host) and {\ttfamily rp}
or {\ttfamily lp} printer printcap options
are used to specify the remote host and printer to be used.
These values can be extracted from a printcap entry,
or supplied in the following manner.
\begin{enumerate}
\item If the user program is not invoked with {\ttfamily -Pxxx} argument,
then the {\ttfamily lp} option is assigned value {\ttfamily xxx}.
\item If no explicit value is specified and the PRINTER environment variable has
value {\ttfamily xxx},
then the {\ttfamily lp} option is assigned value {\ttfamily xxx}.
\item If {\ttfamily lp} has a value of the form
{\ttfamily rp@rm}
or
{\ttfamily rp@rm\%port},
then the
{\ttfamily rp},
{\ttfamily rm},
and
{\ttfamily lpd\_port} options are assigned the indicated values.
\item If {\ttfamily rm} or {\ttfamily rp} does not have a value,
then they are assigned the {\ttfamily default\_host} (usually localhost)
and {\ttfamily default\_printer} (usually lp) option values.
\item A connection is made to {\ttfamily lpd\_port} on host {\ttfamily rm}
and the file transfer or command is sent as specified in
\ref{rfc1179ref} {(RFC1179)}.
\end{enumerate}


See the
\ref{lpdev} {(Opening Output Device)}
section for additional details.
\label{bq}
\label{generatebanner}
\label{translateformat}
\label{bouncequeues}


\subsection{Bounce queues}

Options used:
\begin{itemize}
\item  {\ttfamily bq=}{\itshape destination for processed jobs\/}
\item  {\ttfamily generate\_banner}{\itshape ~~do banner generation\/}
\item  {\ttfamily translate\_format}{\itshape ~~do banner generation\/}
\end{itemize}


Normally, when using a remote queue, the print job is transmitted to
the server computer without any modifications.
When it gets there, it
might be processed by one or more programs before being submitted to
the printer.

Sometimes, you will want to make some modifications to a print job on
the computer that sends the job,
or even a computer that is acting as a relay for job processing.
There are several reasons for doing this: the filter programs or some
of the fonts it needs might not be available on the server, or you
want to minimize the system load.

LPRng supports this capability by indicating that a printer
is actualy a
{\itshape bounce queue\/}.
The term comes from the notion that jobs will {\itshape  bounce \/} through
this print queue,
getting processed by the various facilities.
The output, rather than going to a physical device,
will then be forwarded to final destination over
the network for actual printing.

Again, you will modify the client printcap entry to declare this. In
the next example, `host' is the name of the host which will do the processing,
and `remote' is the target host with the printer.

\begin{verbatim}
# Simple example of a bounce queue
bounce
    :lp=bounce@bouncehost
    :bq=lp@remote
    :sd=/usr/spool/lpd/bounce
    :if=/usr/local/bin/lpf
    :vf=/usr/local/bin/lpf
    :translate_format=vl
    # uncomment if you want banner
    #:generate_banner
\end{verbatim}


Some comments:

\begin{enumerate}
\item The {\ttfamily lp=bounce@host} entry specifies the queue
and hostname where the filtering will be done.
This information is used by the lpr program to determine where to send
the print job.
\item After the lpd daemon on the bouncehost does the processing,
and then the output is transmitted to the queue and hostname
specified by the
{\ttfamily bq}
option.
\item We need a spool directory ({\ttfamily sd}) on the lpd server host
to hold the files and temporary output while they are processed.
\item Next, we need to indicate the filters to be used for different
printer formats.
{\itshape Oops, I still didn't tell you anything about
filters. Just a moment, it's on its way. See section
\ref{secfilter} {(Filters)}.\/}
\item The
{\ttfamily translate\_format}
specifies the way the data file formats will be renamed after filtering.
It the value consists of pairs of letters, the original and renamed format.
For example,
{\ttfamily translate\_format=vl}
specifies that after filtering,
format
{\ttfamily v}
files will be renamed to format
{\ttfamily l} (literal or binary).
You do not need to have a filter for a format to rename it.
For example,
{\ttfamily translate\_format=vlxf}
will rename format
{\ttfamily x}
files to
{\ttfamily f}
and there is no filter for format
{\ttfamily x}.
See
\ref{translateformat} {(translate\_format)}
for more details.
\item The {\ttfamily generate\_banner} flag will force a banner to be
added to the job.
The banner generation is done as discussed in
\ref{bannerprinting} {(Banner Printing)}.
\end{enumerate}


In this example, anything sent to the printer called {\ttfamily bounce} (on
this host) will be filtered on the client host. After that, it will be
transmitted to the queue {\ttfamily lp} on the server called
{\bfseries remote}.

\label{lprbounce}


\subsection{LPR Filtering}

Options used:
\begin{itemize}
\item  {\ttfamily lpr\_bounce}{\itshape ~~lpr does filtering\/}
\end{itemize}


Some users would like to have all of the advantages of having
the filtering and processing capabilities of a lpd daemon
without needing to deal with actualy running a lpd daemon
on their system.
By having the {\ttfamily lpr} program
process the job by passing it through the various filters
and then send the output of the filters as the print job you can
get the desired effect.
\begin{verbatim}
# Simple example of an lpr_bounce entry
bounce
  :lpr_bounce
  :lp=lp@remote
  :if=/usr/local/bin/lpf
\end{verbatim}


The
{\ttfamily lpr\_bounce}
flag, if present in the printcap entry,
will force {\ttfamily  lpr } to process the job using the
specified filters and send the outputs of the filters to the remote printer
for further processing.

In order to do filtering,  it may need to create some temporary files
and run some programs.  By default,  the temporary files are
created in the /tmp directory and the programs are run as user.
Since no spool directory is used, the {\ttfamily sd} information is not
needed.
\label{destinations}
\label{router}
\label{routing}


\subsection{Dynamic Routing}

Options used:
\begin{itemize}
\item  {\ttfamily destinations=}{\itshape destinations for jobs\/}
\item  {\ttfamily router=}{\itshape router program\/}
\end{itemize}


The LPD functionality bounce queue functionality has been extended
to allow a job to not only be passed through filters before sending
to a remote destination,  but also to reroute the job to one or
more destinations in a dynamic manner.  This is accomplished by having
a {\ttfamily router} filter return a set of destinations.  Here is a sample printcap
to accomplish this:
\begin{verbatim}
t2|Test Printer 2:sd=/var/spool/LPD/t2
    :lf=log
    :lp=t2@printserver
    :bq=t1@localhost
    :destinations=t1@localhost,t2@localhost
    :router=/usr/local/LPD/router
\end{verbatim}


The lp entry is used to force all jobs to be sent to the bounce queue
on host 'printserver'.
Once they arrive,  the 'router' filter
is invoked with the standard filter options which include
the user, host, and other information obtained from the control file.
STDIN is connected to a temporary copy of the control file,
and the CONTROL environment variable is set to the value of the
actual control file itself.

The routing filter exit status is used as follows:
\begin{itemize}
\item 0  (JSUCC) - normal processing
\item 37 (JHOLD) - job is held
\item any other value - job is deleted from queue
\end{itemize}


The router filter returns one or more routing entries with the
following format.  Note that entry order is not important, but each
entry must end with the 'end' tag.
\begin{verbatim}
dest (destination queue)
copies (number of copies to be made)
priority (priority letter)
X(controlfile modifications)
end
\end{verbatim}


Example of router output:
\begin{verbatim}
dest t1@localhost
copies 2
CA
priority B
end
dest t2@localhost
CZ
priority Z
end
\end{verbatim}


The above routing information will have copies of the job sent to
the t1 and t2 spool queue servers.  If no valid routing information
is returned by the router filter the job will be sent to the default
bounce queue destination.

LPQ will display job information in a slightly different format
for multiple destination jobs.  For example:
\begin{verbatim}
Printer: t2@astart2 'Test Printer 2' (routed/bounce queue to 't1@astart2.astart.com')
  Queue: 1 printable jobs in queue
 Rank  Owner/ID        Class Job Files                           Size Time
active  papowell@astart2+707 A 707  /tmp/hi                         3 10:04:49
 - actv papowell@astart2+707.1 A 707 ->t1@localhost <cpy 1/2>       3 10:04:49
 -      papowell@astart2+707.2 A 707 ->t2@localhost                 3 10:04:49
\end{verbatim}


The routing information is displayed below the main job information.
Each destination will have its transfer status displayed as it is
transferred.  By convention,  the job identifier of the routed jobs
will have a suffix of the form .N added;  copies will have CN added
as well.  For example, papowell@astart2+707.1C2 will be the job
sent to the first destination, copy two.

Routed jobs can be held, removed, etc., just as normal jobs.  In addition,
the individual destination jobs can be manipulated as well.  The LPC
functionality has been extended to recognize destination jobids as well
as the main job id for control and/or selection operations.

The optional
{\ttfamily destinations} entry specifies the possible set of
destinations that the job can be sent to,
and is for informational purposes only.
In order for LPQ/LPRM to find the job once it has passed though LPD you
it will
use the list of printers in the
{\ttfamily destinations},
and loop over all the names in the list looking for the "job" that you are interested in.
If there is no
{\ttfamily destinations}
information, the
{\ttfamily bq} information will be usued.

One of the more interesting use of the router filter is to
actualy modify the control file before it is put into the spool queue.
The routing filter has STDIN attached to the control file READ/WRITE,
allowing the following interesting bit of Perl code to be used:
\begin{verbatim}
 # you need to get PERL to do a 'dup' call on FD 0
 open(CF, '+<0');  
 # read the control file
 @cf_lines = <CF>;
 # TRUNCATE the control file
 truncate(CF,0);
 # mess about with the control file
 foreach $line (@cf_lines) {
    # or whatever you want
    print CF $line;
 } 
\end{verbatim}


This will read the control file,
truncate it,
and then write it out again.
\label{secnetwork}


\subsection{Support for Network Print Servers}

This section was supplied by Horst Fickenscher
$<${\ttfamily horst.fickenscher@it.erlm.siemens.de}$>$
and updated by Patrick Powell
$<${\ttfamily papowell@astart.com}$>$.

A ``network print server'' is usually a box
(external model) or card in a printer (internal model)
which has a network connection to a TCP network and
software to implement a LPD print server.
If it is an external model,
The parallel or serial port of
the printer is connected to the box,
and the print server may support multiple printers.
If it is an internal model,
the server is usually nothing more than a Network Interface Controller
and a ROM containing software that the microprocessor in the printer
uses.

The print server may support multiple printing protocols,
such as
\ref{rfc1179} {(RFC1179)}
(TCP/IP printing using the LPD print protocol),
Novell Printer Protocols,
SMB print protocols,
and Appletalk protocols.
One of the observed problems with Network Print servers is that while they
can usually support one protocol and one user at a time quite well,
when you try to use multiple protocols and/or multiple users try to transfer
print jobs to the printer,  the printer may behave in a very odd manner.
Usually this results in a printer failing to finish a job currently being
printed,
and unable to accept new jobs.

Several of the newer models of print servers have
Simple Network Management Protocol (SNMP) agents built into them,
and can provide detailed information about their internal functions.
By using a SNMP manager such as SunNetmanage or HP-Openview,
you can monitor your network printers activities.

Although it's possible to connect to network printers as if they were
remote printers, Patrick Powell advises differently:

\begin{quotation}
I recommend that you use only a single protocol to send jobs to the printer
at a time.
If you can,  I also recommends that you use a print spooler and have only
a single host system send a job to the printer.

My best advice on connecting to network printers is not to use the
the built-in LPD server,
but to use the direct TCP/IP connection to the print engine.
Usually this is done to particular TCP/IP port on the printer.
For the HP JetDirect and other HP products, this is usually~9100.

Once you have the direct connection,
you can now use various filters to preprocess the print job,
insert PJL and PCL commands,
or convert text to PostScript or PCL for better print quality.

\end{quotation}


Here is a sample printcap for an
HP LaserJet 4 or above, attached via an HP JetDirect print server.
It uses the CTI-ifhp filters:
\begin{verbatim}
     # printcap file for pr4
     # PostScript via JetDirect card, IP address pr4, port 9100.
     # Note: some PC's LPR packages use the v format for their jobs
     #
     pr4|network
         :rw:sh:lp=pr4%9100:sd=/usr/spool/lpd/pr4
         :af=acct: :lf=log: :ps=status
         # only allow the following formats
         :fx=flpv
         #filters
         :if=/usr/local/lib/CTI-Print/bin/ifhp
         :of=/usr/local/lib/CTI-Print/bin/ofhp
         :vf=/usr/local/lib/CTI-Print/bin/ifhp -c
\end{verbatim}


The {\ttfamily lp=pr4\%9100} means that LPRng is to make a TCP/IP
connection to host {\ttfamily pr4} on its port~9100.
The CTI-Print filters
referenced in {\ttfamily if}, {\ttfamily of}, and {\ttfamily vf},
send PJL (and PCL) commands along with the print files to the
printer.
The CTI-Print filters are available
separately from the LPRng distribution sites.

Filters are discussed in section
\ref{secfilter} {(Filters)}.

According to Richard S.~Shuford $<${\ttfamily s4r@ornl.gov}$>$, some DEC
printers (e.g., the DEClaser~3500) use TCP port~10001.


\subsection{Printer load balancing}

In a large site, you could have several equivalent printers, which
will be used by many people. The reason for this is, of course, to
increase the printer output, by enabling several jobs to be printed at
once.

LPRng supplies mechanisms to define a `virtual' printer for such a set
of real printers. If properly set up, print jobs will be distributed
evenly over all printers.

I'll give two examples for this situation.
\label{ss}
\label{sv}


\subsubsection{Multi-server print queue}

Options used:
\begin{itemize}
\item  {\ttfamily ss=}{\itshape queue served by printer \/}
\item  {\ttfamily sv=}{\itshape printers where jobs are sent (servers)\/}
\end{itemize}


A multi-server print queue is one that feeds jobs to other queues.
The main queue
{\ttfamily sv=q1,q2,...} printcap entry specifies the names of the printers
that will be sent jobs.
These printers must have their spool queues on this LPD server.

Servers that are fed jobs have a
{\ttfamily ss=mainqueue}
printcap entry.
This informs the {\ttfamily lpd} server that the queue operates under the
control of the mainqueue print queue,
and is fed jobs from it.

During normal operation,
when the {\ttfamily lpd} server has a job to print in the {\itshape mainqueue\/},
it will check to see if there is an idle {\itshape service\/}  queue.
If there is,
it will transfer the job to the service queue spooling directory
and start the service queue printing activities.

Users can send jobs directly to the individual printers serving a queue.

The next example (and the comments underneath) was supplied by John Perkins
$<${\ttfamily john@cs.wisc.edu}$>$ (slightly edited).

Here's how I've set up a bounce queue that feeds 6 LaserWriters:

\begin{verbatim}
laser|pi|Room 1359 LaserWriters
    :lp=laser@server.com
laser|pi|Room 1359 LaserWriters
    :server
    :lf=/usr/adm/laser-log
    :sv=laser1,laser2,laser3,laser4,laser5,laser6
    :sd=/usr/spool/laser
@commonlaser
    :sd=/usr/spool/%P
    :rw:mx#0:sh
    :lf=/usr/adm/laser1-log
    :if=/s/lprng/lib/filters/cappsif
    :of=/s/lprng/depend/cap/bin/papof
    :ss=laser
    :fx=fdginpt
laser1|pi1|Room 1359 LaserWriter #1
    :lp=laser1@server.com
laser1|pi1|Room 1359 LaserWriter #1
    :server
    :lp=/dev/laser1
    :tc=@commonlaser
laser2|pi2|Room 1359 LaserWriter #1
    :lp=laser2@server.com
laser2|pi2|Room 1359 LaserWriter #2
    :server
    :lp=/dev/laser2
    :tc=@commonlaser
\end{verbatim}


and so on for the other 4~{\ttfamily laser?} queues.

This will forward a job from {\ttfamily laser} to {\ttfamily laser?}, once
one of those queues is available. It will hold jobs in the
``{\ttfamily laser}'' queue until one of the other queues is empty.

Even though the queues are not meant for
direct use,
people can print directly to individual queues.
This allows a specific load sharing printer to be used.
If you wanted to
{\itshape hide\/} the load sharing printers,
then you would simply remove the entries for them at
the start of the printcap file.
\label{checkidle}


\subsubsection{Checking Busy Status of Server Queues}

Options used:
\begin{itemize}
\item  {\ttfamily check\_idle=}{\itshape check for idle printer program \/}
\end{itemize}


The previous section outlined how LPRng uses the {\ttfamily sv} and {\ttfamily ss}
flags to indicate that the server spool queue has multiple destination queues.
However,
there is a problem when the actual printer being served by the destination queue
is a remote device,
and can be busy or offline.

The {\ttfamily check\_idle} option specifies a program that is invoked by the
{\ttfamily lpd}
server to determine if the spool queue device is available.

The program is invoked with the standard filter options,
STDIN and STDOUT connected to {\ttfamily /dev/null},
and STDERR to the error log.

The program should make a connection to the remote device or system
and should determine that the remote device is available for use,
and then exit with the following status.
\begin{verbatim}
Key      Value   Meaning
JSUCC    0       Successful - printer is idle
JABORT   non-zero Printer is not accepting jobs
\end{verbatim}


If the printer is accepting jobs but is temporarily busy,
then the program should poll the printer until it becomes
free,
and only exit when it is available for use.
If the printer is not accepting jobs, then the program should
exit with a non-zero exit code. 

The following is a sample printcap entry, showing how the {\ttfamily check\_idle}
facility can be used.
\begin{verbatim}
pr:
  :lp=laserjet%9100
  :check_idle=/usr/local/filters/remote_check lp@laserjet
  :if=/usr/local/filters/ifhp
\end{verbatim}


The following perl program shows how to generate a query to the
remote printer by simulating an {\ttfamily lpq} query and checking for
returned status.
\begin{verbatim}
#!/usr/local/bin/perl
# Usage:
#  remote_check printer@host[%port] [-options]
#   -Tflag[,flags]*
#  flag
#    debug  - turns debugging on
#    long   - use long status format
#
# query the remote printer whose name is passed on the command line
# 
# Note that -Txxx options are passed AFTER the printer
use English;
use IO::Socket;

my $JSUCC = 0;
my $JABORT = 33;
my $JNOSPOOL = 38;
my $JNOPRINT = 39;

my $debug = 0;
my $optind;

# pull out the options
my($key,$value,$opt,$long,$opt_c);

$printer = $ARGV[0];

for( $i = 1; $i < @ARGV; ++$i ){
    $opt = $ARGV[$i];
    print STDERR "XX opt= $opt\n" if $debug;
    if( $opt eq '-c' ){
        $opt_c = 1;
    } elsif( ($key, $value) = ($opt =~ /^-(.)(.*)/) ){
        if( $value eq "" ){
            $value = $ARGV[++$i];
        }
        ${"opt_$key"} = $value;
        print STDERR "XX opt_$key = " . ${"opt_$key"} . "\n" if $debug;
    } else {
        $optind = $i;
        last;
    }
    print STDERR "XX opt_P = $opt_P\n" if $debug;
}

$long = 0;  # short

if( defined($opt_T) ){
    print STDERR "XX CHECK_REMOTE opt_T=$opt_T\n" if $debug;
    if( $opt_T =~ /debug/ ){
        $debug = 1;
    }
    if( $opt_T =~ /short/ ){
        $long = 1;
    }
    if( $opt_T =~ /long/ ){
        $long = 0;
    }
}

print STDERR "XX CHECK_REMOTE " . join(" ",@ARGV) . "\n" if $debug;

if( !defined($printer) or $printer =~ /^-/ ){
    print STDERR "$0: no printer value\n";
    exit( $JABORT );
}

while( checkstatus( $printer, $long ) ){
    print STDERR "XX CHECK_REMOTE sleeping\n" if $debug;
    sleep(10);
}

exit $JSUCC;

sub checkstatus {
    my ($printer,$long) = @_;
    my ($remote,$port);
    my ($count, $socket, $line);

    if( $long ){
        $long = 4;
    } else {
        $long = 3;
    }
    if( $printer =~ /@/ ){
        ($printer,$remote) = $printer =~ m/(.*)@(.*)/;
    }
    $remote="localhost" unless $remote;

    if( $remote =~ /%/ ){
        ($remote,$port) = $remote =~ m/(.*)%(.*)/;
    }
    $port = 515 unless $port;
    print STDERR "XX CHECK_REMOTE remote='$remote',"
        . " port='$port', pr='$printer', op='$long'\n" if $debug;

    $socket = getconnection( $remote, $port );

    $count = -1;
    # send the command
    printf $socket "%c%s\n", $long, $printer;

    while ( defined( $line = <$socket>) && $count < 0 ){
        chomp $line;
        print STDERR "XX CHECKREMOTE '$line'\n" if $debug;
        if( $line =~ /printing disa/ ){
            print STDERR "XX CHECKREMOTE printing disable\n" if $debug;
            exit $JNOPRINT;
        } elsif( $line =~ /spooling disa/ ){
            print STDERR "XX CHECKREMOTE printing disable\n" if $debug;
            exit $JNOSPOOL;
        } elsif( $line =~ /([0-9]*)\s+job.?$/ ){
            $count = $1;
            print STDERR "XX CHECKREMOTE $count jobs\n" if $debug;
        }
    }
    close $socket;
    if( $count < 0 ){
        print STDERR "CHECKREMOTE cannot decode status\n";
        exit $JABORT;
    }
    return $count;
}

sub getconnection {
    my ($remote,$port) = @_;
    my ($socket);
    print STDERR "XX CHECK_REMOTE remote='$remote', port=$port\n" if $debug;
    $socket = IO::Socket::INET->new(
        Proto => "tcp",
        PeerAddr => $remote,
        PeerPort => $port,
        );
    if( !$socket ){
        print STDERR "CHECK_REMOTE IO::Socket::INET failed - $!\n";
        exit $JABORT;
    }
    $socket->autoflush(1);
    $socket;
}
\end{verbatim}


The example of the previous section can be modified now
so that it uses the {\ttfamily check\_idle} facility.
The master queue will send jobs only to the server queue queues
which report idle status.
\begin{verbatim}
laser1|pi1|Room 1359 LaserWriter #1
    :server:check_idle=/usr/local/lib/filters/remote_check pr@laser1
    :lp=laser1%9100
    :tc=@commonlaser
laser2|pi2|Room 1359 LaserWriter #2
    :server:check_idle=/usr/local/lib/filters/remote_check pr@laser1
    :lp=laser2%9100
    :tc=@commonlaser
\end{verbatim}



\subsubsection{Using a router filter}

A router filter allows you to re-route jobs in a dynamic way. For
details, see
{\ttfamily \ref{routing} {(routing)}.}

Lars Anderson $<${\ttfamily lsa@business.auc.dk}$>$ supplied this example
(slightly edited):

This script will attempt to distribute print jobs evenly on
2 printers hpl5a and hpl5b when sending to hpl5bounce.

\begin{verbatim}
hpl5bounce|for PLP/LPRng software - network based HP Jetdirect card:
        :lf=log.hpl5
        :lpr_bounce
        :lp=hpl5b@localhost
        :router=/usr/local/admscripts/bouncer.pl
hpl5a|for PLP/LPRng software - network based HP Jetdirect card:
        :af=acc.hpl5a:
        :lp=hpl5a%9100:sd=/var/spool/lpd/hpl5a:
        :lf=log.hpl5a:
        :tc=@hplcommon
hpl5b|for PLP/LPRng software - network based HP Jetdirect card:
        :af=acc.hpl5b:
        :lp=hpl5b%9100:sd=/var/spool/lpd/hpl5b:
        :lf=log.hpl5b:
        :tc=@hplcommon
# Common settings
@hplcommon:
        :rw:sh:ps=status:
        :fx=flp:
        :if=/usr/local/lib/filters/ifhp -Tbanner=on
        :of=/usr/local/lib/filters/ofhp -Tbanner=on
\end{verbatim}


The perl script {\ttfamily bouncer.pl} looks like this:

\begin{verbatim}
#!/usr/bin/perl
#
# Script for printjob loadsharing
#
#                                 29/5-97 Lars Anderson
#
# Printqueues to check
$printer1="hpl5a\@localhost";
$printer2="hpl5b\@localhost";
# obtain number of jobs in each printqueue
$lpq1=`/usr/local/bin/lpq -s -P$printer1`;
$lpq2=`/usr/local/bin/lpq -s -P$printer2`;
$lpq1=~ (/(\d+) jobs?/); $numjobs1=$1;
$lpq2=~ (/(\d+) jobs?/); $numjobs2=$1;
if ($numjobs1 == 0) {
    print "dest $printer1\nCA\nend\n";
    exit;
}
if ($numjobs1 > $numjobs2) {
    print "dest $printer2\nCA\nend\n";
    exit;
}
print "dest $printer1\nCA\nend\n"; 
\end{verbatim}

\label{lpdprintcappath}
\label{printcappath}
\label{nw}
\label{details}


\subsection{The Missing Details}

Options used:
\begin{itemize}
\item  {\ttfamily printcap\_path=}{\itshape printcap file locations\/}
\item  {\ttfamily lpd\_printcap\_path=}{\itshape additional server printcap file locations\/}
\item  {\ttfamily nw}{\itshape ~~NFS spool directory\/}
\end{itemize}


The LPRng software uses a greatly simplified set of printcap conventions.
This section discusses the details of the printcap database. LPRng can
use vintage (i.e.- Berkeley LPR) format printcap files; use the checkpc
program to make sure they are totally compatible with LPRng (see checkpc
man page, README.install, DOC/Intro).

The client programs (LPR, LPRM, LPQ, LPC) do not need access to a printcap
database, but will use it if available. The -Pprinter@host option or PRINTER
environment variable specifies the printer and LPD host; the LPD server
does all of the various spool queue activities. The client programs send
requests and/or jobs to the LDP server which carries out all activity.
If no printcap is available and the host is not specified, a default host
value is provided.

If a printcap database is desired, then it is obtained as follows. First,
the
{\ttfamily printcap\_path }
and
{\ttfamily  lpd\_printcap\_path }
configuration information (see
\ref{lpdconf} {(lpd.conf(5))}) specifies where client and server programs find printcap
information.
The client programs use printcap\_path; lpd uses both printcap\_path
and lpd\_printcap\_path. All files are read and the printcap entries are
extracted in order from the files. Later printcap information overrides
previous information in the files.

The common defaults for the printcap locations are:
\begin{verbatim}
printcap_path      /etc/printcap:/usr/etc/printcap:\
                       /var/spool/lpd/printcap.HOSTNAME
lpd_printcap_path /etc/lpd_printcap:/usr/etc/lpd_printcap
\end{verbatim}


When the {\ttfamily lpd} server gets a printcap entry,
if the printcap entry obtained has a spool directory and the
spool directory has a {\ttfamily printcap} file in it,
then this file is assumed to contain additional printcap information,
and the server will read and append this information to the obtained
printcap information.
The {\ttfamily nw} (NFS mounted or network file system) flag
will suppress this operation,  as there is a security loophole
when obtaining information from an NFS mounted system.

The most common method of printcap information distribution is to have
a master printcap file shared or distributed to all system. This usually
has only the printer name and lpd host specified in the printcap entries,
as shown below.
\begin{verbatim}
    ----- /etc/printcap on clients and server ------- 
    #parallel attached DUMB printer
    pr1|dumb
        :lp=pr1@taco.astart.com
    # server information
    pr2|postscript
        :lp=pr2@taco.astart.com
    pr3|laserjet
        :lp=pr3@taco.astart.com
    @common|common code for printers
        :if=/bin/filter
        :of=/bin/filter
    @morecommon|show the configuration expansion
        :sd=/var/spool/lpd/%P
        
    realpr:tc=@common:tc=@morecommon
\end{verbatim}


A careful study of the above example will discover the following features
of the LPRng printcap structure.
\begin{enumerate}
\item Lines ending with a $\backslash$ indicate continuation to the next line.
In practice,  the $\backslash$ is replaced with space(s) when line joining is done.
\item Blank lines and lines whose first nonwhitespace character
is a \# are ignored, except if it follows a continuation line.
(Which makes sense.)
\item All leading and trailing whitespace on a line are removed.
\item A printcap entry consists of a name, 0 or more aliases, and data entries.\\ 
- name starts with an alphabetic character; dummy entries can start \_, @ or .\\ 
- alias starts with a $|$ followed by the alias\\ 
- fields or data entry starts with : followed by the entry
\item Field or data entry\\ 
name - main or cannonical name for printcap entry\\ 
$|$name - alias name for printcap entry\\ 
:key   - set the key to ON  (1)\\ 
:key@  - set the key to OFF (0)\\ 
:key\#nnn - set the key to nnn, where nnn follows C language conventions\\ 
:key=string - set the key to the string value to end of line
\item Printcap entries whose cannonical name starts with \_, @, or . (period)
(eg.- {\ttfamily @name})
are treated like dummy
entries.  They can be referenced with :tc=entry:,  but will
be ignored otherwise.
\item The {\ttfamily tc=f1:tc=f2:...} acts similar to a file inclusion
operator,
but substitutes printcap entries.
The specified tc entries are logically append to the end of
the current printcap entry,
and the appended information will override the previous information.
Note that you can
have multiple :tc: entries.
\item key=value.\%X\\ 
a selected set of
\%X values are expanded when the printcap entry is used by
the client or server program.
The following values are expanded:\\ 
P - printcap cannonical or main name\\ 
H - Fully Qualified Domain Name for host\\ 
h - short name for host\\ 
R - Fully Qualified Domain Name for remote host host\\ 
r - short name for remote host host
\item The
{\ttfamily oh} entry specifies that a particular printcap entry
can only be used by a host with a matching host name or IP address.
See
\ref{secoh} {(Master Printcap Files)} for details.
\item The
{\ttfamily server} entry specifies that a particular printcap entry
can only be used by the lpd server,
and is ignored by other programs.
See
\ref{secserver} {(Shared Printcap Files)} for details.
\end{enumerate}


Printcap information is extracted in order from the printcap files,
and later information for printcap entries overrides earlier ones.

The
{\ttfamily \%X} substitution is especially useful when most of the
information for a set of printers is common or identical.
This can be placed in a printcap entry and referenced with the
{\ttfamily tc} operator.
As shown in the example,
by making the spool directory name depend on the cannonical printcap name,
it simplifies management of the printer.


\subsubsection{Spool (Control) Directory Printcap File}

You can put a printcap file in a spool queue directory. This file is
only consulted by the LPD server when performing operations on a spool
queue. It allows you to put information particular to a spool queue in
well controlled location.

The
{\ttfamily server}
tag and
{\ttfamily oh}
options have rendered this facility obsolete,
and it may be removed in later releases.


\subsubsection{Separate Printcap Files for LPD}

Since only the LPD server uses the
{\ttfamily /etc/lpd\_printcap}
or
{\ttfamily /usr/etc/lpd\_printcap}
file,
you can place server specific information there.
This allows you to have a common printcap file for clients and an
additional one for the lpd servers.
You may have to modify the lpd.conf file
{\ttfamily lpd\_printcap\_path}
entry to specify the desired file.

The
{\ttfamily server}
and
{\ttfamily oh} options have rendered this
facility obsolete and it may be removed
in future releases of LPRng.


\subsubsection{Printcap Entry all}

The 'all' printcap entry is reserved to provide a list of all printers
available for use by the spooling software. This was intended to be used
with systems that did not have ways to provide a wildcard search of the
printcap database. The 'all' printcap entry has the form:
\begin{verbatim}
all:all=pr1,pr2,...
\end{verbatim}


The LPRng software will use the individual entries of
the printer list and request additional printcap information if necessary.


\subsubsection{More Example Printcap Entries}

The following printcap entries show the formats,  and have
some additional comments about fields in the printcap file.
\begin{verbatim}
#
#  NOTE:
#  Use the lpf filter (supplied with LPRng) or the of and if filter.
#  Banners will be printed using the lpbanner
#  program, supplied with LPRng.  You can also create your own banner
#  program and specify it as the banner printer (printcap :bp: entry.)
#  Put -$ at the start of a filter or program specification to suppress
#  additional command line options. (see lpd.conf).
#  Note: some PC's LPR packages use the v format instead of the l or f format
#
# This is the VINTAGE form of printcap,  with trailing \ to extend information
# to next line.  Note the -$ to suppress adding options to command line
# typical dump printer, no banner, parallel port
pr1|dumb- no banner:\
    :sh:lp=/dev/lpr1:sd=/usr/spool/lpd/pr1:\
    :fx=flpv:\
    :af=acct:lf=log:\
    :if=/usr/local/bin/lpf:\
    :vf=-$ /bin/cat
# dumb with banner - note that lprng will use the default banner program
#  /usr/local/bin/lpbanner to generate full banner
# Note: we use the standard LPRng printcap format
pr1b|dumb- banner
    :lp=/dev/lpr1:sd=/usr/spool/lpd/pr1        #<- sh deleted
    :fx=flpv
    :af=acct:lf=log
    :of=/usr/local/bin/lpf
    :if=/usr/local/bin/lpf
    :vf=/usr/local/bin/lpf -c
# common printer information:
# we define a @common entry
@filter|printcap filter information
    :of=/usr/local/bin/lpf
    :if=/usr/local/bin/lpf
    :vf=/usr/local/bin/lpf -c
# dumb with user banner - bp specifies banner printer
#  If we wanted the banner at the END of the job, we would use
#  :hl: (header last) flag.
#  We can also have headers at start and end, using the
#  be={banner printer} and bs={banner printer} overrides
#  Note: -$ suppresses adding command line options
pr1b|dumb- user supplied banner
    :lp=/dev/lpr1:sd=/usr/spool/lpd/pr1
    :fx=flpv
    :af=acct:lf=log
    :bp=/usr/local/lib/my_banner_printer
    :tc=@filter
#serial attached PostScript printer
# Note that fields can have terminating colons (:)
# You can put comments into this printcap with this form
# Note that the of filter does accounting
pr2|postscript - no banner
    :rw:sh:lp=/dev/ttya:sd=/usr/spool/lpd/pr2
    :sy=9600 -raw -parenb cs8 crtscts
    :af=acct:lf=log:ps=status
    # only allow the following formats
    :fx=flpv
    # filters
    :tc=@filter
#serial attached PostScript printer with psof created banner
pr2|postscript - psof will expand short banner
    # Note: sb is short banner format
    # psof filter recognizes this and produces a fancy banner
    # from the input
    :rw:sb:lp=/dev/ttya:sd=/usr/spool/lpd/pr2
    :sy=9600 -echo -crmod -raw -oddp -evenp pass8 cbreak ixon
    :af=acct:lf=log:ps=status
    # only allow the following formats
    :fx=flpv
    # filters
    :tc=@filter
#serial attached PostScript printer with user created banner
pr2|postscript - psof will expand short banner
    # Note: sb is short banner format
    # psof filter recognizes this and produces a fancy banner
    # from the input
    :rw:sb:lp=/dev/ttya:sd=/usr/spool/lpd/pr2
    :sy=9600 -echo -crmod -raw -oddp -evenp pass8 cbreak ixon
    :af=acct:lf=log:ps=status
    # only allow the following formats
    :fx=flpv
    # filters
    :tc=@filter
# parallel attached Laser Jet
# Note that fields do not need terminating colons
#
pr3|laserjet
    :rw:sh:lp=/dev/lp:sd=/usr/spool/lpd/pr3
    :af=acct:lf=log:ps=status
    # only allow the following formats
    :fx=flpv
    #filters
    :if=/usr/local/lib/CTI-Print/bin/ifhp -Tstatus=off
    :of=/usr/local/lib/CTI-Print/bin/ofhp -Tstatus=off
    :vf=/usr/local/lib/CTI-Print/bin/ifhp -c -Tstatus=off
# printcap file for pr4
# PostScript via JetDirect card, IP address pr4, port 9100.
# Note: some PC's LPR packages use the v format for their jobs
#
pr4|network
    :rw:sh:lp=pr3%9100:sd=/usr/spool/lpd/pr4
    :af=acct: :lf=log: :ps=status
    # only allow the following formats
    :fx=flpv
    #filters
    :if=/usr/local/lib/CTI-Print/bin/ifhp
    :of=/usr/local/lib/CTI-Print/bin/ofhp
    :vf=/usr/local/lib/CTI-Print/bin/ifhp -c
\end{verbatim}



\subsubsection{PC-NFS Print Spooler}

If you are using PC-NFS to do print spooling,  then you have several
security loopholes exposed.  You must modify the permissions on the
spool directory to allow other users to access it and place jobs into
the directory.  Printcap and other control information by default is
placed in the spool directory, and can be easily modified by malicious
users.  To reduce this risk, the :cd: (control directory) entry is used
to specify a directory to hold sensitive control information. For example
\begin{verbatim}
#/etc/lpd_printcap
# PCNFS Spooler
#
pr7
    :lp=pr7@printserver
    :bq=pr1@printserver
    :sd=/usr/spool/pcnfs/pr7
    :cd=/usr/spool/lpd/pr7
\end{verbatim}


This printcap entry will implement a simple 'bounce queue',  in which
jobs are stored temporarily and then transferred to another spool queue,
and is the recommended way to support PC-NFS printing.


\subsection{Management Strategy for Large Sites}

One very effective way to organize print spooling is to have a small
number or print servers running a
{\ttfamily lpd} daemon,
and to have all the other systems send their jobs directly to them.
By using the above methods of specifying the printer and server host
you eliminate the need for more complex management strategies.

However,
you still need to inform users of the names and existence of these printers,
and how to contact them.
One method is to use a common
{\ttfamily /etc/printcap}
file which is periodically updated and transfered to all sites.
Another method is to distribute the information using the
NIS or some other database.
LPRng has provided a very flexible method of obtaining and distributing
database information:  see
\ref{secnis} {(Using Programs To Get Printcap Information)}
for details.
\label{secnis}


\subsection{Using Programs To Get Printcap Information}

In the
lpd.conf
file you can specify:
\begin{verbatim}
printcap_path=|program
\end{verbatim}

This will cause the LPRng software to execute the specified program,
which should then provide the printcap information.
The program is invoked with the standard filter options,
and has the name of the printcap entry provided on
{\ttfamily STDIN}.
The filter
should supply the printcap information on
{\ttfamily stdout}
and exit with a 0
(success) error code.  By convention,  the printcap name 'all'
requests a printcap entry that lists all printers.

This technique has been used to interface to the Sun Microsystem NIS
and NIS+ databases with great success.
By having the invoked program a simple shell script or front end to the
{\ttfamily nismatch} or {\ttfamily ypmatch} programs,
the complexity of incorporating vendor specific code is avoided.


\subsubsection{How to use NIS and LPRng}

This note is based on material sent to the
{\ttfamily lprng@iona.ie}
mailing list by
Paul Haldane
{\ttfamily $<$paul@ucs.ed.ac.uk{$>$}}.

\begin{verbatim}
 # From: Paul Haldane <paul@ucs.ed.ac.uk>
 # To: lprng@iona.ie
 # Subject: Re: Problem using plp with NIS
 # Sender: majordomo-owner@iona.ie
 # Precedence: bulk
 # Reply-To: lprng@iona.ie
 # Status: RO
 # 
\end{verbatim}


We generally don't use NIS for printcap files (we've
moved to hesiod) but I can show you what we've done in the past.

The input to NIS is a normal printcap file:
\begin{verbatim}
# Classical printcap entry
lp23a|lp23|lp|main printhost printer - KB, EUCS front Door:\
        :lp=lp23a@printhost:\
        :sd=/usr/spool/lpr/lp23a:
 
#lprng printcap entry
lplabel|lpl|TEST - Labels printer:
        :lp=:rm=printhost:rp=lplabel:
        :sd=/usr/spool/lpr/lplabel:
        :rg=lpadm:mx#1:
\end{verbatim}


To build the NIS printcap.byname map we add the following to
the NIS makefile (along the other bits and pieces that the makefile
needs to know about a new map).
\begin{verbatim}
PRINTCAP=$(DIR)/printcap
#PRINTCAP=/etc/printcap
# warning : [  ] is actualy [<space><tab>] in the script
printcap.time: $(PRINTCAP) Makefile
  if [ -f $(PRINTCAP) ]; then \
    sed < $(PRINTCAP) \
      -e 's/[   ][  ]*$$//' -e '/\\$$/s/\\$$/ /' \
    | awk '$$1 ~ /^#/{next;} $$1 ~ /^[:|]/ {printf "%s", $$0; next;} \
        {printf "\n%s", $$0 }' \
    | sed -e 's/[   ]*:[  ]*:/:/g' -e 's/[  ]*|[  ]*/|/g' \
      -e '/^[   ]*$$/d' > .printcap.$$$$; \
    cat .printcap.$$$$; \
    if [ $$? = 0 -a -s .printcap.$$$$ ]; then \
      awk <.printcap.$$$$ '{ FS=":"; OFS="\t"; } { \
          n = split($$1, names, "|"); \
          for (i=1; i<=n; i++) \
              if (length(names[i]) > 0 \
              && names[i] !~ /[ \t]/) \
                  print names[i], $$0; \
      }' | $(MAKEDBM) - $(YPDBDIR)/$(DOM)/printcap.byname; \
      awk <.printcap.$$$$ '{ FS=":"; OFS="\t"; } { \
          n = split($$1, names, "|"); \
          if (n && length(names[1]) > 0 && names[1] !~ /[ \t]/) \
              print names[1], $$0; \
      }' | $(MAKEDBM) - $(YPDBDIR)/$(DOM)/printcap.bykey; \
      rm -f .printcap.$$$$; \
      touch printcap.time; echo "updated printcap"; \
    fi \
  fi
  @if [ ! $(NOPUSH) -a -f $(PRINTCAP) ]; then \
      $(YPPUSH) printcap.byname; \
      $(YPPUSH) printcap.bykey; \
      touch printcap.time; echo "pushed printcap"; \
  fi
\end{verbatim}


To specify that you want YP database rather than file access,
use the following entry in your {\ttfamily /etc/lpd.conf} file:
\begin{verbatim}
printcap_path |/usr/local/lib/pcfilter
\end{verbatim}


Put the following shell script in /usr/local/lib/pcfilter
\begin{verbatim}
#!/bin/sh
#/usr/local/lib/pcfilter
read key
ypmatch "$key" printcap.byname
\end{verbatim}





\subsubsection{How to use NIS and LPRng - Sven Rudolph}

\begin{verbatim}
 Date: Wed, 11 Sep 1996 00:11:02 +0200
 From: Sven Rudolph <sr1@os.inf.tu-dresden.de>
 To: lprng@iona.ie
 Subject: Using :oh=server: with NIS
\end{verbatim}


When I use a cluster-wide printcap,
two entries for each printer will appear, e. g.:
\begin{verbatim}
---------- start of /etc/printcap snippet
lp1
 :lp=lp1@server
lp2
 :lp=lp2@server
lp1
 :server:oh=servername
 :sd=/var/spool/lpd/lp1
 :lp=/dev/lp1
 :sh:mx#0
---------- end of /etc/printcap snippet
\end{verbatim}


When I create a NIS map out of this,
the printer name is used as a key
and must be unique. So NIS' makedbm decides to drop all but the last
entry for each printer. This makes the printer on the clients
unavailable.
I solved this by a hack where the second entry is called lp1.server
and the NIS client script has to request the right entry.
\begin{enumerate}
\item Assumptions
Perl is available at the YP server in /usr/bin/perl .
A Bourne Shell is available at all clients in /bin/sh
The printcap that is to be exported is in /etc/printcap .
The printcap is written in the new format.

In the examples the printer is called lp1 .

\item Add the following to your YP Makefile (/var/yp/Makefile) on the YP
server :
\begin{verbatim}
---------- start of /var/yp/Makefile snippet
PRINTCAP  = /etc/printcap
printcap: $(PRINTCAP)
    @echo "Updating $@..."
    $(CAT) $(PRINTCAP) | \
        /usr/lib/yp/normalize_printcap | $(DBLOAD) -i $(PRINTCAP) \
        -o $(YPMAPDIR)/$@ - $@
    @if [ ! $(NOPUSH) ]; then $(YPPUSH) -d $(DOMAIN) $@; fi
    @if [ ! $(NOPUSH) ]; then echo "Pushed $@ map." ; fi
---------- end of /var/yp/Makefile snippet
\end{verbatim}

(These lines are for Debian GNU/Linux, other systems might require
other modifications)

\item Install the programs {\ttfamily match\_printcap}
and {\ttfamily normalize\_printcap} to {\ttfamily /usr/lib/yp}.
normalize\_printcap
is only required on the YP server.
The {\ttfamily normalize\_printcap} processes only the LPRng printcap format.
\begin{verbatim}
---------- start of /usr/lib/yp/normalize_printcap
#! /usr/bin/perl
$debug = 0;
$line = "";
$new = "";
while (<>) {
    chomp;
    next if ( /^\s*\#.*/ );
    s/^\s*$//;
    next if ( $_ eq '' );
    print "new: " . $_ . "\n" if $debug;;
    if (/^\s/) { # continuation line
        $line = $line.$_;
        print "continued: $line\n" if $debug;
        next;
    } else {
        $line =~ s/\s+\:/:/g;
        $line =~ s/\:\s+/:/g;
        $line =~ s/\:\s*\:/:/g;
        print "line: $line\n" if $debug;
        push(@lines, $line) if $line;
        $line = $_;
    }
}
$line =~ s/\s+\:/:/g;
$line =~ s/\:\s+/:/g;
$line =~ s/\:\s*\:/:/g;
push(@lines,$line) if $line;
@lines = sort(@lines);
foreach $line (@lines) {
    ($printers) = split(/\:/,$line);
    @printers = split(/\|/,$printers);
    foreach $printer (@printers) {
      $num{$printer}++;
      push(@allprinters,$printer);
      print "allprinters: @allprinters\n" if $debug;
      print $printer."_".$num{$printer}."\t$line\n";
    }
}
@pr = keys %num;
print "printers @pr\n" if $debug;
if ($#allprinters >=0) {
    print "all_1\tall:all=".join(",",@pr)."\n";
}
---------- end of /usr/lib/yp/normalize_printcap
\end{verbatim}

The result of processing the sample printcap file is:
\begin{verbatim}
lp1_1 lp1:lp=lp1@server
lp1_2 lp1:server:oh=servername:sd=/var/spool/lpd/lp1:lp=/dev/lp1:sh:mx#0
lp2_1 lp2:lp=lp2@server
all_1 all:all=lp1,lp2
\end{verbatim}


Observe that each of the real printer entries has a key consisting of the
printer name with a numerical suffix.
This leads to the following method of extracting the printcap information
using {\ttfamily ypmatch}:
\begin{verbatim}
---------- start of /usr/lib/yp/match_printcap
#!/bin/sh
read p
n=1
while ypmatch "${p}_${n}" printcap 2>/dev/null; do
    n=`expr $n + 1`
done
---------- end of /usr/lib/yp/match_printcap
\end{verbatim}


\item Now test the YP arrangement:
\begin{verbatim}
$ cd /var/yp; make # this should create the printcap map
$ ypcat printcap # should provide the whole normalized printcap
$ echo lp1 |/usr/lib/yp/match_printcap # yields lp1 printcap
\end{verbatim}
\item Add the printcap\_path entry to {\ttfamily /etc/lpd.conf}:
\begin{verbatim}
printcap_path=|/usr/lib/yp/match_printcap
\end{verbatim}
\item Test the use of the printcap path entry:
\begin{verbatim}
$ lpq -Plp1 # shows the status of lp1
\end{verbatim}
\item Restart the lpd server and check to see that it accesses
the right printcap information.
Use the same {\ttfamily lpq} command,
and then try {\ttfamily lpc printcap lp1}.
\end{enumerate}

\label{qq}
\label{usequeuename}
\label{forcequeuename}


\subsection{The Record Queue Name qq and force\_queuename flags}

Options used:
\begin{itemize}
\item  {\ttfamily qq}{\itshape ~~Insert queue name into control file\/}
\item  {\ttfamily use\_queuename}{\itshape ~~(alias for qq)\/}
\item  {\ttfamily force\_queuename=}{\itshape ~Queuename to be used\/}
\end{itemize}


The printcap information consists of the printer name and aliases;
when a job is spooled to a printer alias,
it is actualy spooled to the main printer entry.

The
{\ttfamily qq}
use queuename option or its
alias
{\ttfamily use\_queuename}
tells
LPRng to record the queue name that a job was queued to,
and make it available to other software for processing.
The
{\ttfamily force\_queuename=...}
entry forces this name to be used.
This capability has some interesting possibilities,
as shown below.
\begin{verbatim}
pr1_landscape|pr1_portrait|pr_raw:lp=pr@host:qq
\end{verbatim}


If a job is printed using
{\ttfamily lpr -Ppr1\_landscape},
then
{\ttfamily pr1\_landscape}  will be recorded as the spool queue name
by the LPRng software.

Later,
when the job is processed by a filter,
the filter will be invoked with a
{\ttfamily -Qpr1\_landscape}
command line option.
The filter can use the name of the queue to enable say,
landscape,
portrait,
or raw
orientations.
\begin{verbatim}
john|tom|frank:lp=pr@host:force_queuename=office
\end{verbatim}


This printcap entry forces the queuename to be {\ttfamily office};
this information could be used by a central routing facility to
process the information is a suitable manner.
\label{checkfornonprintable}
\label{ml}
\label{xt}


\subsection{Using the check\_for\_nonprintable Flag}

Options used:
\begin{itemize}
\item  {\ttfamily check\_for\_nonprintable}{\itshape ~~LPR checks for non-printable file \/}
\item  {\ttfamily ml\#}{\itshape ~~minimum number of printable characters \/}
\item  {\ttfamily xt}{\itshape ~~(alias for check\_for\_nonprintable)\/}
\end{itemize}


Normally, {\ttfamily lpr}
checks an {\ttfamily f} format file
for non-printable characters (i.e., escape characters) at the start
of the print file.
Disabling this check allows you to print executable files,
etc., which can cause extreme abuse of your printer.

Disabling can be done on a single printcap basis,
or you can do this on a global basis by modifying the
configuration information (see
\ref{lpdconf} {(lpd.conf)}).

The {\ttfamily ml} value specifies the number of characters that
are to be checked.
Clearly,  if it is 0, none will be checked.
\label{fd}


\subsection{The fd Forwarding Off Option}

Options used:
\begin{itemize}
\item  {\ttfamily fd}{\itshape ~~Forwarding off\/}
\end{itemize}


When the {\ttfamily fx} option is on (default is OFF),
then the {\ttfamily lpd} server will not accept jobs whose host name
in the control file is not the same as one of the hostnames for the
host which originates the connection.

This was a wimpy attempt to prevent job spoofing.
\label{rg}


\subsection{The rg Restrict Use to Group Members Option}

Options used:
\begin{itemize}
\item  {\ttfamily rg=}{\itshape Restricted group list\/}
\end{itemize}


The {\ttfamily rg} value specifies a list of groups.
If this value is present,
then use of a printer or operation is restricted to only users in a
particular group.

This was a wimpy attempt to do restrictions on print facilities.
The -Ppr@host option overrides this check,
unless the {\ttfamily rg} value is put in the LPRng defaults.

However,
it does provide a simple tool to have clients do some form of permissions
checking that only the {\ttfamily lpd} server could normally do.
\label{fx}


\subsection{The fx Allowed Formats Option}

Options used:
\begin{itemize}
\item  {\ttfamily fx=}{\itshape supported formats for printing\/}
\end{itemize}


The {\ttfamily fx} option specifies which formats are supported by
a spool queue.
The {\ttfamily lpr} program uses these to check if a requested format
is supported.
The default formats are
{\ttfamily fx=flp},  i.e. - the default (normal), binary,
and {\ttfamily pr} formats.

If the {\ttfamily lpr -Fx} option is used,
the allowed formats are not checked.


\subsection{Fixing Bad Control Files and Metacharacters}

RFC1179 defines a simple protocol and standard for print jobs to be
interchanged between print spooling systems.
Unfortunately,
there were some major mistakes in not specifying the exact form
that text would take when placed in the control file.

In addition,
there are some simple coding errors that have been made,
but due to their wide distribution in major vendors software,
need to be accommodated.
See
\ref{reverselpqformat} {(reverse\_lpq\_format)}
for an example.
\label{safechars}
\label{fixbadjob}


\subsubsection{Defective RFC1179 Implementations}

Options used:
\begin{itemize}
\item  {\ttfamily fix\_bad\_job}{\itshape ~~fix bad job\/}
\item  {\ttfamily safe\_chars=}{\itshape additional safe characters for control file \/}
\end{itemize}


Most printer (or print server box) manufacturer totally ignore the
details of the RFC1179 protocol,
and simply accept the data files for printing,
and disregard the control file {\bfseries until they need to print a banner
or provide status information}.

At this point,  you suddenly discover that all sorts of little details
will cause horrible problems.
For example,
the use of non-ASCII characters (i.e. - values are 128-255) in the
J (job) line of a control file has been known to crash one network
interface card in such a manner that a power-up is needed to restart
the printer.

Also,
as an exercise for the reader,
here is another little gem.
If you send one particular RFC1179 compatible print spooler a
control file with a character whose value is 255 (i.e. 0xFF),
the job will never get printed,
and there is a mysterious diagnostic on the console:
\begin{verbatim}
unexpected end of input
\end{verbatim}


This is due to the fact that the 0xFF eight bit value is getting sign
extended to a 16 bit value 0xFFFF,
which just turns out to be -1, or the error indication from a read.


\subsubsection{Serious Security Loophole}

Finally,
there is the subtle and nasty problem with some print filters
that are not
{\itshape meta-char-escape\/} proof.
For example,
suppose that a user decided to spool a job as follows:
\begin{verbatim}
lpr '-J; rm -rf /*;' /tmp/a
\end{verbatim}


This would create a job file with the line:
\begin{verbatim}
J `rm /etc/passwd; echo Job;`
\end{verbatim}


The job would get printed on a printer with the following printcap:
\begin{verbatim}
pr:sd=/...
  :if=/usr/local/hack
\end{verbatim}


And of course we have {\ttfamily /usr/local/hack} (yes,
this is a BAD example, so we won't start pointing out all the things):
\begin{verbatim}
#!/bin/sh
while [ -n "$1" ] ; do
        case "$1" in
        -J  )  shift; args="$args -M$1";;
        esac;
        shift;
done;
# reformat the command line
eval /usr/local/realfilter $args
\end{verbatim}


The observant reader will notice that the above line gets expanded to:
\begin{verbatim}
eval /usr/local/realfilter -M`rm /etc/passwd; echo Job;`
\end{verbatim}


The interesting thing to observe is that the {\ttfamily realfilter}
will probably execute correctly,
while the password file will magically vanish.


\subsubsection{Using the fix\_bad\_job Option}

Several microprocessor operating systems have decided to use
{\itshape extended fonts\/} for information in the control file.
Needless to say,  while this is obnoxious,  it is not serious.
However,
it will cause problems when trying to print messages on consoles,
etc.

In order to prevent such problems,
LPRng ruthlessly purges all characters but
upper and lower case letters,
spaces, tabs, and {\ttfamily -\_.@/:()=,+-\%} from the control file,
replacing suspicious characters with '\_'.

However desirable it may to detect when
such obnoxious behavior is taking place,
it is usually more desirable to replace suspicious characters with safe
ones and proceed with processing the job.
If the
{\ttfamily fix\_bad\_job} configuration or printcap option is 0 (false)
then when a suspicious character is spotted the job processing is aborted.
If it is 1 (true),
then the characters are silently purged and job processing continues.

For some installations,
the default set of safe characters may be overly restrictive.
For example,
{\itshape vintage\/} software may generate files with {\ttfamily \#} characters
in the {\ttfamily J} line of the control file.
The replacement of this character may cause other things to stop
working.

The {\ttfamily safe\_chars} option allows the user to specify an additional
set of safe characters in the {\ttfamily lpd.conf} configuration files.
For example, {\ttfamily safe\_chars=\#"} would allow the
{\ttfamily \#}
and
{\ttfamily "}
characters to appear in the control file.
\label{bk}
\label{controlfilterbk}


\subsubsection{Using the bk Option and Control File Filters}

Options:
\begin{itemize}
\item  {\ttfamily bk}{\itshape ~~Berkeley compatible control file\/}
\item  {\ttfamily control\_filter=}{\itshape Control file filter\/}
\end{itemize}


One of the more serious problems is when a print spooler (LPR) program
does not generate print jobs in a manner compatible with a remote system.

While LPRng performs checks for improper implementations of RFC1179,
it will try to accept a job,
even under the most severe abuse of the protocol.
However,
other spoolers are not so forgiving.

Some spoolers require that the contents of the control file
be in {\bfseries exactly} the order that the original 1988 BSD LPR software
generated them.
While some entries can be missing,
all the entries present in the file must be in an explicit order.

The {\ttfamily bk} (Berkeley LPD compatible control file) option
causes LPR and LPD to reformat the control file,
removing objectionable entries.
The control file of a job being sent to
a remote printer to have its control file entries restricted to
letters in (and the same order) as  HPJCLIMWT1234.

However,
there are some very odd commercial implementations that require
{\itshape more\/} information than is present.
To assist with this,
the {\ttfamily control\_filter} option can be used.
This specifies a program that will process the control file
before it is sent to a remote destination.
See
\ref{secfilter} {(Filters)} for details on filter
operation,
and
\ref{controlfilter} {(Control Filters)} for more information.

The {\ttfamily control\_filter} program is run with the standard set of filter options.
STDIN is attached (read/write) to the control file and the filter STDOUT will be used as the control file value
sent to the remote host.

The
{\ttfamily control\_filter}
can rewrite the control file,
modify and the names and formats of the data files,
or perform other changes.
Here is a small snip of PERL code that shows how to
rewrite the control file:
\begin{verbatim}
# you need to get PERL to do a 'dup' call on FD 0
$status = 0;
@cf_lines = <STDIN>;
# mess about with the control file
foreach $line (@cf_lines) {
   # or whatever you want
   print STDOUT $line;
} 
exit $status;
\end{verbatim}


The exit code of the
{\ttfamily control\_filter}
is used to determine whether to proceed in processing.
See
\ref{errorcodes} {(Errorcodes)} for details.

Also, see
\ref{controlfilter} {(Control Filters)} for more information.
\label{mc}
\label{sc}


\subsection{Maximum Copies}

Options used:
\begin{itemize}
\item  {\ttfamily mc\#}{\itshape maximum copies \/}
\item  {\ttfamily sc}{\itshape ~~maximum copies \/}
\end{itemize}


The {\ttfamily  mc} value specifies the maximum number of
copies of a job that can be printed on a printer using the
{\ttfamily lpr -Knn } or
{\ttfamily lpr -\#nn } option.

The {\ttfamily sc} cause LPR to reject requests to print multiple
copies of a file.
\label{mi}
\label{minfree}


\subsection{The mi Minimum Spool Queue Space Option}

Options used:
\begin{itemize}
\item  {\ttfamily mi\#}{\itshape minimum spool queue space (Kbytes) \/}
\item  {\ttfamily minfree\#}{\itshape alias for mi\/}
\end{itemize}


If this value is non-zero,
then the {\ttfamily lpd} server checks to see that there is the
specified number of bytes of file space available before transferring a job.
\label{db}
\label{fulltime}
\label{mstimeresolution}
\label{syslogdevice}
\label{usedate}
\label{useinfocache}


\subsection{Debugging}

Options used:
\begin{itemize}
\item  {\ttfamily debugging=}{\itshape debugging options\/}
\item  {\ttfamily full\_time}{\itshape ~~full or extended time format\/}
\item  {\ttfamily ms\_time\_resolution}{\itshape ~~millisecond time resolution\/}
\item  {\ttfamily syslog\_device=}{\itshape syslog alternative device\/}
\item  {\ttfamily use\_date}{\itshape ~~put date information in control file\/}
\item  {\ttfamily use\_info\_cache}{\itshape ~~cache printcap and other information\/}
\end{itemize}


The LPRng software has a very powerful debugging capability.
Since most printing problems occur on remote systems where it is impossible
to run debuggers,  and since most systems do not do core dumps of SETUID ROOT
programs,
the LPRng software provides a very verbose set of log file trace messages.

First,
serious errors or other information are logged using the
{\itshape syslog()\/} facilities.
If these are not present on a system,
then the messages are logged to the device specified by
{\ttfamily syslog\_device}.

For client programs, the debugging options are specified on the command
line and output is directed to STDERR.
For the {\ttfamily lpd} server,
debugging commands can be specified on the command line OR as the
{\ttfamily db=options} printcap value.
Output is directed to the log file ({\ttfamily lf} option value, default log).

A typical debug entry has the format {\ttfamily 2,network+1,database}.
This sets the general
debugging level to 2, network debugging to 1 and the database debugging level
to the default.  The following debugging options and levels are supported.
\begin{itemize}
\item nnn - general purpose debugging level
\item network - network debugging
\item database - database debugging
\item receive - job or command reception debugging
\item print - detailed job printing debugging
\end{itemize}


The {\ttfamily full\_time} flag forces the logging and other information
which has timestamps to have a full (year, month, day, etc.) timestamp.
The
{\ttfamily ms\_time\_resolution} flag forces millisecond time resolution
in the time stamp.
The
{\ttfamily use\_date} flag forces a date value to be placed in a control file
if there is none.

The {\ttfamily use\_info\_cache} (default ON) causes {\ttfamily lpd}
to cache printcap and configuration information.
This is desirable except when trying to change values in printcap files and
test the results.
By using {\ttfamily use\_info\_cache@} in the configuration information,
you can get immediate responses.
Also, see
\ref{lpcreread} {( {$<$}tt{$>$}lpc reread{$<$}/tt{$>$})}
for another method.
\label{ipv6}
\label{lockfile}
\label{logfile}
\label{spooldirperms}
\label{spoolfileperms}
\label{spreadjobs}


\subsection{LPD Specific}

Options used:
\begin{itemize}
\item  {\ttfamily ipv6}{\itshape ~~use IPV6 Network facilities \/}
\item  {\ttfamily lockfile=}{\itshape lpd server lock file\/}
\item  {\ttfamily logfile=}{\itshape lpd server log file\/}
\item  {\ttfamily spool\_dir\_perms\#}{\itshape spool directory permissions \/}
\item  {\ttfamily spool\_file\_perms\#}{\itshape spool file permissions \/}
\item  {\ttfamily spread\_jobs\#}{\itshape job number spread\/}
\end{itemize}


These options are usually LPD specific.
For example,
the {\ttfamily ipv6} specifies that the IPV6 protocol,
rather than IPV4 will be used.
In future versions,  this may not be necessary.

The {\ttfamily lockfile} and {\ttfamily logfile} specify the location of the
lock file and the log file used by the {\ttfamily lpd} server.

The {\ttfamily spool\_dir\_perms} and {\ttfamily spool\_file\_perms}
(default 0700 and 0600 respectively)
values are the (numeric) permissions for the spool directory and
spool files.

The {\ttfamily spread\_jobs} option is obsolete.
The {\ttfamily  spread\_jobs} option was a desperation fix to handle
difficulties with the arrival of a large number of jobs with the same or
close job number.  The LPD server would fork children,
each of whom tried to lock the job files.  The spread value randomly
chose a new number in the range about the original job number.
However,
it is still preserved for legacy systems which still have problems with
file locking.


\subsection{Legacy Compatibility}

The following arguments have been provided for compatibility with
legacy systems.
\label{allowduplicateargs}


\subsubsection{The allow\_duplicate\_args Option}

Options used:
\begin{itemize}
\item  {\ttfamily allow\_duplicate\_args}{\itshape ~~allow lpr to have duplicate arguments \/}
\end{itemize}


Some users would like LPR's and LPRM's arguments to be 'cumlative', i.e. -
{\ttfamily lpr -a x -a y }  should be identical to
{\ttfamily lpr -a x}

The {\ttfamily allow\_duplicate\_args} option
allows the various client programs to have duplicate arguments.
The last specified argument on the command line will override
previous values.
\label{classnamelength}
\label{breakclassnameprioritylink}


\subsubsection{The break\_classname\_priority\_link Option}

Options used:
\begin{itemize}
\item  {\ttfamily break\_classname\_priority\_link}{\itshape ~~classname and priority can differ\/}
\item  {\ttfamily classname\_length\#}{\itshape ~~maximum length of classname in control file \/}
\end{itemize}


By default the class name and the job priority are identical.  The
{\ttfamily  break\_classname\_priority\_link }
flag breaks this link, and the class can be
specified separately from the priority.

Also, the maximum classname
size specified by RFC1179 is 32 characters;  the
{\ttfamily classname\_length\#nnn}
(default 31) allows a longer classname (up to 127 characters) to be used.
\label{reverselpqformat}


\subsubsection{The reverse\_lpq\_format Option}

Options used:
\begin{itemize}
\item  {\ttfamily reverse\_lpq\_format=}{\itshape ~reverse LPQ status format for specified remote systems\/}
\end{itemize}


Various Solaris and other System V implementations support an RFC1179 interface
to remote printers.
Unfortunately,  there is a problem in that when they send a status request,
the status format is reversed.
That is,
when LONG status format is wanted,
they send SHORT,
and vice versa.

The {\ttfamily reverse\_lpq\_format=} specifies a list of printers or IP addresses
for which the {\ttfamily lpd} server will return LONG status when SHORT is
requested,
and vice versa.
For example:
\begin{verbatim}
reverse_lpq_format=*.eng.com,130.192.0.0/16
\end{verbatim}


will cause hosts whose Fully Qualified Domain Name (FQDN) ends in
{\ttfamily eng.com} or from subnet {\ttfamily 130.192.0.0} to have reversed
status returned.
\label{shortstatuslength}
\label{returnshortstatus}


\subsubsection{The return\_short\_status and short\_status\_length Options}

Options used:
\begin{itemize}
\item  {\ttfamily return\_short\_status=}{\itshape ~return short LPQ status for specified remote systems\/}
\item  {\ttfamily short\_status\_length\#}{\itshape ~short LPQ status length in lines\/}
\end{itemize}


In order to be compatible with non-LPRng printers,
some administrators would like {\ttfamily lpd} to return a short or brief
status to normal status queries.

The {\ttfamily return\_short\_status=} specifies a list of printers or IP addresses
for which the {\ttfamily lpd} server will return an abbreviated
status when LONG status is requested.
For example:
\begin{verbatim}
return_short_status=*.eng.com,130.192.0.0/16
short_status_length#3
\end{verbatim}


will cause hosts whose Fully Qualified Domain Name (FQDN) ends in
{\ttfamily eng.com} or from subnet {\ttfamily 130.192.0.0} to get only
3 lines of detailed status returned.
\label{co}


\subsection{Unused Legacy Printcap Options}

Options used:
\begin{itemize}
\item {\ttfamily co}{\itshape Cost - passed to filters.\/}
\end{itemize}


The above options are retained only for
compatibility with legacy filter operation.
See
\ref{filtercmd} {(Filter Command Line Flags)}
for details.


\subsection{Compatibility with BSD printcap}

If you previously had a BSD-style printer spooler, you might be lucky:
your printcap will be directly usable by LPRng in many cases,
i.e. - LPRng is almost totally backwards compatible with the old BSD printcaps.
However, a lot of people have found out the hard way
that LPRng is not completely compatible with BSD LPR.

For example,
the {\ttfamily fc/fs/xc/xs} fields,
with were used to set serial line configuration,
are no longer supported.
The flag bits and their meanings are totally implementation dependent,
and highly unportable.
Most UNIX systems now have use a stty compliant
{\ttfamily ty} or {\ttfamily sy} entry. Both options
are synonyms, and the value is a set of {\bfseries stty(1)} commands.
See
\ref{secconvert} {(Converting BSD fc,fs,xc,xs To LPRng sy)}
for details.

There are other items,
such as the fact that the keywords used by LPRng can be variable length,
not just two letters,
and other
commenting and formatting conventions
which are not supported by the older BSD servers.
\label{secfilter}


\section{Filters}

This section gives an overview of how LPRng uses filter programs,
and gives a detailed discussion of how the printcap options and
filters interact.


\subsection{What are filters?}

Print filters are one of the most powerful tools in BSD-style printer
systems.

In general UNIX terms, a filter is a program that takes its input
file(s), does something with it, and sends the result to its standard
output. Most UNIX utilities are designed as filters.
(But since you are a system manager, you should already know that :))

In the context of a BSD-style print spooler (and also LPRng), the term
`filter' refers to a program that does processing on a file that is
submitted to the printer. As such, it is a specific example of the
general class of programs called `filters'.

Usually the
filter is executed with STDIN reading from the file to be
printed
or program generating the output and STDOUT to the printer device.
STDERR (file handle 2) is redirected to a log file,
and file handle~3 to an accounting file.

A filter can be as simple as a {\ttfamily LF} to {\ttfamily CR/LF}
translator (the example used before),
or it can incorporate a complete
accounting system, automatic file type translations,
or even redirect the job to another printing system.

As part of the LPRng project,
the following filters are supported.
See the associated documentation for details.
\begin{itemize}
\item  Distributed in the LPRng source distribution\\ 
\ref{lpf} {( {$<$}tt{$>$}lpf{$<$}/tt{$>$})}
a very simple CR/LF or passthrough filter.
\item  Distributed in the FILTERS\_LPRng distribution:\\ 
\ref{ifhp} {(CTI-ifhp {$<$}tt{$>$}ifhp{$<$}/tt{$>$})}
HP PCL and PJL printer filters
\item \ref{psfilter} {(psfilter {$<$}tt{$>$}psif{$<$}/tt{$>$})}
PostScript printer filter
\end{itemize}

The supported filters and other facilities are available from
\url{ftp://ftp.astart.com/pub/LPRng}
\label{if}


\subsection{What are print formats?}

Options used:
\begin{itemize}
\item {\ttfamily if},
{\ttfamily cf},
{\ttfamily df},
{\ttfamily gf},
{\ttfamily nf},
{\ttfamily of},
{\ttfamily rf},
{\ttfamily tf},
{\ttfamily vf},
{\itshape X\/}{\ttfamily f},
{\itshape ~~Filter programs \/}
\end{itemize}


LPRng has inherited a set of so-called `{\bfseries print formats}' from its
BSD ancestor.
The format was originally used
to specify the type of file that was being printed,
and the
{\ttfamily lpd }
would use the print format to select the required
filter for processing the file.
The
de{\ttfamily f}ault format is
{\ttfamily f}.

The user can specify the format (i.e., the file type) by giving
the appropriate option to {\ttfamily lpr}:

\begin{itemize}
\item {\ttfamily -b} or {\ttfamily -l}: Binary (literal) file. No processing should
be done.
The
{\ttfamily l} format is recorded as the file format.
\item {\ttfamily -c}: cifplot(1) output.
\item {\ttfamily -d}: TeX DVI file.
\item {\ttfamily -g}: Output from the plot(3X) routines.
\item {\ttfamily -n} or {\ttfamily -t}: (di)troff output.
\item {\ttfamily -p}: Text file that should be pre-processed by the {\ttfamily pr}
command, and then by the standard text filter.
\item {\ttfamily -r}: Text with FORTRAN carriage control characters in the
first column. (Used to be the {\ttfamily -f} option.)
\item {\ttfamily -v}: Benson Varian raster image.
\end{itemize}


Alternatively, one can also use
{\ttfamily -Fx}, where {\ttfamily x} is the format specifier.
(E.g., {\ttfamily -Fc}
instead of {\ttfamily -c}.)
This last form also allows you to use other
(non-standard) format specifiers.

The filter for format
{\ttfamily X}
is the value for the
{\ttfamily Xf} printcap
option,
with some minor exceptions.
The following
{\ttfamily Xf}
options have a pre-defined meaning.

\begin{itemize}
\item {\ttfamily if}
The {\ttfamily f}
format filter,
i.e. - for the default
{\ttfamily f}
format.
All print jobs are passed
through this one, unless another format is selected.
\item \label{cf}
{\ttfamily cf} Cifplot data filter (for {\ttfamily -c} format).
\item \label{df}
{\ttfamily df} Filter for DVI files ({\ttfamily -d}).
\item \label{gf}
{\ttfamily gf} Graph data filter ({\ttfamily -g}).
\item \label{nf}
{\ttfamily nf} Ditroff data filter ({\ttfamily -n}).
\item {\ttfamily of} This filter is used for processing the (optional)
banner at the start and/or end of the print job,
and also for the interjob separators.
See
\ref{ofdetails} {(of)} filter for details.
\item \label{rf}
{\ttfamily rf} Filter for Fortran style files ({\ttfamily -r}).
\item \label{tf}
{\ttfamily tf} Troff filter ({\ttfamily -t}).
\item \label{vf}
{\ttfamily vf} (Versatek) raster image filter ({\ttfamily -v}).
\end{itemize}

\label{ofdetails}


\subsection{OF Filter}

The
{\ttfamily of}
filter is used to process banners and job separators.
The
{\ttfamily of} filter is responsible for performing appropriate
processing of this information and sending to the printer
for action.

While the various file filters are invoked on a once per per print file basis,
the
{\ttfamily of}
filter is invoked on a once per print job basis.

This filter is the first one to be started,
and should perform whatever specialized device initialization
is needed.
It should also do whatever accounting procedure is desired
for start of job accounting.

The
{\ttfamily of}
filter will be given any banner printing or job separation
information for a job.
As part of its operation,
it can detect a specific string,
corresponding to a banner print request,
and generate a banner.
(See the
\ref{jobsteps} {(Job Processing Steps and Printcap Options)}
for details.)

During operation,
the
{\ttfamily lpd} server will send the special
{\bfseries stop} sequence of {\ttfamily $\backslash$031$\backslash$001} to the
{\ttfamily of} filter.
The filter must then suspend itself using a
{\ttfamily kill -STOP} operation.
The {\ttfamily lpd} server will detect that the
{\ttfamily of} filter has suspended itself and then
will perform other printing operations.

After the other printing operations have been completed,
the {\ttfamily of} will then be sent a
{\ttfamily kill -CONT} signal.

This sequence will continue until all information has been printed,
and then the of filter's STDIN will be closed.
The filter will then perform whatever cleanup operations are needed,
update accounting or other information,
and exit.
\label{pr}


\subsection{The lpr -p  format and pr option}

Options used:
\begin{itemize}
\item {\ttfamily pr=}{\itshape pr program for p format\/}
\end{itemize}


The {\ttfamily -p} format is implemented by sending the file through
the program
specified by the {\ttfamily pr}
printcap utility (default is {\ttfamily /bin/pr}),
and passing the result to the normal
{\ttfamily :if} filter.


\subsection{The lpr -l  format and binary format}

The binary (or literal) format
is indicated by format type
{\ttfamily -l}.
The {\ttfamily :if} filter.
is used to process the file,
and is invoked with the
{\ttfamily -c}
({\ttfamily c}ancel processing?) flag.
\label{jobsteps}


\subsection{Job Processing and Printcap Options}

Much of the flexibility of the LPRng software is obtained
from the ability to control the details of each step of job processing.
The following section details each step in the processing of a job,
and explains the printcap options used to control each operation.

Assume the {\ttfamily pr}
printcap entry has the form:
\begin{verbatim}
pr
    :lp=/dev/lp  OR  :lp=rp@rm
    :sd=/var/spool/lpd/pr
    :lf=log
    :of=/usr/local/bin/lpf
    :if=/usr/local/bin/lpf
\end{verbatim}


Assume that we have used the following command to print
a set of files.
\begin{verbatim}
lpr -Ppr file1 file2
\end{verbatim}


This will create a control file
in the
{\ttfamily /var/spool/lpd/pr}
directory with the following contents (this is an example -
in practice there may be minor differences between the example
and an actual control file):
\begin{verbatim}
Hastart4.astart.com
J/tmp/file1 /tmp/file2
CA
Lpapowell
Ppapowell
fdfA002230astart4.astart.com
N/tmp/file1
UdfA002230astart4.astart.com
fdfB002230astart4.astart.com
N/tmp/file2
UdfB002230astart4.astart.com
\end{verbatim}


\label{achk}
\label{af}
\label{as}
\label{ff}
\label{fo}
\label{lk}
\label{lpdev}
\label{la}
\label{ar}
\label{ld}
\label{rw}
\label{connectgrace}
\label{networkconnectgrace}
\label{connectinterval}
\label{connecttimeout}
\label{connecttry}
\label{controlfilter}
\label{nb}
\label{servertmpdir}


\subsubsection{Opening Output Device}

Options used:
\begin{itemize}
\item  {\ttfamily achk}{\itshape ~~Accounting check at start\/}
\item  {\ttfamily af=}{\itshape Accounting File\/}
\item  {\ttfamily ar}{\itshape ~~Remote printer accounting enabled\/}
\item  {\ttfamily as=}{\itshape Accounting at start\/}
\item  {\ttfamily connect\_grace\#}{\itshape ~~Time between jobs\/}
\item  {\ttfamily connect\_interval\#}{\itshape ~~Connection interval\/}
\item  {\ttfamily connect\_timeout\#}{\itshape ~~Connection timeout\/}
\item  {\ttfamily control\_filter=}{\itshape Control file filter\/}
\item  {\ttfamily ff}{\itshape ~~form feed\/}
\item  {\ttfamily fo}{\itshape ~~form feed on open\/}
\item  {\ttfamily la}{\itshape ~~Local printer accounting enabled\/}
\item  {\ttfamily ld=}{\itshape leader on open (initialization string)\/}
\item  {\ttfamily lk}{\itshape ~~Lock IO device\/}
\item  {\ttfamily lp=}{\itshape IO device pathname\/}
\item  {\ttfamily nb}{\itshape ~~Nonblocking device open\/}
\item  {\ttfamily network\_connect\_grace\#}{\itshape ~~Time between jobs\/}
\item  {\ttfamily of=}{\itshape of filter\/}
\item  {\ttfamily retry\_econnrefused\#}{\itshape ~~Retry if open failed\/}
\item  {\ttfamily retry\_nolink\#}{\itshape ~~Retry if open failed\/}
\item  {\ttfamily rw}{\itshape ~~device opened RW flag\/}
\item  {\ttfamily server\_tmp\_dir=}{\itshape temporary directory\/}
\end{itemize}

Sequence of Operations:
\begin{enumerate}
\item During the server operations,
it will try to create temporary files in the print queue spool directory.
If this is not desirable,
it will create them in the {\ttfamily server\_tmp\_dir} directory.
\item If the accounting file specified by
{\ttfamily af}
exists,
it is opened (af\_fd) and the af\_fd is passed as file descriptor
3 to all filters.
If the {\ttfamily af} value has the form {\ttfamily af=$|$/program}
then the program is started and the program STDIN is used as af\_fd.
If the {\ttfamily af} value has the form {\ttfamily af=host\%port},
then a TCP/IP connection to the corresponding port on the remote host
is made and the port used as af\_fd.
In the latter two cases,  the filter STDIN (file descriptor 0)
is actualy opened read/write, and is used when information is needed
from the accounting filter or remote server.
See
\ref{accountingserver} {(Accounting Printcap Options)}
for more information on the LPRng accounting support.
\item If the
{\ttfamily connect\_grace}
value is non-zero and the server is opening a device or
{\ttfamily network\_connect\_grace} is non-zero and a network connection
is being made,
the server will pause the specified time.
This is to accommodate devices which need a recovery time between jobs.
\item The {\ttfamily lp} option is checked to determine the type of IO device.
\begin{table}[tbp]
\begin{center}
\begin{tabular}{{$|$}l{$|$}l{$|$}}
Format& Meaning\\ 
{\ttfamily /pathname}& Absolute pathname of IO device\\ 
{\ttfamily pr@host}& transfer to {\ttfamily pr} on remote {\ttfamily host}\\ 
{\ttfamily host\%port}& open a TCP/IP connection to port on host. host can be name or IP address\\ 
{\ttfamily $|$filter}& run the filter program; it STDIN will be used as device\\ 
\end{tabular}
\end{center}
\end{table}
\item The IO device specified by
{\ttfamily lp} is opened write-only or read-write if the
{\ttfamily rw}
flag is true, and the resulting file descriptor is io\_fd.
If the {\ttfamily nb} flag is set,
a non-blocking open will be done as well.
If the {\ttfamily lk} (lock device) flag is true,
the device will be locked against use by other LPD servers.
\item If a {\ttfamily host\%port} combination,
a TCP/IP connection will be opened to the remote port and the connection will
be used as io\_fd.
\item If a filter program is specified,
the filter program will be run and the STDIN of the filter will be
used as the device file descriptor.
\item If a {\ttfamily rp@rm} combination,
or none of the above combinations are true and the
{\ttfamily rm} and {\ttfamily rp} values are non-zero,
then the job will be transferred to a remote printer.
The type of operation will be a job transfer,
rather than printing operation.
\item If the {\ttfamily connect\_timeout} value is non-zero,
a timeout is setup for the device or socket open.
If the device or connection open does not succeed within the timeout,
then the open operation fails.
\item If a connection is to a network address
(i.e. - {\ttfamily connect()} system call)
and the connection attempt fails with an {\ttfamily ECONNREFUSED}
error,
if the {\ttfamily retry\_econnrefused}
flag is set then the connection attempt is retried,
but this time using an alternative port number.
See
\ref{rfc1179ref} {(RFC1179)} for details.
This is repeated until all of the possible originating port numbers
are exhausted.
\item If the open or connect operation fails,
and the {\ttfamily retry\_nolink} flag is set,
then the server will pause for a minimum of
{\ttfamily connect\_grace} plus a multiple of
{\ttfamily connect\_interval} seconds
based on the number of attempts
before retrying the open operation.
Note that the interval may increase as the number of attempts
increases.
\item If printing a job and the
{\ttfamily of} filter is specified,
it is created with its STDOUT (fd 1) attached to the io\_fd.
Its stdin (of\_fd) will be used in the steps listed below.
If there is no
{\ttfamily of} filter,
then the of\_fd value will be the io\_fd descriptor.
\item If transferring a job and the {\ttfamily control\_filter} option is specified,
then the program specified by the {\ttfamily control\_filter}
value will be run. It will have its STDIN set to the control file,
and its STDOUT output will be used as the new value of the control file
to transfer to the remote host.
See
\ref{filtercmd} {(Filter Command Line Flags)}
for details of options passed to the control filter,
and
\ref{errorcodes} {(errorcodes)} for the exit codes of the filter.
\item \label{accountstart}
If {\ttfamily la} (local accounting) is true and we are printing a job
or {\ttfamily ar} (remote accounting) is true and we are transferring a job,
the {\ttfamily as} value is examined.
If it is a filter (program) specification,
then the program is started with its STDIN attached to
{\ttfamily /dev/null} and STDOUT to the io\_fd,
STDERR to the error file,
and file descriptor 3 to the accounting file descriptor af\_fd.
The lpd program will wait until it terminates,
and examine the error code for action, as for the filters
(see
\ref{errorcodes} {(errorcodes)} below).
If it is a string,
then it is interpreted, the escape sequences replaced with the appropriate
information,  and written to the accounting file.
\item If the {\ttfamily achk} (accounting check) flag is set,
then the a line is read from the accounting filter af\_fd file descriptor.
This line should be {\ttfamily accept},
otherwise the job processing terminates with a JFAIL indication.
\item If the operation is a job transfer,
then the operation proceeds as outlined in
\ref{rfc1179ref} {(RFC1179)},
and then the
\ref{normalterm} {(Normal Termination)} operations are
carried out.
\item If the operation is a print operation,
and the
{\ttfamily ld} (leader on open) value is provided,
the string
is translated (escapes removed)
and written to the of\_fd file descriptor.
\item If the
{\ttfamily fo} (form feed on open) flag is true, then the
{\ttfamily ff} (form feed) string
is translated (escapes removed)
and written to the of\_fd file descriptor.
\end{enumerate}

\label{ab}
\label{hl}
\label{be}
\label{bl}
\label{bp}
\label{bs}
\label{sb}
\label{sh}
\label{of}
\label{bannerprinting}


\subsubsection{Printing Banner At Beginning}

Options used:
\begin{itemize}
\item  {\ttfamily ab}{\itshape ~~Always print banner (default FALSE)\/}
\item  {\ttfamily be=}{\itshape End banner generator program\/}
\item  {\ttfamily bl=}{\itshape Short banner line format\/}
\item  {\ttfamily bp=}{\itshape Banner generator program\/}
\item  {\ttfamily bs=}{\itshape Start banner generator\/}
\item  {\ttfamily hl}{\itshape ~~Banner (header) Last\/}
\item  {\ttfamily of=}{\itshape Banner and File Separator Filter\/}
\item  {\ttfamily sb}{\itshape ~~Short banner (default FALSE)\/}
\item  {\ttfamily sh}{\itshape ~~Suppress header (banners) (default FALSE)\/}
\end{itemize}

Sequence of Operations:
\begin{enumerate}
\item If the
{\ttfamily sh} (suppress header) flag is true, no banner is
printed,
and the actions in this section are skipped.
\item If the {\ttfamily hl} flag is true, the banner is printed at the end
of the job,
and the actions in this section are skipped.
\item If the user does not supply a banner name,
(the {\ttfamily L} line in the control file)
and
{\ttfamily ab} (always print a banner) is false
(the default),
then no banner is printed.
If no name is supplied and
{\ttfamily ab} is true, then ANONYMOUS is used.
\item There are two types of banners - short and long.
If the
{\ttfamily sb} flag is set, then we send the
{\ttfamily bl}
(banner line) contents directly to the of\_fd;
By default the
{\ttfamily bl} value is:
{\ttfamily bl=\$-'C:\$-'n Job: \$-'J Date: \$-'t}
(See
\ref{filtercmd} {(Filter Command Line Flags)}
for details.)
This will get translated to:\\ 
{\ttfamily papowell:A Job: file1 file2 Date: Thu Nov 27 23:02:04 PST 1997}
\item If the
{\ttfamily sb} flag is clear,
we will generate a long banner using a program instead.
If
{\ttfamily bs} (start banner) program is specified, then it is used
to generate a banner,
otherwise if the
{\ttfamily bp} (banner) program is specified, then it is used
to generate a banner.
If no program is available, we skip the banner generation.
The banner generator program is started with the normal command line
flags
(see
\ref{filtercmd} {(Filter Command Line Flags)}),
with its STDOUT attached to the of\_fd descriptor.
The short banner string described in the previous step is written
to the STDIN.
The banner printer is responsible for generating a banner
appropriate to the printing device.
\item The
{\ttfamily ff} (form feed) string
will be interpreted and sent to the of\_fd.
\end{enumerate}

\label{directread}
\label{sendjobrwtimeout}
\label{sendqueryrwtimeout}
\label{sf}
\label{format}


\subsubsection{Printing Job Files}

Options used:
\begin{itemize}
\item  {\ttfamily Xf=}{\itshape Format Filter\/}
\item  {\ttfamily direct\_read}{\itshape ~~Direct connection to file\/}
\item  {\ttfamily if=}{\itshape Default F Format Filter\/}
\item  {\ttfamily pr=}{\itshape pr formatting program\/}
\item  {\ttfamily send\_job\_rw\_timeout=}{\itshape  print job read/write timeout \/}
\item  {\ttfamily send\_query\_rw\_timeout=}{\itshape  status query operation read/write timeout \/}
\item  {\ttfamily sf}{\itshape ~~Suppress FF Print File Separators\/}
\end{itemize}


Sequence of Operations:
for each job in listed in the control file,
the following operations are done in turn.
\begin{enumerate}
\item If there is an {\ttfamily of} filter present,
the suspend string {\ttfamily $\backslash$031$\backslash$001} is written to of\_fd
and the no further action is taken until the of filter is suspended.
\item The control file line for the job is examined,
and the first letter of the data file specification is used as the format.
\item If the format is
{\ttfamily p},
the job is first processed by the program specified by the
{\ttfamily pr}
program,
and the program output used as the print file.
\item If the format is
{\ttfamily f},
{\ttfamily l},
or
{\ttfamily p}
then the {\ttfamily if} filter is used,
otherwise the keyword
{\ttfamily Xf} is used.
Note that certain formats such as
{\ttfamily p, a, l}, may not be used as formats.
\item The
{\ttfamily direct\_read}
flag determines how the print file is provided
to the filter.
Normally, the {\ttfamily lpd} writes the file to the filter process,
and can monitor the printing activity in this way.
However,
some filters require a direct connection in order to
do {\ttfamily lseek} or other operations on the file.
If the
{\ttfamily direct\_read}
flag is true,
then the print file is opened and passed directly to the filter
process,
otherwise the {\ttfamily lpd} program will read the file
and write its contents to the filter.
\item The filter program is started with an appropriate set of command line options
(see
\ref{filtercmd} {(Filter Command Line Flags)}),
and with its STDOUT attached to the printing device (io\_fd),
STDERR to the log file ({\ttfamily lf}),
and file descriptor 3 to the accounting fd af\_fd.
If {\ttfamily direct\_read} is false,
the file is then written to the STDIN of the filter.
This allows the server to monitor job progress.
\item When doing a read/write operation to a device or remote system,
a timeout can be specified.
When doing a print or job transfer operation,
the {\ttfamily send\_job\_rw\_timeout} value is used.
When doing a status or query operation,
the {\ttfamily send\_query\_rw\_timeout} value is used.
If a write or write operation does not complete within
the specified timeout seconds, then we have an error
condition and job processing or the query operation
is terminated with JFAIL status.
If the timeout value is 0, then no timeout is done.
\item \label{errorcodes}
{\ttfamily lpd} will then wait for the filter to exit.
The exit status can be as follows:
\begin{verbatim}
Key      Value   Meaning
JSUCC    0       Successful
JFAIL    1, 32   Failed - retry later
JABORT   2, 33   Abort - terminate queue processing
JREMOVE  3, 34   Failed - remove job
JHOLD    6, 37   Failed - hold this job
Other            Abort - terminate queue processing
\end{verbatim}
\item If the filter exit status was JSUCC (0), or no error indicated,
then processing will continue otherwise the job termination takes
(see
\ref{termination} {(Abnormal Termination)}).
\item If the {\ttfamily of} filter is present,
then it is reactivated with a {\ttfamily kill -CONT} signal.
\item If the {\ttfamily sf} (suppress FF print file separators ) is false,
then the
{\ttfamily ff} (form feed) string
will be interpreted and sent to the of\_fd.
\end{enumerate}



\subsubsection{Printing Banner At End}

Options used:
\begin{itemize}
\item  {\ttfamily hl}{\itshape ~~Header (Banner) Last\/}
\end{itemize}


The actions taken in this step are identical to those for the
\ref{bp} {(Printing Banner At Beginning)},
with the exception that the
{\ttfamily be} (end banner program) is used in the procedure
rather than the
{\ttfamily bs} (start banner program).
\label{ae}
\label{fq}
\label{savewhendone}
\label{tr}
\label{normalterm}


\subsubsection{Normal Termination}

Options used:
\begin{itemize}
\item  {\ttfamily fq}{\itshape ~~Form Feed on Close\/}
\item  {\ttfamily la}{\itshape ~~Form Feed on Close\/}
\item  {\ttfamily tr=}{\itshape Trailer on Close\/}
\item  {\ttfamily ae=}{\itshape Accounting at end\/}
\item  {\ttfamily save\_when\_done}{\itshape ~~Save when done\/}
\end{itemize}


Sequence of Operations:
\begin{enumerate}
\item If we are printing and the the {\ttfamily fq} flag is set and the
{\ttfamily sf} (suppress interfile FF) flag is set,
then the
{\ttfamily ff} (form feed) string
will be interpreted and sent to the of\_fd.
\item If we are printing, the {\ttfamily tr} (trailer) string
will be interpreted and sent to the of\_fd.
\item If printing and the {\ttfamily la} (local printer accounting) flag is set
or transferring a job and the {\ttfamily ar} (remote accounting) flag is set,
the
{\ttfamily ae} is examined and accounting is done as described
for the
{\ttfamily \ref{accountstart} {(as)} field.}
\item If the {\ttfamily of} filter is present,
its STDIN is closed,
and the {\ttfamily lpd} server waits for it to exit.
The exit status is used as described above.
\item The device (io\_fd) is closed.
\item The job is marked as completed in the spool queue.
\item If the {\ttfamily save\_when\_done} flag is not specified,
the job is removed.
\end{enumerate}

\label{rt}
\label{saveonerror}
\label{sendtry}
\label{sendfailureaction}
\label{mailoperatoronerror}
\label{sendmail}
\label{stoponabort}
\label{maxconnectinterval}
\label{termination}


\subsubsection{Abnormal Termination}

Options used:
\begin{itemize}
\item  {\ttfamily mail\_operator\_on\_error=}{\itshape Mail to operator on error\/}
\item  {\ttfamily rt\#}{\itshape ~~Maximum Print or Transfer Attempts\/}
\item  {\ttfamily send\_try\#}{\itshape ~~(alias for {\ttfamily rt}\/}
\item  {\ttfamily save\_on\_error}{\itshape ~~Do not delete on error\/}
\item  {\ttfamily send\_failure\_action=}{\itshape Action on Failure\/}
\item  {\ttfamily sendmail=}{\itshape sendmail path name and options\/}
\item  {\ttfamily stop\_on\_abort}{\itshape ~~Stop processing queue on filter abort\/}
\end{itemize}


If the job processing terminates abnormally,
the following sequence of events occurs:
\begin{enumerate}
\item The job is marked as having an error during processing.
\item The LPD server will attempt to kill all filters and other associated process
by using a sequence of
{\ttfamily kill -INT}
{\ttfamily kill -QUIT},
and finally
{\ttfamily kill -KILL} operations.
\item If there is a {\ttfamily mail\_operator\_on\_error} value,
the specified operator will be mailed an error indication.
The {\ttfamily sendmail} option specifies the pathname of the
{\itshape sendmail\/} program and the options needed to have it read
mail addresses from its standard input.
For example, {\ttfamily sendmail=/usr/sbin/sendmail -oi -t}
is a commonly used set of options.
\item If there is a {\ttfamily send\_failure\_action} specified,
then it is decoded and the corresponding action taken.
If the value is
{\ttfamily remove},
{\ttfamily hold},
{\ttfamily abort},
or
{\ttfamily retry},
then the job is removed, held, aborted, or retried.
If the value is {\ttfamily $|$/program},
the program is executed and
the number of attempts are written to the filter STDIN.
The exit status of the filter will be used to determine the consequent actions.
That is, JSUCC (0) will be success, and the standard success action will
be taken;
JFAIL will cause retry,
JREMOVE will cause the job to be removed,
JHOLD will cause the job to be held,
JABORT or other status will abort processing.
\item If the status is ABORT and the
{\ttfamily stop\_on\_abort}
flag is set,
then further processing of jobs is terminated.
The job is not removed from the queue.
\item If the error status indicates removal,
and the {\ttfamily save\_on\_error} flag is clear
then the job is removed from the spool queue.
\item If the error status indicates that no further operations should
be performed on the queue,
then the {\ttfamily lpd} server will stop processing jobs.
\item If the error code indicated that the job should be retried,
and the
{\ttfamily rt} value is 0 or the number of attempts is less than
the {\ttfamily rt} value,
then the job is retried.
Between each attempt to transfer a job to a remote site.
This pause will double after each attempt,
reaching a maximum of max\_connect\_interval seconds.
If max\_connect\_interval is 0, there is no limit on the interval value.
\end{enumerate}

\label{lpdforcepoll}
\label{lpdpolltime}
\label{maxserversactive}


\subsubsection{LPD Spool Queue Processing}

Options used:
\begin{itemize}
\item  {\ttfamily lpd\_force\_poll=}{\itshape Force LPD to periodically poll print queues \/}
\item  {\ttfamily lpd\_poll\_time\#}{\itshape Time between polls\/}
\item  {\ttfamily max\_servers\_active\#}{\itshape Maximum number of active servers\/}
\end{itemize}


When the {\ttfamily lpd} server starts,
it will fork a set of subserver processes,
each which will handle an individual queue.

If a system has a large number of queues,
then this forking operation may result in the {\ttfamily lpd} server
exhausting the process resources.
To control this,  the
{\ttfamily max\_servers\_active} value restricts the number of active
children to the specified value.
If this value is 0,
then 50\% of the maximum system processes value will be used.

Due to the limits on the number of processes,
there may be times when a job is placed in a queue,
but the {\ttfamily lpd} server is unable to start handling the job.
When all of the children of the main {\ttfamily lpd} server have
exited,
the server starts a timer.
After {\ttfamily lpd\_poll\_time} seconds,  it will scan the queues,
looking for jobs to process,
and starts a process to service them.
If it does not find any jobs it remains idle.

The {\ttfamily lpd\_force\_poll} flag causes the server to periodically
poll the queues.
This is useful when there is a high possibility that jobs could fail to be
printed due to high loads on the server.
\label{bkfilteroptions}
\label{bkoffilteroptions}
\label{bkf}
\label{filteroptions}
\label{offilteroptions}
\label{filterldpath}
\label{filterpath}
\label{passenv}
\label{pl}
\label{pw}
\label{px}
\label{py}
\label{filtercmd}


\subsection{Filter Command Line Flags}

Options used:
\begin{itemize}
\item  {\ttfamily bk\_filter\_options=}{\itshape Backwards Compatible Filter options\/}
\item  {\ttfamily bk\_of\_filter\_options=}{\itshape Backwards Compatible OF Filter options\/}
\item  {\ttfamily bkf}{\itshape ~~Backwards Compatible Filters\/}
\item  {\ttfamily filter\_ld\_path=}{\itshape Filter LD\_LIBRARY\_PATH environment\/}
\item  {\ttfamily filter\_options=}{\itshape Filter options\/}
\item  {\ttfamily filter\_path=}{\itshape Filter PATH environment\/}
\item  {\ttfamily of\_filter\_options=}{\itshape OF Filter options\/}
\item  {\ttfamily pass\_env=}{\itshape Environment variables to copy to Filter environment\/}
\item  {\ttfamily pl\#}{\itshape line count for page\/}
\item  {\ttfamily pw\#}{\itshape column count for page\/}
\item  {\ttfamily px\#}{\itshape pixel width for page\/}
\item  {\ttfamily py\#}{\itshape pixel length for page\/}
\end{itemize}


A filter (or program) specification in the LPRng printcap database
usually has the form:
\begin{verbatim}
:option=| [flags] /path [arguments]
:option=[flags] /path [arguments]
\end{verbatim}


The first case is used where the option value can be a string or filter,
and the second where a program is always expected.
The following procedure is used to run a filter program.

The sequence of operations to run a filter is as follows:
\begin{enumerate}
\item The program must be specified with an absolute path name.
\item By default,
the program is run as either the user,
if invoked from a client
program such as lpr, lpc, etc.
If invoked from {\ttfamily lpd},  it is run as the
{\ttfamily server\_user}
user
(default {\ttfamily daemon}) configuration entry.
\item The
{\itshape flags\/} control how the program is to be run.
The following flags are supported:
\begin{itemize}
\item {\bfseries ROOT}
This opens a horrible security loophole,
as it will run the program as ROOT.
To enable this option,
you must set various compilation flags,
and perform other arcane operations.
This is deliberately done to make administrators
read the warnings and admonitions.
The alternative to ROOT is to have a setuid ROOT executable.
Under NO circumstances should you run a shell script setuid ROOT,
with general execute permissions on it.

\item {\bfseries -\$}
This very odd looking flag is used to suppress the addition of
additional command line arguments
specified by the value of {\ttfamily filter\_options}
to the program command line.
\end{itemize}
\item If the {\bfseries -\$} flag is not specified,
the arguments determined by the value of the {\ttfamily bkf}
(Berkeley LPD filter compatible flag) flag are added to the
filter command line.
If {\ttfamily bkf} is false, then the
{\ttfamily filter\_options} are added for OF filters and
{\ttfamily of\_filter\_options}
are added for non-OF filters;
if it is true, then the
{\ttfamily bk\_filter\_options} and {\ttfamily bk\_of\_filter\_options} are added for
OF and non-OF filters respectively.
\begin{table}[tbp]
\begin{center}
\begin{tabular}{{$|$}l{$|$}l{$|$}}
Option& DefaultValue\\ 
{\ttfamily filter\_options}& \$C \$F \$H \$J \$L \$P \$Q \$R \$Z \$a \$c \$d \$e \$f \$h \$i \$j \$k \$l \$n \$p\$r \$s \$w \$x \$y \$-a\\ 
{\ttfamily of\_filter\_options}& (same as {\ttfamily filter\_options})\\ 
{\ttfamily bk\_filter\_options}& \$P \$w \$l \$x \$y \$F \$c \$L \$i \$J \$C \$0n \$0h \$-a\\ 
{\ttfamily bk\_of\_filter\_options}& \$w \$l \$x \$y\\ 
\end{tabular}
\end{center}
\end{table}




\item By default,
for programs that are not being invoked as print job file filters,
the
{\ttfamily filter\_options}
arguments are added.
For print job filters, if the {\ttfamily bkf} flag is set,
then the
{\ttfamily bk\_filter\_options}
and
{\ttfamily bk\_of\_filter\_options}
entries are used.
The default {\ttfamily bk} filter options are the same as originally used
with the BSD LPR filters.
For the {\ttfamily of} filter,
either the {\ttfamily of\_filter\_options}
or {\ttfamily bk\_of\_filter\_options} arguments will be added.
\item The program arguments will then be scanned and interpreted.
Arguments of the form {\ttfamily \$letter} will be
translated into values from the
print job control file and/or printcap entry.
The letters have the following meaning:
\begin{table}[tbp]
\begin{center}
\begin{tabular}{{$|$}l{$|$}l{$|$}}
Letter& TranslatedValue\\ 
{\ttfamily a }& printcap {\ttfamily af} (accounting file name)\\ 
{\ttfamily b }& job size (in K bytes)\\ 
{\ttfamily c }& binary file ({\ttfamily l} format for print file)\\ 
{\ttfamily d }& printcap {\ttfamily cd} or {\ttfamily sd} entry\\ 
{\ttfamily e }& print job data file name (currently being processed)\\ 
{\ttfamily f }& print job original name when spooled for printing (N info from control file)\\ 
{\ttfamily h }& print job originating host (H info from control file)\\ 
{\ttfamily i }& indent request (I info from control file)\\ 
{\ttfamily j }& job number in spool queue\\ 
{\ttfamily k }& print job control file name\\ 
{\ttfamily l }& printcap {\ttfamily pl} (page length)\\ 
{\ttfamily m }& printcap {\ttfamily co}\\ 
{\ttfamily n }& use name (L info from control file)\\ 
{\ttfamily p }& remote printer (when processing for bounce queue)\\ 
{\ttfamily r }& remote host (when processing for bounce queue)\\ 
{\ttfamily s }& printcap {\ttfamily sf} (status file)\\ 
{\ttfamily t }& time in common UNIX format\\ 
{\ttfamily w }& printcap {\ttfamily pw} (page width)\\ 
{\ttfamily x }& printcap {\ttfamily px} (page x dimension)\\ 
{\ttfamily y }& printcap {\ttfamily py} (page y dimension)\\ 
{\ttfamily F }& print file format\\ 
{\ttfamily P }& printer name\\ 
{\ttfamily S }& printcap {\ttfamily cm} (comment field)\\ 
Capital letter& Corresponding line from control file\\ 
$\{$key$\}$& printcap value for {\ttfamily key}\\ 
\end{tabular}
\end{center}
\end{table}
\item If there is no value for the specified argument,
then the argument is removed from the list.
If there is a value, the actual form of the substitution is
controlled by additional flags as follows.
\begin{table}[tbp]
\begin{center}
\begin{tabular}{{$|$}l{$|$}l{$|$}}
Form& TranslatedValue\\ 
{\ttfamily  \$x }& {\ttfamily '-x{\itshape value\/}' }\\ 
{\ttfamily  \$-x }& {\ttfamily  '{\itshape value\/}' }\\ 
{\ttfamily  \$0x }& {\ttfamily  -x '{\itshape value\/}' }\\ 
{\ttfamily  \$'x }& {\ttfamily  -x {\itshape value\/} }\\ 
\end{tabular}
\end{center}
\end{table}

Each entry in quotes is treated as a single value,
as in /bin/sh.
The {\ttfamily \$'x} does not quote the value.
Combinations of the various flags are allowed.  For example,
{\ttfamily \$-x} would simply substitute the value for {\ttfamily x},
and then pass the whitespace separated components as individual arguments.
This last form is useful for adding in addition flags on the command line.

\item The command line is parsed,
metacharacters are ruthlessly stripped from all arguments and pathnames
and replaced by {\ttfamily \_} (underscores),
and an argument list suitable for the {\ttfamily execve} system call
is formed.
\item A sanitized environment is set up for the program execution,
with the following environment variables.
\begin{table}[tbp]
\begin{center}
\begin{tabular}{{$|$}l{$|$}l{$|$}}
{\ttfamily  USER }& User name (client only)\\ 
{\ttfamily  LOGNAME }& L control file info\\ 
{\ttfamily  HOME }& Home directory (client only)\\ 
{\ttfamily  LOGDIR }& Home directory (client only)\\ 
{\ttfamily  PATH }& {\ttfamily filter\_path} configuration information\\ 
{\ttfamily  LD\_LIBRARY\_PATH }& {\ttfamily  filter\_ld\_path } configuration information\\ 
{\ttfamily  SHELL }& {\ttfamily /bin/sh}\\ 
{\ttfamily  IFS }& {\ttfamily " $\backslash$t"}\\ 
{\ttfamily  TZ }& Time zone\\ 
{\ttfamily  SPOOL\_DIR }& {\ttfamily sd} printcap info\\ 
{\ttfamily  CONTROL\_DIR }& {\ttfamily cd} printcap info\\ 
{\ttfamily  PRINTCAP\_ENTRY }& printcap info\\ 
{\ttfamily  CONTROL }& control file\\ 
\end{tabular}
\end{center}
\end{table}




\item If the filter is to be run by a client program such as {\ttfamily lpr},
then the environment variables specified by the
{\ttfamily pass\_env} configuration or printcap option will be
extracted from the environment,
have any metacharacters removed,
and then placed in the environment variable list.
Commonly, the
{\ttfamily PGPPASS} and {\ttfamily PGPPATH} are specified.
\item The program is started,
with STDIN, STDOUT, and STDERR attached to the appropriate files or
file descriptors.
If none is specified, then they are attached to
{\ttfamily /dev/null}.
\end{enumerate}



\subsection{Bounce queues and filters: caveats}

There are a few situations in which a filter of a bounce queue will
behave differently from an ordinary queue.


\subsection{The lpr -p  format and :pr filter}

The {\ttfamily -p} format doesn't behave as expected. Instead of running
{\ttfamily pr $|$ if}, the daemon will try to call the {\ttfamily :pf} filter.

After filtering, the file might be of a different type than before.
Since the result is transfered to another print service (which might
do its own filtering), it is important that the right file type (by
means of the print format) is passed on to the second queue.

Use the
{\ttfamily \ref{translateformat} {(translate\_format)}
=oNoN...}
printcap option.
Its value takes the form of old/new pairs of formats. For example:
\begin{verbatim}
translate_format=pf
\end{verbatim}


The {\ttfamily -p} format file will now be renamed with the
{\ttfamily f} format.


\subsection{LPRng Supported Filters}

There already exists a large library of ready-to-use filters. Some of
them have LPRng-specific versions, which can be found at the
\ref{secftp} {(LPRng ftp mirror sites)}.


\subsubsection{Filter Distribution Conventions}

By convention,
most filters are either totally standalone (very rare),
or require a set of support files.
There are two types of support files: per print queue configuration information
and global support information.

Since a print filter will execute with the current directory set to the
spool queue directory,
most filters expect that per print queue configuration information
should be kept in the spool directory.
Most {\itshape vintage\/} filters insist on having these files {\itshape hidden\/}
with names such as {\bfseries {\ttfamily .setup}}.
This can make it difficult for administrators to determine where the
configuration files are.

It is strongly recommended that filters and information
be placed in commonly accessible directories such as
{\ttfamily {\bfseries /usr/local/lib/filters}},
and the executables in subdirectories.
This allows the LPRng administrator to set the privileges on these
directories such that only the {\ttfamily lpd} process can
access them.

Most of the LPRng supported filters can either be used as a
{\ttfamily if} or {\ttfamily of} filter.
The filter will examine the format type passed by the {\ttfamily -F{\itshape X\/}}
command line argument,
and if it is {\ttfamily o} (of filter) will perform as an
{\ttfamily of} filter.

Alternatively,
the filter will check the filename in the pathnameby which is was invoked.
If the name has the substring {\ttfamily of} in the filename,
then it assumes it is to act as an {\ttfamily of} filter.
This allows symbolic links to be make to a common filter executable,
each of which corresponds to the filter name by which it is to be invoked.

When a filter is invoked,
it is passed a large number of options,
many of which are totally ignored in filter operation.
However,
for many purposes it is necessary to provide options to the
filters to tailor their operation to the particular spool queue needs.

By convention,
all LPRng supported filters use the
\begin{verbatim}
-Tkey=value[,key=value]
\end{verbatim}


convention for specifying filter configuration option values.
\label{lpf}


\subsubsection{lpf}

Source code:
\ref{secftp} {(LPRng Distribution)}

This filter is distributed as part of the LPRng source code,
and has a very limited functionality.
By default,
it only translates {\ttfamily $\backslash$n} to {\ttfamily $\backslash$r$\backslash$n}
sequences,
and detects the OF Filter Stop sequence when invoked as an OF filter.
\begin{itemize}
\item Options:\\ 
{\ttfamily -Tcrlf} - suppress {\ttfamily $\backslash$n} to {\ttfamily $\backslash$r$\backslash$n} translation
\end{itemize}

\label{ifhp}


\subsection{CTI-ifhp ifhp Filters}

Source code:
\ref{secftp} {(LPRng Distribution, CTI-ifhp-{$<$}em{$>$}version{$<$}/em{$>$}.tgz)}

This filter supports a wide variety of Hewlett-Packard printers,
or to be more specific,
printers which support the Hewlett-Packard PCL and/or PJL languages.
In addition,
they try to detect PostScript jobs and send the correct commands to the
printers to enable PostScript rather than PJL operation.

This filter was originally developed by
Panos Dimakopoulos, Systems Programmer,
of the CTI-Print project
at the Division of Computing Facilities of the Computer
Technology Institute (CTI), Patras, Greece.
The code has been heavily modified by Patrick Powell
{\ttfamily $<$papowell@astart.com{$>$}}
to support newer versions of HP Printers.
It is intended to replace the HPJetDirect drivers supplied by Hewlett-Packard.


\subsubsection{Printer Capabilities}

As explained in
\ref{installref} {(Setting Up Your Printer)},
you can have a parallel (unidirectional),
serial (bidirectional),
or network (bidirectional) connection.
When using a bidirectional connection,
you can sometime obtain or gratuitously receive error and/or status
information from the printer.

Some printers will spontaneously generate error messages when printing
a job on a bidirectional interface.
Usually, though,
it it necessary to force the printer to provide status in a reasonable format.

Some printers have the capability of printing either PCL or PostScript;
some require special setup commands and some will {\itshape autosensee\/} which
type of job is being printed.

If you are printing text,
and not using a Page Description Language like PostScript or PCL,
then you may want to download a font to the printer.
This is especially the case when you are trying to print text files
in a non-English font.

Some printers will provide a {\itshape hardware\/} page counter value when requested;
however,
the means of requesting differ from model to model.

Sometimes you want to generate a special banner for a particular printer,
and need to put in some dynamic information.
While this can be done by the {\ttfamily lpd} server using the
{\ttfamily bp} program specification,
it turns out that non-LPRng systems which want to use the {\ttfamily ifhp}
want to have the same facilities.
Thus,  you need to have some way to get the same effect as the {\ttfamily bp}
option,  but at the filter level.

Having done {\ttfamily lpd} banner generation and printing,
why not have the filter run an accounting script as well?

At this point,  I suspect that the reader is beginning to suspect that
making a general purpose filter to support all of these possibilities is
difficult.
That is incorrect.  It is {\bfseries extremely} difficult.


\subsubsection{hpif Options}

These options are specified by the {\ttfamily -Tkey=value [key=value]*}
on the command line.

\begin{table}[tbp]
\begin{center}
\begin{tabular}{{$|$}l{$|$}l{$|$}}
Option& Purpose\\ 
{\ttfamily accounting=accounting\_script\_pathname}& Invoke the accounting script with a subset of theoptions passed to the filter. In addition, the-bpagecount option indicates the number of pagesprinted for the job.\\ 
{\ttfamily autodetect=[on$|$off*]}& The printer has or does not have job type autode-tect capability. Do not download fonts or try todetermine job type if autodetect is on.\\ 
{\ttfamily banner=[on$|$off*]}& If banner is on, then the ifhp filter will attemptto print a banner using information passed on thecommand line or on the standard input. The titleoption can be used to specify additional titleinformation on the banner. See BANNERS below fordetails.\\ 
{\ttfamily cartridge=[*on$|$off]}& (Alias for postscript)If cartridge is on, the printer has PostScript sup-port. The filter will try to determine if a job ispostscript and send Printer Job Language commandsto put the printer in PostScript mode.\\ 
{\ttfamily debug=debuglevel}& Sets the debugging level; 2 is the default; alarger number causes more verbose error messages.\\ 
{\ttfamily defaultfont=fontname}& Sets the default font to be downloaded; default isNONE.\\ 
{\ttfamily dev=/device or dev=host\%port}& Open the specified device or connection to remotehost; by default ifhp filter uses file descriptor 1(stdout). If the optional orig\_port is specified,connections will be originated from this port.Some printers require that connections originatefrom a port in the range 1-1024.\\ 
{\ttfamily infostatus=[*on$|$off]}& The PJL INFOSTATUS request is not supported on someHP printers. Use this to turn the status requestoff. Note that you cannot get real time reports ofthe printer status if you do this. This will alsosuppress getting pagecount information using thePJL facilities.\\ 
{\ttfamily forcepagecount=[on$|$off*]}& If you have a printer that has PostScript pagecount information support, you can set infostatusto OFF and forcepagecount to ON. This will causethe PostScript facility to be used. If you setcartridge or postscript to OFF then this will notbe done.\\ 
{\ttfamily logall}& Save all of the error and information messages fromthe printer in the log file. This is useful whenyou wish to examine returned status from theprinter.\\ 
{\ttfamily model=(C5M$|$III$|$IIID$|$IIISi$|$IV*)}& The model of HP printer. C5M is Color 5M, III isHP LaserJet 3, IIID is HP LaserJet 3D, etc. Addi-tional printers may be added or defined at varioustimes - please consult the source for details.This selects various timing and format characteristic-tics. This is a desperation parameter for userswith antique or non-conforming PJL based equipment;read the source code for details on the particularpeculiarities.\\ 
{\ttfamily pagecount=[on*$|$off]}& Get the hardware pagecounter value for accounting.Some printers such as the HP LJ4s do not have hard-ware support for pagecounters, and return bogusnumbers. Use this to suppress attempting to getvalid information. If your printer does supportPostScript, then you can get the page count valueusing PostScript by setting forcepagecount to ON.\\ 
{\ttfamily plp=[on$|$off*]}& Return PLP status values on exit; by default LPRngstatus values are returned.\\ 
{\ttfamily postscript=[on*$|$off]}& The printer has postscript support.\\ 
{\ttfamily quiet=[on$|$off*]}& If set, do not report common status messages.\\ 
{\ttfamily retries=count}& The number of times to retry connecting to theprinter.\\ 
{\ttfamily sleep=time}& The number of seconds to wait before trying to con-nect to the printer.\\ 
{\ttfamily status=[*on$|$off]}& When on, the printer is treated as a write onlydevice and is not queried for pagecount and statusinformation. Set status=OFF for parallel printers.If status is OFF, then the ifhp filter simply addsjob control language headers, fonts, and trailersto the jobs.\\ 
{\ttfamily stty=stty flags}& if the output device is a serial line, set the linecharacters according to the stty flags. Theseflags are (most likely) identical to those avail-able with the stty(1) command on the host system.\\ 
{\ttfamily summary=[filename$|$host\%port]}& This option specifies that summary or informationalmessages should be placed in the specified file orsent, using the UDP protocol, to the indicated hostand port address. This allows remote monitoring ofthe printing and error activity. The undocumentedprogram included with the filter distribution is asimple program that can be used to perform the mon-itoring.\\ 
{\ttfamily sync=[*on$|$off]}& Try to synchronize communications with printer.This will ensure that the printer has been reset,and no problems involving the previous job willresult.\\ 
{\ttfamily tbcp=[on$|$*off]}& When invoked as an IF filter and transferring aPostScript job, the filter will use the AdobeTagged Binary Communications protocol. This allowsbinary data to be transferred and not interpretedas control information.\\ 
{\ttfamily title=line[/line]*}& The title information is printed on the bannerpage; it consists of a list of / separated lineswhich are added to the banner information.\\ 
{\ttfamily wrap=[on$|$off*]}& enables or disables line wrapping in PCLmode.\\ 
\end{tabular}
\end{center}
\end{table}



\subsubsection{Parallel Port Printer}

On a parallel port printer, you cannot get status, or do much besides
set up the printer to either handle PostScript or do autosensee.
The following is a typical printcap entry:
\begin{verbatim}
pr:.... options
  :of=/usr/local/lib/filters/ifhp -Tstatus=off
  :if=/usr/local/lib/filters/ifhp -Tstatus=off
\end{verbatim}


You might want to also look at the {\ttfamily autodetect}
or {\ttfamily postscript} options.
\label{ifhpbanner}


\subsubsection{Printing Banners}

By default, the {\ttfamily ifhp} filter when used as an OF filter will
interpret the first line to it as a
{\itshape short banner\/} line,
and use the information on this line to produce a PCL based banner.
The short banner line should have the format:

{\itshape class\/}:{\itshape username\/} {\ttfamily Job:} {\itshape jobinfo\/} {\ttfamily Date:} {\itshape dateformat\/}

\begin{verbatim}
Example:
  A:papowell Job: (stdin) Date: Sun Dec 14 07:13:34 PST 1997
\end{verbatim}


This is produced by the default
short banner line option value:
\begin{verbatim}
bl=$-'C:$-'n Job: $-'J Date: $-'t
\end{verbatim}


If you want to suppress banner printing,
then you need to suppress generation of this short banner line.
If you want to have the {\ttfamily lpd} program to generate the
default {\itshape long\/} special banner,
then you need to suppress {\ttfamily ifhp} from interpreting the
information sent to is as banner information.
Finally, you may want to have {\ttfamily lpd} invoke the {\ttfamily bp}
(banner program) and have its output used as the banner.
Here are the various possible ways:

\begin{verbatim}
# no banner at all, use :sh: - suppress headers
lp:....
  :sh
  :of=/usr/local/lib/filters/ifhp
# have ifhp generate banner from short banner input
lp:....
  :sb
  :of=/usr/local/lib/filters/ifhp
# have LPD generate long banner, have of filter pass it
lp:...
  :sb@
  :of=/usr/local/lib/filters/ifhp -Tbanner=off
# have LPD invoke bp banner generation program, have of filter pass it
# bp programs require short banner on STDIN to work, so we need to
# generate short banner
lp:...
  :sb
  :bp=/usr/local/lib/filters/banner_program
  :of=/usr/local/lib/filters/ifhp -Tbanner=off
\end{verbatim}


The {\ttfamily ifhp} banner is generated in PCL,
and uses the minimum PCL facilities.
Since when you send a banner to an autosenseing printer you cause it to enter
the requested mode,  the if filter (ifhp) will need to reset the printer
to autosensee mode.  The ifhp filter automatically does this.

If you want very fancy banners,
the
{\ttfamily banner.sh} (PCL) and
{\ttfamily psbanner.sh} (PostScript) banner generating programs
in the CTI-ifhp distribution make a good starting point.
\label{ifhperror}


\subsubsection{Error Logging}

Error logging and reporting is done by the {\ttfamily ifhp}
filter as follows.
\begin{enumerate}
\item Messages are produced by the actions of the {\ttfamily ifhp}
software.
This are logged to the STDERR output of the filter.
\item Messages are produced by status returned from the printer,
when the {\ttfamily -Tstatus=on} (default) option is enabled.
These are classified according to the Hewlett-Packard Printer Job Language
error status definitions,
and logged to the STDERR output of the filter.
\item In addition to error messages,
ongoing status messages are also produced.
If the printcap entry has a {\ttfamily ps=statusfile} entry and the
statusfile exists and is writeable,
then the error and status messages will be written to the log file.
\item If the message concerns a serious matter or has been returned from the
printer as an 'ALERT' in it,
then the message can also be sent to a 'summaryfile'.
This file can be either a file
OR a UDP socket on a host. This is specified with the
-Tsummary=summaryfile option. For example
ifhp -Tsummary=taco\%3000 would send messages to UDP port 3000
on host taco.
\item If you do not want the filter to report status on its STDERR output,
use the -Tquiet option to suppress this, or
compile it with the -DQUIET option.
\end{enumerate}

\label{ifhpaccounting}


\subsubsection{Accounting Information}

Doing printer accounting  is not simple.
Read
\ref{accountingref} {(LPRng Accounting)}
for more information.

In order to help aid in accounting,
by default the {\ttfamily ifhp} filter will query the printer
to get the current value of the {\bfseries hardware} page counter value,
if there is such a thing on the printer.
Unfortunately,
due to different types of printers and errors in their PJL, PCL,
and PostScript implementations,
several different methods need to be used.
\begin{enumerate}
\item Only a printer with a bidirectional port will return status,
so you need to have a bidirectional connection.
\item If the printer is still printing a job,
then getting the value of the hardware page counter will be useless;
you need to wait until the printer is idle,
i.e. - synchronize your operations with the printer.
Unfortunately,
some printers return an {\ttfamily idle} indication even when
they are printing pages of the previous job.
This means that the printer has to be polled,
and only when it is idle {\bfseries and} the pagecounter value has been
stable for a reasonable time (5 seconds?)
can you trust the page counter value.
This slows down job printing very seriously.

Some of the newer PJL printers have a
{\ttfamily PJL TEOJ},
or return end of job indication when the last page of a job
has been printed.
If you have this capability,
you can speed up printing.

\item If your printer supports Hewlett-Packard Printer Job Language
{\ttfamily PJL INFO PAGECOUNT}
facility,
then it will first be tried to get the page count.
\item If your printer does not return pagecount information
using the PJL facility and it has PostScript support (default),
then a small PostScript job will be sent to the printer
requesting the {\itshape systemdict pagecounter\/} value.
Unfortunately,
different implementations and versions of PostScript will
need different programs.
The PostScript Printer Definition file for the printer will
have the correct script that is needed.
The default script that is used is:
\begin{verbatim}
 /ps { print flush } def
 (\tPAGECOUNT ) ps
 statusdict begin pagecount end == flush
\end{verbatim}
\item To confuse matters totally,
some printers
which can do PostScript
interpretation do not support PJL {\itshape PAGECOUNT\/} reporting.
You can use the PostScript method to get the pagecount information,
but you cannot get status.
\item The pagecounter information is obtained at the start and end of processing
a job,
and is printed in the accounting file and also on File Descriptor 3
(if it is open).
This information has the format:
\begin{verbatim}
  start -ppagecounter -Ff -kjob -uuser -hhost -R...
  end  -ppages -qpagecounter -Ff -kjob -uuser -hhost -R...
\end{verbatim}


When we use the OF filter and/or banners,  we will see the
individual jobs bracketed by the OF filter records:

\begin{verbatim}
    start -p100 -Fo -kcfA100taco -uuser -hhost -R...
    start -p101 -Ff -kcfA100taco -uuser -hhost -R...
    end  -p1 -q102 -Ff -kcfA100taco -uuser -hhost -R...
    start -p102 -Ff -kcfA100taco -uuser -hhost -R...
\end{verbatim}


We can use the various job numbers and other information
to track page usage.

\end{enumerate}


The following are a selected set of printcap entries that can
be used to get page counting information:
\begin{verbatim}
# use defaults, try to get pagecount using all methods, wait for stable
# value of pagecount before proceeding
pr:...
  :of=/usr/local/lib/filter/ifhp
# printer support PJL True End of Job and PAGECOUNT
pr:...
  :of=/usr/local/lib/filter/ifhp -Ttrue_eoj=on
# no PJL INFO status available, but you can get page count using postscript
pr:...
  :of=/usr/local/lib/filter/ifhp -Tinfostatus=off,forcepagecount
\end{verbatim}


You should try connecting to your printer directly
and testing the accounting facilities.
You can do this by using the {\ttfamily ifhp -Tdev=...}
facility.
For example:
\begin{verbatim}
ifhp '-Tdev=/dev/ttyb,stty=38400 -echo -crmod -raw -oddp \
-evenp ixon pass8 -ixany cbreak' -Tdebug=5 <ellipse.ps
ifhp -Tdev=astart14%9100 -Tdebug=5 -Ttrue_eoj <ellipse.ps
\end{verbatim}

\label{psfilter}


\subsection{psfilter PostScript Printer Filter}

Source code:
\ref{secftp} {(LPRng Distribution, psfilter-{$<$}em{$>$}version{$<$}/em{$>$}.tgz)}

The
{\ttfamily psfilter} is similar to the CTI-ifhp
filter in its operation and functionality.
Its general operation and procedures are similar,
but it has the following additions:
\begin{enumerate}
\item  It will translate text jobs to PostScript and print them
using PostScript unless the jobs are {\itshape literal\/} or binary formats.
\item  It will use the PostScript serial line status query support
to obtain status and other error information.
\item  When you are sending a PostScript file with {\itshape binary\/} information,
you need to either suppress status gathering,
or you need to use the
{\itshape Transparent Binary Communications Protocol\/}.
Note that older PostScript printers do not support this.
\end{enumerate}

\label{psfilterprintcap}


\subsubsection{IF and OF Filter Support}

During the installation process,
{\ttfamily  psif } and
{\ttfamily  psof } symbolic links are made to the
{\ttfamily  psfilter} executable.
Thus,
the following printcap entries can be used:
\begin{verbatim}
# common use:
lp:...
  :of=/usr/local/lib/filters/psof
  :if=/usr/local/lib/filters/psif
# same effect:
lp:...
  :of=/usr/local/lib/filters/psfilter
  :if=/usr/local/lib/filters/psfilter
\end{verbatim}

\label{psfilteroptions}


\subsubsection{Options}

The {\ttfamily -Tkey=value[,key=value]} convention is used to
pass options to the psfilter.
The following options are supported.
Many of these are identical in intent to CTI-ifhp options.
\begin{table}[tbp]
\begin{center}
\begin{tabular}{{$|$}l{$|$}l{$|$}}
Option& Purpose\\ 
{\ttfamily accounting=/pathname\_to\_executable}& When the -Taccounting is specified, the specifiedprogram is executed with the same options as thefilter.\\ 
{\ttfamily debug=level}& set debugging level. The default level is 2;higher values produce more verbose output.\\ 
{\ttfamily dev=/device}& dev=host\%portOpen a connection to either the device or to theport on the host and send output to it. Bydefault, output is send to stdout.\\ 
{\ttfamily endpause=delay}& When used as the OF filter, at the start and end ofthe job psfilter will query the printer for thevalue of the hardware pagecounter. The differencebetween the start and end values is reported as thenumber of pages used for the job. Unfortunately,some printers such as the HP LaserJet 4 and HPLaserJet 5 report the current value of the pagecounter at the time of request, and it is difficultto determine if the last page has been completelyprinted by examining returned PostScript status.Before querying the printer at the end of a job,the psfilter software will wait endpause seconds(default is 5). On a 12 page per minute printer,this appears to be sufficient to allow the lastpage to be completely printed. However, if theprinter jams on the last page, it will still not bereported and the page count will be off by one.\\ 
{\ttfamily forcepagecount=[off*$|$on]}& To find the pagecount value, a PostScript programis sent to the printer. This overrides any otherflags and forces the program to be sent. Usuallyused in combination with -Tstatus=off -Tforceps,and -Tnosync flags. See the comments below forprinter specific problems.\\ 
{\ttfamily forceps=[off*$|$on]}& Forces a dummy PostScript job to be sent at thestart of operations. This usually tricks autosense-ing printers into going into PostScript mode andresponding to the PostScript conventions. See thecomments below for printer specific problems.\\ 
{\ttfamily maxresponse=seconds(default30seconds)}& Specifies how long to wait for a status responsebefore giving an error indication.\\ 
{\ttfamily nosync=[off*$|$on]}& Suppresses trying to get status from the PostScriptprinter, as would normally be returned by sending a\^{}T. See the comments below for printer specificproblems.\\ 
{\ttfamily pagecount=[off$|$on*]}& Get the pagecounter value from the printer and usefor accounting information. Note that some HPprinters (LJ4s) do not appear to have pagecounters.(Default is on).\\ 
{\ttfamily reverse=[off*$|$on]}& Reverse page order on output.\\ 
{\ttfamily status=[off$|$on*]}& Query the print device for status and page countinformation. If status is off, then psfilter sim-ply formats input into postscript and does not doaccounting.\\ 
{\ttfamily stty=stty\_options}& If the output device is a serial port, set the con-figuration according to the stty options. Theseoptions should be identical to those used bystty(1).\\ 
{\ttfamily summary=destination}& Write a one line status summary to the destination.The destination can be a file (i.e. - /tmp/status)or a UDP port on a host (host\%port). The host namecan be an hostname or an IP address (i.e.-info.sdsu.edu\%2000 or 130.191.163.56\%1000).\\ 
{\ttfamily tbcp=[off*$|$on]}& Use the Adobe Tagged Binary Communications protocolto send the document when invoked as an IF filter.The OF filter cannot handle binary PostScript docu-ments as it will remove various control sequences.The -Ztbcp LPRng option will also enable TBCP oper-ations.\\ 
{\ttfamily udp\_status\_port=host\%port}& The HP5m and possibly other printers use port 9101(UDP) to request and send status. When sent a UDPpacket on this port, the printer responds by sendingstatus back to the sender. This option forces theuse of this port for sending status. However, pagecounts and other information still use the standardconnection to the printer.\\ 
\end{tabular}
\end{center}
\end{table}

\label{psfilteraccounting}


\subsubsection{Accounting}

The {\ttfamily psfilter} uses the same methods for doing accounting as the
{\ttfamily CTI-ifhp} filter.
See
\ref{ifhpaccounting} {(IFHP Accounting)} for details.

Consult your printers PostScript Printer Description file
to determine the PostScript script needed to do accounting.
You may need to modify the default one supplied in the {\ttfamily psfilter}
code.

Always test that the printer returns the right accounting information using
a test similar to the following:
\begin{verbatim}
psfilter -Tdebug=8 '-Tdev=/dev/ttyb,stty=38400 -echo -crmod -raw -oddp \
-evenp ixon pass8 -ixany cbreak' <ellipse.ps
psfilter -Tdebug=8 -Tdev=astart14%9100 -Ttrue_eoj <ellipse.ps
\end{verbatim}

\label{lppipe}


\subsection{lp\_pipe Filters}

Source code:
\ref{secftp} {(LPRng Distribution, part of FILTERS\_LPRng-$<$version{$>$}.tgz)}

The {\ttfamily lp\_pipe} family of filters was developed to act
as a {\itshape network pipe\/} to network devices.
They are largely replaced by the {\ttfamily lp=host\%port}, facility.
\begin{itemize}
\item {\ttfamily tcp-pipe}: uses a tcp socket ({\bfseries OBSOLETED} by
{\ttfamily lp=host\%port}), but good starting point if you have special
device requirements;
\item {\ttfamily annex-pipe}: supports annex terminal server.
\end{itemize}

\label{apsfilter}


\subsection{apsfilter Filter}

Source code:
\ref{secftp} {(LPRng Distribution, apsfilter-$<$version{$>$}.tgz)}

The {\ttfamily apsfilter}
is basically a simple front end to the {\ttfamily a2ps} program
(See:
\url{http://www-inf.enst.fr/\~{}demaille/a2ps/} for details),
and is an example of a {\itshape MagicFilter\/} that has powerful
processing capability.
The {\ttfamily apsfilter} program sets up options for the
{\ttfamily a2ps} program and then invokes it.

The {\ttfamily a2ps} program can convert just about any type of file
into PostScript,
and then by using the GhostScript facility can convert this to
the output compatible with a particular printer.

Combined with the LPRng {\ttfamily qq} and {\ttfamily force\_queuename}
options, we can set up virtual queues that do various types of reformatting.
Here is a sample set of printcap entries:
\begin{verbatim}
# seen by users - note that the queue name is put into control file,
#  and we then send it to the frontend@host queue for processing
raw:qq:lp=frontend@host
twoup:qq:lp=frontend@host
landscape:qq:lp=frontend@host
frontend:lp=frontend@host:force_queuename=raw
# frontend does the job conversions and accounting
frontend:server
  :lp=/dev/lp:force_queuename=raw
  :if=/usr/local/lib/filter/apsfilter
\end{verbatim}



\subsection{Using your own filters}

If you already have a working setup, with its own specific filter
programs, you might want to keep them. Or, you might want to write a
set of your own.

See the source code in the
\ref{secftp} {(LPRng Distribution, FILTERS\_LPRng-$<$version{$>$}.tgz)} files for examples.
\label{sd}
\label{cd}


\section{Spool Queues and Files}

When files are accepted by the {\ttfamily lpd} server for printing,
they are stored in a spool queue directory,
together with other files controlling the print operation.
This section describes these files and how the LPRng software uses them.

For descriptive purposes,
we will use the following printcap entry as a guide:

\begin{verbatim}
pr|alias
  :sd=/var/lpd/pr_public
  :cd=/var/lpd/pr
\end{verbatim}



\subsection{Spool Queue and Control Queue}

\begin{itemize}
\item  {\ttfamily sd=}{\itshape Spool queue directory name\/}
\item  {\ttfamily cd=}{\itshape Control queue directory name\/}
\end{itemize}


The
{\ttfamily sd}
option in the printcap entry specifies the spool queue
directory.
If there is no
{\ttfamily sd}
entry or value,
then the printer can only be used by the clients such as {\ttfamily lpr}
to locate the destination for a print job.

Normally,
all information,
files,
etc.,
for a print queue is stored in the spool directory.
However,
some software packages such as the PC-NFS spooling package from
Sun Microsystems originally required read/write access to the directory
in order to create print jobs on behalf of the user.
To prevent unauthorized or accidental tampering with LPRng operations,
the {\ttfamily cd} (control directory) entry specifies that only the
print job files should be placed in the spool queue,
and that all the control and informational files should be in the
control directory.

By default,
the {\ttfamily cd} value will be the same as the {\ttfamily sd}
value unless explicitly overridden in the printcap entry.


\subsection{Job State}

\label{ah}

Options used:
\begin{itemize}
\item  {\ttfamily ah}{\itshape ~~Automatically hold jobs\/}
\end{itemize}


A job can be in the following state:
\begin{enumerate}
\item Initial.
This is the state during job submission.
Jobs in the initial state do not have any status displayed for them.
\item Held.
Once a job is submitted,
it can either be printed or {\itshape held\/}.
The {\ttfamily ah} printcap option specifies that all jobs are
automatically held on submission.
The
{\ttfamily lpc release}
and
{\ttfamily lpc redo}
command will cause these jobs to be printed and
the {\ttfamily lprm} command can remove these jobs.
\item Active.
The job is being processed for printing or transfer to another queue.
\item Pending.
Jobs which can be printed but are not active.
\item Error.
Jobs which have encountered and error during printing.
The
{\ttfamily lpc release}
and
{\ttfamily lpc redo}
command will cause these jobs to be printed and
the {\ttfamily lprm} command can remove these jobs.
\item Done.
Jobs which have completed printing,
but which are not yet removed from the print queue.
See the
{\ttfamily \ref{savewhendone} {(save\_when\_done)}}
flag for more information.
The {\ttfamily lprm} command can remove these jobs.
\end{enumerate}


Normally the job sequences is initial, pending, active, and done.
However, a job may be put in the error state by problems processing the job
or by actions of the {\ttfamily lpc} command.


\subsection{Printer Lock File}

When the {\ttfamily lpd} server starts printing,
it will fork individual worker processes to service each queue.
To prevent multiple processes from working on the same queue,
a printer lock file with the cannonical spool queue name is used.
In our example,
the lock file would be:
{\ttfamily /var/lpd/pr/pr}.

The process ID of the currently active printer is stored in the lock file.
By reading the lock file and testing to see if the process is still active,
programs such as {\ttfamily lpq} can determine queue activity.

Similarly,
the worker process may need to create other processes to assist it.
These in turn will create lock or temporary files in the spool directory
as well.


\subsection{Spool Control File}

The spool control file is used to control the operations of the
spooler,
and is in the spool or control directory.
The file name has the form {\ttfamily control.{\itshape printer\/}};
in our example,
the control file would be:
{\ttfamily /var/lpd/pr/control.pr}.

The {\ttfamily lpc} program sends spool control requests to the
{\ttfamily lpd} daemon,
which updates the control file and then signals the appropriate
spool server processes that an update has been performed.
The control file contents have the form:
\begin{verbatim}
key value
\end{verbatim}


The following keys and their values are currently supported.

\begin{table}[tbp]
\begin{center}
\begin{tabular}{{$|$}l{$|$}l{$|$}l{$|$}}
Key& Values& Purpose\\ 
printing\_disabled& 0 or 1& disable printing of jobs in queue\\ 
spooling\_disabled& 0 or 1& disable placing jobs in queue\\ 
holdall& 0 or 1& hold jobs until released\\ 
redirect& printer& transfer jobs to indicated printer\\ 
class& glob expression& print only jobs whose class matches glob expression\\ 
server\_order& printer name list& preferred order of printer use\\ 
debug& debugging options& debugging and tracing\\ 
\end{tabular}
\end{center}
\end{table}


The {\ttfamily printing\_disabled} and {\ttfamily spooling\_disabled}
are managed using the {\ttfamily lpc} start, stop, enable and disable
commands.
Similary,
{\ttfamily holdall} is enabled and disabled by holdall and noholdall
commands respectively.
When holdall is enabled,
jobs placed in the print queue will be held until they are explicitly
released for printing by an {\ttfamily lpc release} command.

The {\ttfamily redirect} entry is used to redirect or transfer jobs
which are spooled to this queue to another queue,
and is managed by the redirect command.
The {\ttfamily lpc redirect off} removes the redirect entry from the
control file.

The {\ttfamily class} entry is similar in operation to the
{\ttfamily holdall},
but allows jobs whose class identification matches the glob
expression to be printed.
This can be useful when you have special forms or paper required for a
print job,
and want to run only these jobs when the paper is in the printer.

The {\ttfamily server\_order}
entry is created and updated for a multiple printer queue.
It records the order in which printers should next be used
for normal print operations.
This allows {\itshape round robin\/} use of printers,
rather than having all jobs printed to the first printer in the
list of printers.

The {\ttfamily debug}
entry is set by the {\ttfamily lpc debug} command,
and is used to enable or disable debugging and tracing information
for a spool queue.
This facility is for diagnostic purposes only.
\label{lf}
\label{ps}
\label{maxstatusline}
\label{maxstatussize}
\label{minstatussize}


\subsection{Log and Status Files}

\begin{itemize}
\item  {\ttfamily lf=}{\itshape log file name (default: log)\/}
\item  {\ttfamily max\_status\_line\#}{\itshape ~~maximum status line length (characters) \/}
\item  {\ttfamily max\_status\_size\#}{\itshape ~~maximum status file size (Kbytes)\/}
\item  {\ttfamily min\_status\_size\#}{\itshape ~~minimum status file size (Kbytes)\/}
\item  {\ttfamily ps=}{\itshape filter status file name (default: status)\/}
\end{itemize}


During operation,
the {\ttfamily lpd} server records the current printing operations
in the {\ttfamily status.{\itshape printer\/}} file.
For our example, this would be
{\ttfamily /var/lpd/pr/status.pr}.
In order to prevent this file from growing too large,
the server will periodically truncate the file.
The
{\ttfamily max\_status\_size} configuration or printcap option
sets the maximum size (in Kbytes) of the status file;
if the file exceeds this,  only the last
{\ttfamily min\_status\_size} bytes or 25\% (default if not specified)
will be preserved.

Some filters require an additional filter status file
that they use for recording additional filter status or
other operational information.
The
{\ttfamily ps} names this file,
and it is passed to a print filter using the {\ttfamily \$s}
option
(see
\ref{filtercmd} {(Filter Command Line Flags)}).

The log file ({\ttfamily lf}) is opened and used as the
STDERR output for filters and debugging information from
the {\ttfamily lpd} server.

When reporting status information,
the length of line returned can be a problem.
The {\ttfamily max\_status\_line\#79} option restricts the status line
to a maximum of 79 characters.


\subsection{Job Control File}

\begin{itemize}
\item  {\ttfamily longnumber}{\itshape ~~ long job number\/}
\item  {\ttfamily default\_priority=}{\itshape default job priority\/}
\end{itemize}


A print job consists of a control file and one or more data files.
\ref{rfc1179} {(RFC1179)}
specifies the general format of these files and how they are to be
transfered between servers.
LPRng has extended the contents of the control files and the transfer protocol
to provide a more powerful set of features,
but has extensive provisions for backwards compatibility with
non-LPRng software.
A sample control file is shown below:
\begin{verbatim}
Hastart4.astart.com
J/tmp/file1 /tmp/file2
CA
Lpapowell
Ppapowell
fdfA002230astart4.astart.com
N/tmp/file1
UdfA002230astart4.astart.com
fdfB002230astart4.astart.com
N/tmp/file2
UdfB002230astart4.astart.com
\end{verbatim}


The first part of the control file contains general information generated
by the {\ttfamily lpr} or other spooling program.
The information lines start with an uppercase letter or digit.
Some other spooling systems also start information lines with
various punctuation marks such as underscores (\_) or periods (.).

Following this are a set of entries about each of the various files to
be printed.
These lines start with a lower case letter,
followed by the print file name.
The lower case letter is the
{\itshape format\/} to be used to process the file.
See
\ref{format} {(print file formats)}
for more information about its use.

\begin{table}[tbp]
\begin{center}
\begin{tabular}{{$|$}l{$|$}l{$|$}l{$|$}}
Key& Meaning& Generated By\\ 
A& identifier *& LPRng internal\\ 
C& class& lpr -C class\\ 
D& date& lpr\\ 
H& originating host& lpr\\ 
I& indent& lpr -i indent\\ 
J& jobname& lpr -J jobname (default: list of files)\\ 
L& bnrname& lpr -U username\\ 
N& filename& (see text)\\ 
M& mailname& lpr -m mailname\\ 
P& logname& lpr\\ 
Q& queuename& lpr -Q\\ 
R& accntname& lpr -R accntname\\ 
S& slinkdata *& lpr\\ 
T& prtitle& lpr -T prtitle\\ 
U& unlnkfile& (see text)\\ 
W& width& lpr -w width\\ 
Z& zopts *& lpr -Z zopts\\ 
1& font1& lpr -1 font1\\ 
2& font2& lpr -2 font2\\ 
3& font3& lpr -3 font3\\ 
4& font4& lpr -4 font4\\ 
\end{tabular}
\end{center}
\end{table}


The entries marked with * are used only by LPRng.
{\ttfamily N} and {\ttfamily U} lines
are associated with a print file.
The {\ttfamily N} line is the original name of the print
file.
The {\ttfamily U} line originally was used to indicate that the
named file was to be unlinked after printing.
This information is now ignored by LPRng.
These lines are always grouped with a print file entry.

The names of control and data files follow a very strict pattern.
Control files have the format {\ttfamily cfX{\itshape number\/}{\bfseries host}},
where X is an upper case letter,
{\itshape number\/} is (usually) a 3 digit number,
and {\bfseries host} is the host name.
\ref{rfc1179} {(RFC1179)}
restricted the total length of the control file name to 32 characters;
LPRng has a much looser limit.

Data file names must follow the same pattern as the control file name,
and have the format
{\ttfamily dfX{\itshape number\/}{\bfseries host}}.
The X can be in the range A-Za-z,
allowing at most 52 data files for a job.
The {\itshape number\/} and {\bfseries host} must be identical to the corresponding
control file.

By convention,
LPRng uses the X of the control file name to set a priority for the
job.
A job with format
{\ttfamily cfA}
will have {\itshape lower\/} format
than a job with format
{\ttfamily cfB},
and so forth.
The {\ttfamily lpr} program uses the first letter of the class name
or an explicit priority indication to set the letter value.
If none of these are specified, then the
{\ttfamily default\_priority} value from the configuration or printcap
entry is used.

The job number is usually a 3 digit value.
However,
in systems where a large number of jobs are spooled and need to be
kept for printing at scheduled times,
this can lead to problems.
The
{\ttfamily longnumber}
option will use 6 digit job numbers.
This must be used with care when operating with non-LPRng software.


\subsection{Job Hold File}

Associated with each control file is a
hold file that has additional information controlling the printing operations.
The entries in this file have the form:
\begin{verbatim}
key [value]
\end{verbatim}


The following is an example of a hold file:
\begin{verbatim}
active 0
attempt 3
error cannot open printer
hold 0
priority 0
remove 0
routed 0
\end{verbatim}


The
{\ttfamily active}
entry records the process ID of the server process that is printing
the job.
The
{\ttfamily attempt}
field records the total number of attempts to print the job.
The
{\ttfamily error}
field records any error that would prevent the job from being printed.
This information is reported by the {\ttfamily lpq} program.

The
{\ttfamily hold}
field is non-zero when the
{\ttfamily lpc hold}
command is used to
explicitly prevent the job from being printed;
{\ttfamily lpc release}
will clear the field and allow the job to be printed.

The
{\ttfamily priority}
field is modified by the
{\ttfamily lpc topq}
command and is used to provide an overriding priority to printing the file.

The
{\ttfamily remove}
field is non-zero when the file has been printed and should be removed.

The
{\ttfamily routed}
field is used to indicate that there is routing information present in
the hold file,
and that special handling is needed.
The routing information is provided by a
\ref{routing} {(routing filter)}
The information is recorded by information in the hold file.
The following is an example of routing information:

\begin{verbatim}
active 0
attempt 0
done 0
hold 0
priority 0
remove 0
routed 880892602
route dest t1
route ident papowell@astart4+705.1
route error 
route copies 1
route copy_done 0
route status 0
route active 0
route attempt 0
route done 0
route hold 0
route sequence 0
route priority B
route CB
route end 
route dest t1
route ident papowell@astart4+705.2
route error 
route copies 0
route copy_done 0
route status 0
route active 0
route attempt 0
route done 0
route hold 0
route sequence 1
route end 
\end{verbatim}


Routing information lines start with
{\ttfamily route} followed by individual routing entry information.
The {\ttfamily route} {\ttfamily dest},
{\ttfamily copies},
{\ttfamily priority},
and
{\ttfamily Xnnnn}
entries are
derived from the output of the router program;
other fields are used during the printing process.
The {\ttfamily copy\_done} records the numbers of copies done,
while the {\ttfamily done} records that the entry has been completed.
The {\ttfamily status} is the process ID of the server process
doing the printing.

The output from  route filter  that generated the above file was:
\begin{verbatim}
dest t1
copies 1
priority B
CB
end
dest t1
end
\end{verbatim}

\label{useidentifier}


\subsection{Job Identifier}

Options:
\begin{itemize}
\item  {\ttfamily use\_identifier}{\itshape ~~put job identifier in control file\/}
\end{itemize}


For each job in a spool queue,
the LPRng software creates a unique identifier.
This identifier is recorded in the control file {\ttfamily A} line.
It can be used by the various client programs for identifying jobs,
and is displayed by the {\ttfamily lpq} program as status information.

\label{configfile}
\label{lpdconf}


\section{/etc/lpd.conf Configuration File}

The values in the LPRng configuration file
(default: {\ttfamily /etc/lpd.conf})
specify values for global options
and default values for printcap options.
See the man pages for
{\ttfamily lpd.conf(5)} and
{\ttfamily printcap(5)}
for a complete list of configuration variables and their effects.


\subsection{Configuration File Format}

The LPRng distribution contains an template {\ttfamily lpd.conf} file
which can be installed as
{\ttfamily /etc/lpd.conf}.
The configuration file has the following format:
\begin{verbatim}
# Default version of the lpd.conf file
# ae=jobend $H $n $P $k $b $t
# allow_getenv
# ar
# architecture
# as=jobstart $H $n $P $k $b $t
# bk_filter_options=$P $w $l $x $y $F $c $L $i $J $C $0n $0h $-a
# bk_of_filter_options=$w $l $x $y
# bl=$-'C:$-'n Job: $-'J Date: $-'t
# check_for_nonprintable
  check_for_nonprintable@
# client_auth_command
...
\end{verbatim}


The file uses the same notation for
\ref{printcapref} {(printcap)}
entries,
but does not use the : (colon) separator.
A line starting with {\ttfamily \#} is a comment.

To change the default value of an option,
remove the comment character and edit the entry.
In the above example,
the default value (1 or TRUE) for
{\ttfamily check\_for\_nonprintable}
has been changed to 0 or off.

To force the {\ttfamily lpd} server to use the new options,
use the {\ttfamily lpc reread} command.

As for printcap entries,
the {\ttfamily \%X} combinations are interpreted when a
configuration entry is used for configuration or defaults,
and can be used to do site and host dependent customization.
This interpolation is done when the default or configuration value
is used in a printcap context.
See
\ref{details} {(Missing Details)} for more
information.

\label{allowgetenv}


\subsection{Obtaining Configuration Information}

The location of the configuration file is compiled into the
LPRng software.
The {\ttfamily config\_file} entry in the compilation defaults
is normally set to search for configuration information in the following
files:
\begin{verbatim}
config_file=/etc/lpd.conf:/usr/etc/lpd.conf
\end{verbatim}


The {\ttfamily lpd.conf} file can be obtained by using a filter.
See
\ref{secnis} {(Using Programs To Get Printcap Information)}
for details.
An example would be:
\begin{verbatim}
config_file=|/usr/local/libexec/get_config
\end{verbatim}


The program will be run in the normal fashion for
LPRng filters; see
\ref{secfilter} {(Filters)} for details.
The STDIN will be attached to {\ttfamily /dev/null},
the configuration information should be written to STDOUT,
and STDERR will be attached to the appropriate log file or error output.

To change any of the {\ttfamily config\_file} specifications,
the the {\ttfamily LPRng/src/common/default.c}
file will need to be modified and the LPRng software recompiled.

In addition,
LPRng has a special {\itshape debug\/} mode.
When compiled with the {\ttfamily -DGET\_ENV} option enabled,
this sets the value of the {\ttfamily allow\_getenv} option to 1.
LPRng can then use the value of the
{\ttfamily LPD\_CONF} environment variable instead of the compiled in
{\ttfamily config\_file} value.
{\bfseries  This is a possible security loophole,
and should not be used when running SETUID ROOT or as ROOT.}
To enable this option,
see the {\ttfamily TESTVERSION} comments in the {\ttfamily  LPRng/src/Makefile}.


\subsection{Useful Configuration Options}

The following variables are used to set default behavior
for the LPRng software,
or are commonly used for configuration of LPRng operations.
\label{defaultformat}


\subsubsection{default\_format}

Default format for printing.
Usually,
{\ttfamily default\_format=f},
but setting it to
{\ttfamily default\_format=l} will cause all files spooled by lpr
to be spooled as binary files.
\label{defaultpermission}


\subsubsection{default\_permission=ACCEPT}

The default permissions to use when checking for printing or other permissions.
\label{defaultpriority}


\subsubsection{default\_priority=A}

The default priority for a print job.
\label{defaultremotehost}


\subsubsection{default\_remote\_host=localhost}

The default {\ttfamily lpd} server host.
\label{defaulttmpdir}


\subsubsection{default\_tmp\_dir=/tmp}

The default directory for temporary files.

This option can be used to specify a default
printer. If no value is given (default), the first printer in the
printcap file will be used when no printer is specified.


\subsubsection{domain\_name=domain.name}

You will only need to set this if LPRng can't determine your
hosts domain name itself.
This is usually a desperation option when DNS or some other
database system is not available.
\label{lpdpermsref}


\section{The /etc/lpd.perms Permissions File}

This file is used to specify the restrictions on the use
of the LPRng software,
printers,
and other facilities.
The following is an example of a {\ttfamily lpd.perms} file.

\begin{verbatim}
# allow root on server to control jobs
ACCEPT SERVICE=C SERVER REMOTEUSER=root
REJECT SERVICE=C
#
# allow same user on originating host to remove a job
ACCEPT SERVICE=M SAMEHOST SAMEUSER
# allow root on server to remove a job
ACCEPT SERVICE=M SERVER REMOTEUSER=root
REJECT SERVICE=M
# all other operations allowed
DEFAULT ACCEPT
\end{verbatim}


The structure of the lpd.perms file was inspired by network
packet filter configuration files.
When the LPD server gets a request from a remote client program,
it performs the checks specified by the rules in the
{\ttfamily lpd.perms}
to decide whether to accept or reject the request.

A rule will ACCEPT or REJECT a request
if all of the patterns specified in the rule match.
If there is a match failure,
the next rule in sequence will be applied.
If all of the rules are exhausted,
then the last specified default authorization will be used.

The sense of a pattern match can be inverted using the NOT keyword.
For example,
the rules with
{\ttfamily ACCEPT NOT USER=john,bill}
succeeds only if USER is defined and the USER value
is not {\ttfamily john} or {\ttfamily bill}.

The following patterns and matching are applied.

\begin{table}[tbp]
\begin{center}
\begin{tabular}{{$|$}l{$|$}l{$|$}}
Keyword& Match\\ 
{\ttfamily DEFAULT}& default result\\ 
{\ttfamily SERVICE}& lpC Status and User, lpR, lprM, lpQ request\\ 
{\ttfamily USER}& user name in print job\\ 
{\ttfamily REMOTEUSER}& user making request\\ 
{\ttfamily HOST}& host name in print job\\ 
{\ttfamily REMOTEHOST}& host making request\\ 
{\ttfamily IP}& IP address and mask of host in print job\\ 
{\ttfamily REMOTEIP}& IP address and mask of host making request\\ 
{\ttfamily PORT}& TCP/IP port of host making request\\ 
{\ttfamily SAMEUSER}& USER and REMOTEUSER same\\ 
{\ttfamily SAMEHOST}& HOST and REMOTEHOST same\\ 
{\ttfamily SERVER}& request originates on lpd server\\ 
{\ttfamily FORWARD}& destination of job is not host\\ 
{\ttfamily GROUP}& USER is in the particular group\\ 
{\ttfamily REMOTEGROUP}& REMOTEUSER is in the particular group\\ 
{\ttfamily CONTROLLINE}& match a line in control file\\ 
{\ttfamily AUTH}& authentication type\\ 
{\ttfamily AUTHUSER}& authenticated user\\ 
{\ttfamily FWDUSER}& authenticated forwarder\\ 
\end{tabular}
\end{center}
\end{table}


Most of the patterns can be lists of alternative values to match,
and can even contain wild cards.
The full details of the rules and keywords are detailed in
the {\ttfamily lpd.conf(5)} man page.


\subsection{Information for matching}

In order to do matching,
the {\ttfamily lpd} server obtains and sets up the following information:
\begin{enumerate}
\item If the request is coming over a network connection,
then the IP address (REMOTEIP)
port (PORT) of the source of the connection and
FQDN of the remote host (REMOTEHOST) are obtained
and the indicated values are set.
\item If the request contains the name of the user,
then REMOTEUSER is assigned the name.
\item If the request contains the name of the printer,
then PRINTER is assigned the name.
\item If a print job is being printed,
then the USER, HOST, and PRINTER are set to the
user name, host, and printer information in the control file for the
print job.
\item If one of the optional authentication methods is being used,
(see
\ref{authref} {(Authentication and Encryption)}),
then AUTH is set to NONE,
USER,
or FWD,
depending on the type of operation and authentication present.
AUTHUSER to the authenticated originating user of the request
and FWDUSER is set to the forwarding servers authentication information
(if any).
\end{enumerate}



\subsection{Permission Checks}

When a connection is made to the {\ttfamily lpd} server,
the originating site's IP address and hostname are determined,
and a check with {\ttfamily SERVICE=X} is made.
The REMOTEHOST,
REMOTEIP,
and PORT will be defined for the purposes of this check.

If the result is to accept the connection,
then the request is then read from the connection,
and the
SERVICE,
REMOTEUSER and PRINTER
will be defined.
A further check is performed to determine if the service request would
be accepted.

While when performing a service activity and a particular job is to
be acted on,
the
USER, HOST, and other control file information will be available,
and a further check can be performed.

If a rule is specified and the particular value is not defined,
then a rull will fail to match.


\subsection{Match Procedure}

\begin{verbatim}
key=pattern                         substring match
key=pattern1,pattern2,pattern3,...  glob and exact
key=IP1/mask1,IP2/mask2,...         IP address
\end{verbatim}


Each of the indicated values is matched against a list of patterns.
The following types of matches are used:
\begin{enumerate}
\item substring match.
The indicated entry is present as a substring in the pattern.
\item GLOB matches.
The pattern is interpreted as a GLOB style pattern,
where * matches 0 or more characters,
and ? matches a single character.
\item Exact string match.
There is no glob matching performed and the strings must match
exactly.
\item IP address match.  The address must be specified in the
standard {\ttfamily nn.nn.nn.nn} format.
The mask must be either an integer number
corresponding to the number of significant bits,
or in the standard {\ttfamily nn.nn.nn.nn} format.
The two addresses are compared by doing
\begin{verbatim}
( IPaddr XOR IP ) AND mask
\end{verbatim}

If the result is 0, then a match results.

\item integer range match.
The pattern has the form {\ttfamily low-high},
where low and high are integer numbers.
The match succeeds if the value is in the specified range.
\end{enumerate}



\subsubsection{DEFAULT}

\begin{verbatim}
DEFAULT ACCEPT
DEFAULT REJECT
\end{verbatim}


The DEFAULT rule specifies the default if no rule matches.
Normally,
there is one DEFAULT entry in a permissions file.
\label{userlpc}


\subsubsection{SERVICE}

Options used:
\begin{itemize}
\item  {\ttfamily user\_lpc=}{\itshape allow set of lpc actions on user files\/}
\end{itemize}


Match type: substring

The SERVICE key is based on the type of request.
\begin{table}[tbp]
\begin{center}
\begin{tabular}{{$|$}l{$|$}l{$|$}}
Key& Request\\ 
{\ttfamily C}& LPC Control Request\\ 
{\ttfamily M}& LPRM Removal Request\\ 
{\ttfamily P}& Job Printing\\ 
{\ttfamily Q}& LPQ Status Request\\ 
{\ttfamily R}& LPR Job Transfer\\ 
{\ttfamily S}& LPC Status Request\\ 
{\ttfamily U}& LPC User File Request\\ 
{\ttfamily X}& Connection Request\\ 
\end{tabular}
\end{center}
\end{table}


Each of the above codes corresponds either directly to the user command,
or a set of subcommands.

All the LPC subcommands are SERVICE=C;
status commands such as {\ttfamily lpc status, printcap, active, }
or {\ttfamily lpd} are SERVICE=S commands as well.

The {\ttfamily user\_lpc} configuration option can be used to specify a
set of control commands that can be applied to individual user files
in a spool queue.
These commands include {\ttfamily user\_lpc=}
{\ttfamily hold},
{\ttfamily release},
{\ttfamily move},
{\ttfamily topq},
{\ttfamily kill},
and
{\ttfamily abort}.
When the {\ttfamily user\_lpc} specifies one of these commands,
the {\ttfamily lpd} program will delay rejecting a request until
the individual files in a queue are checked for permission.
This allows the following permissions line to be used:
\begin{verbatim}
#allow root on server all permissions
ACCEPT SERVICE=C SERVER REMOTEUSER=root
#allow all status commands
ACCEPT SERVICE=S
#allow same user on same host to use user_lpc commands
ACCEPT SERVICE=U SAMEUSER SAMEHOST
#note that this has effect for U only when file checks are performed
REJECT SERVICE=UCS
\end{verbatim}


The above permissions entry will allow users to perform the actions
specified by {\ttfamily user\_lpc} on their files.


\subsubsection{USER}

Match type: GLOB

The USER information is taken from the {\ttfamily P} (person or logname)
information in the print job control file.


\subsubsection{REMOTEUSER}

Match type: GLOB

The REMOTEUSER information is taken from the user information sent
with a service request.

Note that one of the deficiencies of
\ref{rfc1179} {(RFC1179)}
is that an LPQ (print status)
request does provide a REMOTEUSER name.


\subsubsection{HOST}

Match type: GLOB

The HOST information is taken from the {\ttfamily H} (host)
information in the print job control file.


\subsubsection{REMOTEHOST}

Match type: GLOB

The REMOTEHOST information is obtained by doing a reverse IP name lookup
on the remote host address.
If there is no FQDN available,
then the IP address in text form will be used.


\subsubsection{PORT}

Match type: integer range

The PORT value is obtained from the originating port of the TCP/IP
connection.
The match succeeds if it is in the specified range.


\subsubsection{IP}

Match type: IPaddr

The IP information is obtained by doing a DNS lookup on the
H (host) information in the control file.
If there is no host information, the IP address is undefined.


\subsubsection{REMOTEIP}

Match type: IPaddr

The REMOTEIP information is the IP address of the host making the
service request.


\subsubsection{SAMEUSER}

Match type: exact string match

Both the REMOTEUSER and USER information must be present and identical.


\subsubsection{SAMEHOST}

Match type: exact string match on IP addresses

One of the IP addresses found when doing a gethostbyname() lookup for
both HOST and REMOTEHOST must be identical.


\subsubsection{SERVER}

Match type: exact string match on IP addresses

One of the IP addresses of the {\ttfamily lpd} server host
and REMOTEHOST must be identical,
or REMOTEHOST must be {\ttfamily localhost}.


\subsubsection{FORWARD}

Match type: exact string match

Both the REMOTEHOST and HOST information must be present and different.

This is usually the case when the {\ttfamily lpd} server is acting to
forward jobs from a server to a remote printer.


\subsubsection{GROUP}

Match type: modified GLOB

If the pattern does not start with a {\ttfamily @} character,
then the USER information must be present
and the USER must be present in
one of the groups in {\ttfamily /etc/group} or whatever permissions mechanism is used
to determine group ownership
which matches the GLOB pattern.

If the pattern starts with a {\ttfamily @} character,
then the USER information must be present
and the user must be in the specified {\ttfamily netgroup}.
This match will be performed only if the {\ttfamily netgroup}
mechanism is supported on the system and the specified netgroup
exists.
No wildcard match will be done for netgroups.


\subsubsection{REMOTEGROUP}

The same rules as for GROUP,
but using the REMOTEUSER value.


\subsubsection{CONTROLLINE}

Match type: GLOB

A {\ttfamily CONTROLLINE} pattern has the form
\begin{verbatim}
X=pattern1,pattern2,...
\end{verbatim}


X is a single upper case letter.
The corresponding line must be present in a control file,
and the pattern is applied to the line contents.

This pattern can be used to select only files with specific control
file information for printing.


\subsubsection{AUTH}

Match type: GLOB

The AUTH value can be NONE,
indicating that no authentication was done.
If authentication was done,
then AUTH=USER checks to see if there was user information,
and AUTH=FWD checks to see if there was forwarding system identification.


\subsubsection{AUTHUSER}

Match type: GLOB

If AUTH=USER check succeeds,
the AUTHUSER rule will check to see if the user identification
matches the pattern.


\subsubsection{FWDUSER}

Match type: GLOB

If AUTH=FWD check succeeds,
the FWDUSER rule will check to see if the forwarding system identification
matches the pattern.


\subsubsection{IFIP}

Match type: IPmatch, but for IPV6 as well as IPV4

There is a subtle problem with names and IP addresses which are
obtained for 'multi-homed hosts', i.e. - those with multiple
ethernet interfaces,  and for IPV6 (IP Version 6),  in which a host
can have multiple addresses,  and for the normal host which can have
both a short name and a fully qualified domain name.

The IFIP (interface IP) field can be used to check the IP address
of the origination of the request,  as reported by the information
returned by the accept() system call.  Note that this information may
be IPV4 or IPV6 information,  depending on the origination of the
system.  This information is used by gethostbyaddr() to obtain the
originating host fully qualified domain name (FQDN) and set of IP addresses.
Note that this FQDN will be for the originating interface,  and may
not be the cannonical host name.  Some systems which use the Domain Name Server
(DNS) system may add the cannonical system name as an alias.
\label{permspath}
\label{xu}


\subsection{Permission File Location}

Options used:
\begin{itemize}
\item  {\ttfamily perms\_path=}{\itshape  directory path list\/}
\item  {\ttfamily xu=}{\itshape  additional permission file pathname\/}
\end{itemize}


The {\ttfamily perms\_path=} configuration variable specifies the
location of the default permissions file.
The default value is:
\begin{verbatim}
perms_path=/etc/lpd.perms:/usr/etc/lpd.perms
\end{verbatim}


In addition the
{\ttfamily xu}
(extra permissions file) specifies an additional per-printer
permissions file to be used when checking permissions for a particular printer.

The {\ttfamily lpd.perms} file can be obtained by running a program,
in a similar manner to the {\ttfamily /etc/printcap} file.
See
\ref{secfilter} {(Filters)} for details on how
the program would be invoked.
For example, assume the configuration information specified:
\begin{verbatim}
perms_path=|/usr/local/libexec/get_perms
\end{verbatim}


Then the {\ttfamily get\_perms} program would be invoked with STDIN attached
to {\ttfamily /dev/null} and the complete set of permission information
would be read from its STDOUT.


\subsection{Example Permission File}

\begin{verbatim}
# allow root on server to control jobs
ACCEPT SERVICE=C SERVER REMOTEUSER=root
REJECT SERVICE=C
#
# allow same user on originating host to remove a job
ACCEPT SERVICE=M SAMEHOST SAMEUSER
# allow root on server to remove a job
ACCEPT SERVICE=M SERVER REMOTEUSER=root
REJECT SERVICE=M
# all other operations allowed
DEFAULT ACCEPT
\end{verbatim}


In the above sample, we first specify that
lp{\ttfamily C}
commands from user {\ttfamily root} on the lpd server will be accepted.
This is traditionally the way that most lpc commands operate.

Next,  we reject any other lpc requests.

We accept
lpr{\ttfamily M}
requests from the host and user that submitted the job,
as well as from root on the server,
and reject any others.

Finally,
all other types of commands (lpq, lpr) are allowed by default.


\subsection{Complex Permission Checking}

One of the more useful types of permission checking is to
restrict access to your printers from users outside your
networks.
The IP pattern can specify a list of IP addresses and netmasks
to apply to them.

For example
{\ttfamily IP=10.3.4.0/24} would match all hosts with the IP
addresses
{\ttfamily IP=10.3.4.0} to
{\ttfamily IP=10.3.4.255}.

Similarly, the HOST pattern can specify a set of hostnames
or patterns to match against based on the GLOB notation.

For example
{\ttfamily REMOTEHOST=*.astart.com}
would match all hosts with a DNS entry which ended with
{\ttfamily astart.com}.

The NOT keyword reverse the match sense.  For example
{\ttfamily REJECT NOT REMOTEHOST=*.astart.com,*.murpy.com}
would reject all requests from hosts which did not have a DNS entry
ending in
{\ttfamily astart.com}
or
{\ttfamily murphy.com}
as one of the host name components.


\subsection{More Examples}

The following is a more complex lpd.perms file.
\begin{verbatim}
# All operations allowed except those specifically forbidden
DEFAULT ACCEPT
#Reject connections which do not originate from hosts with an
# address on 130.191.0.0 or from localhost,
# or name is not assigned to Engineering pc's
  REJECT SERVICE=X NOT IFIP=130.191.0.0/16,127.0.0.1/32
  REJECT SERVICE=X NOT REMOTEHOST=engpc*
#Do not allow anybody but root or papowell on
#astart1.astart.com or the server to use control
#facilities.
  ACCEPT SERVICE=C SERVER REMOTEUSER=root
  ACCEPT SERVICE=C REMOTEHOST=astart1.astart.com REMOTEUSER=papowell
#Allow root on talker.astart.com to control printer hpjet
  ACCEPT SERVICE=C HOST=talker.astart.com PRINTER=hpjet REMOTEUSER=root
#Reject all others
  REJECT SERVICE=C
#Do not allow forwarded jobs or requests
  REJECT SERVICE=R,C,M FORWARD
# allow same user on originating host to remove a job
ACCEPT SERVICE=M SAMEHOST SAMEUSER
# allow root on server to remove a job
ACCEPT SERVICE=M SERVER REMOTEUSER=root
\end{verbatim}



\section{Running the software}

\label{checkpc}


\subsection{LPRng's little helper: checkpc}

The program {\ttfamily checkpc} (check printcap file) is one of the most
useful utilities in the LPRng package.

It will read all the configuration files, printcap files and tests
whether devices are set up correctly. Optionally, it will also set the
permissions for spool directories and device files. Additionally, it
will truncate the accounting and log files to a maximum size. Another
use for {\ttfamily checkpc} is to remove old entries from queue
directories.

For a new installation, you will want to run
\begin{verbatim}
checkpc -f
\end{verbatim}

to set the permissions right. The {\ttfamily -f} flag instructs the
program to correct file permissions. If you don't run this as
{\ttfamily root}, you'll receive a warning about that fact, and any
{\bfseries chown(2)} calls will (most likely) fail.

The program reports everything it changes. Since it isn't too clever
about some thing (dixit the man page), you should keep an eye on the
output, and if needed, run it again. If it keeps failing, change the
permissions yourself.

These are the permissions of my spool directory:
\begin{verbatim}
drwx--S---   2 lp       lp           1024 Jul 22 21:15 ./
drwxr-xr-x  16 root     root         1024 May 29 21:55 ../
-rw-------   1 lp       lp          10222 Jul 23 05:32 acct
-rw-------   1 lp       lp              0 Feb 14 21:14 control.lp1
-rw-------   1 lp       lp          10229 Jul 23 05:32 log
-rw-------   1 lp       lp              5 Jul 22 21:13 lp1
-rw-------   1 lp       lp           9064 Jul 22 21:15 status.lp1
-rw-------   1 lp       lp              5 Jul 22 21:13 unspooler.lp1
\end{verbatim}


And this is lpd's master directory:
\begin{verbatim}
drwx--S---   2 lp       lp           1024 May 11 18:44 ./
drwxr-xr-x  16 root     root         1024 May 29 21:55 ../
-rw-------   1 lp       lp              0 Feb 18 07:05 lpd.lock.duff
-rw-------   1 lp       lp              3 Jul 13 22:42 lpd.lock.duff.printer
-rw-------   1 lp       lp              0 Apr  1 22:40 lpd.log.duff
\end{verbatim}


Later, you will want to use {\ttfamily checkpc} for the daily
maintenance of your system. I have this line in user {\ttfamily lp}'s
crontab:
\begin{verbatim}
32 5 * * * checkpc -t 10K -A3 -r >/dev/null 2>&1
\end{verbatim}

This job will:
\begin{enumerate}
\item truncate all log and accounting files to 10KB ({\ttfamily -t 10K}).
Actually, it will keep the last 10K from the file, starting on a
complete line.
\item remove all stale files older than three days ({\ttfamily -A3 -r}).
\end{enumerate}

I'm redirecting output to {\ttfamily /dev/null}, because {\ttfamily checkpc}
is a little noisy to my taste. (But too noisy is better than too
silent :)


\subsection{Starting the daemon}

Now comes the moment of truth: will it work? (I hope so, otherwise it
means there are errors here.)
Where should I run the daemon?

In order to work, vanilla LPR needs to be run on all computers on the
network. This is because a job is first transmitted to the local
{\ttfamily lpd}, and then (if needed) to the remote host.

LPRng eliminates the local {\ttfamily lpd} from this chain, and connects
directly to the remote daemon (except in the case of a bounce queue).
Therefore, you won't need to start a daemon on all machines.

In short: where do you need the daemon? Only on those machines where you have
spool directories.
Almost there...

These are the last steps in the installation:
\begin{itemize}
\item Kill your old lpd/lpsched.
\item Start the newly installed lpd program.
\item Print a sample file using the new lpr:
\begin{verbatim}
lpr /etc/printcap
\end{verbatim}
\end{itemize}


If it works, you can remove your old printing software, and change
your system startup files to run the new daemon automatically.

Then, read the rest of the documentation to build whatever complex
configuration you need.
\label{accountingref}


\section{Accounting}

The LPRng method for doing accounting is based on experiences in a
Academic environment,  where avoiding printing accounting procedures
has long been practiced.  While the LPRng procedures are not bombproof,
they do provide a wide range of facilities,  with various degrees
of trust built into them.


\subsection{Printer Accounting Reality Check}

The following was written
by Patrick Powell
{\ttfamily $<$papowell@astart.com{$>$}}
in response to the expressions of frustration
that are periodically vented in the
{\ttfamily \ref{maillist} {(lprng@iona.ie)}}
mailing list.
While this addresses the use of a particular set of printer filters,
i.e. - the
\ref{ifhp} {(CTI-ifhp)}
set,
the comments are appropriate to other issues.

In Academic institutions, avoiding printing accounting has been
regarded as a challenge,  an ongoing game of fat cat and poor starving
mouse, between the Administration and the downtrodden, poor, overcharged
student.  The following is a lighthearted ramble down the dark lane of
printing accounting.

We will disregard the fact that if most students put as much effort
into their studies as in finding ways to avoid accounting procedures
then they would be Rhodes Scholar material,  but I digress...

The accounting procedures put into the LPRng and the hpif filters may
appear to be extraordinarily complex,  but believe me, they are not.
Firstly, we make the assumption that the printer has some sort of
non-volatile page counter mechanism that is reliable and impervious to
power on/off cycles.  Without this mechanism the enterprising student
ummm... user will simply turn off the printer.  Software that prescans
jobs for line counts and pages is notoriously unreliable,  given even
the most modest efforts of users to hide these procedures.   The cost
of running a PostScript simulator simply to do accounting has its
flaws; without ensuring that the simulator has all of the interesting
security loopholes closed, such as opening files, etc.,  it can become
a trap door to hell for the system administrator.

Secondly,  we must make the assumption that the student... uhhh...
user will not be able to tinker with the page counter mechanism, i.e.-
they will not be able to roll back the odometer on the printer, FOR THE
DURATION OF A SINGLE JOB.  I will digress and point out that a student
actualy did this for a challenge;  it only took him a couple of weeks
of study and a fully equipped micrcontroller lab, and two (2) laser
printers which he ruined in the experiment.  HP was not amused when we
sent them back under warranty,  claiming that this our 'normal lab usage.'

Lastly,  you should not mind a small amount of pilferage, or a few
pages here and there being charged to the wrong account.

{\bfseries How Does It Work?}

The basic mechanism the CTI/LPRng filter uses is to record the page
counter value at the start and end of each part of a print job. Each
record has the form:
\begin{verbatim}
start -ppagecounter -Ff -kjob -uuser -hhost -R... 
end  -ppages -qpagecounter -Ff -kjob -uuser -hhost -R...
\end{verbatim}


When we use the OF filter and/or banners,  we will see the
individual jobs bracketed by the OF filter records:
\begin{verbatim}
start -p100 -Fo -kcfA100taco -uuser -hhost -R...  
start -p101 -Ff -kcfA100taco -uuser -hhost -R...  
end  -p1 -q102 -Ff -kcfA100taco -uuser -hhost -R...  
start -p102 -Ff -kcfA100taco -uuser -hhost -R...
end  -p3 -q105 -Ff -kcfA100taco -uuser -hhost -R...  
end  -p5 -q105 -Fo -kcfA100taco -uuser -hhost -R...
\end{verbatim}


It should be clear from the above that all we need to do is to add up
the values for the -Fo (OF) filter lines and we are done.

Unfortunately,  this is too simplistic.  If for some reason the job is
killed or terminates due to error conditions,  the OF filter may not
get to finish its work.  Thus,  we may see the following:
\begin{verbatim}
start -p100 -Fo -kcfA100taco -uuser -hhost -R...  
start -p101 -Ff -kcfA100taco -uuser -hhost -R...  
start -p110 -Fo -kcfA101taco -uuser -hhost -R...
\end{verbatim}


This is a clear indication that the user's job has been terminated.  In
this case we need to use the differences between pagecounters of the start
records to do accounting.

There is a caveat to all of this;  that is the problem of the last dead
job in the list.  If the last line in the accounting file is:
\begin{verbatim}
start -p110 -Fo -kcfA101taco -uuser -hhost -R...
\end{verbatim}

is the last job finished or did it abort?

{\bfseries Who Used Up 2000 Pages of Paper Today?}

Now we move on to the problem of real time accounting.  Due to limited
budgets, etc., many institutions would like to strictly enforce limits
on paper use by students. As jobs are printed their accounts should be
docked for the amount of paper use.  One way to do this is to have an
external accounting procedure update a shared database.  The CTI filter
has provision for a shell script to be called at the end of print job;
this is done by both the OF and IF filter.  Thus, we can blithely
assume that there is a central database carefully getting updates
from the LPRng software, probably from dozens of different printers,
and updating the accounting information.

The first question to be asked is simple:  is this worth it?
Perhaps doing accounting as a batch job once an hour/four times
a day/once a day is cheaper than building an running such a database.
If it costs \$5K/year for the database software, you might just consider
ignoring the 10,000 pages that get lost in the shuffle and use
a simple set of awk/sed/perl scripts to update a database once
an hour.

{\bfseries BAD JOBS - Who Do We Bill?}

We inevitably run into an interesting question:
what happens if a job does not complete correctly?

If you use the completion of the OF filter as a success status, I have
to point out that many students... ummm... users soon find ways to send
jobs to the printer that will cause it to lock up after their output
has been printed. These jobs require power cycling of the printer and
restarting the filter; a bit extreme, perhaps, but it has happened.

I suggest that you simply adopt a 'bill to last user of record'
attitude,  using the pagecount information as follows:
\begin{verbatim}
start OF -- starting point for THIS job
start IF --  nice information, but not useful
start IF --
end   OF -- ending point for this job - can record infomation
start OF --
if no end OF for previous job,  then treat as end OF and
      update accounting.
\end{verbatim}


Now somebody is sure to complain that they got charged for a bunch of
pages that they did not use.  This is inevitable;  always carry a
can of oil for the squeaky wheels.  I might make the observation that
once is accident, twice is coincidence, but three times is malice;
be wary of the constant complainer and check out not only him or her but
also their co-workers.

{\bfseries How Do We Update the Database?}

I suggest that database update be done as follows:

You maintain a 'last page reported' counter for each printer in the
database.  When a successful job reports in,  check to see that\\ 
pagecount + joblength ==  newpagecount;

If this is not the case,  then you have had a some unsuccessful jobs.
In this case I strongly recommend that you have a means to request the
accounting reporting program to go back through the accounting file and
find the last report for the page counter value and try to backtrack
through the accounting files.  The accounting file is one of the first
things to be attacked by students... Ummm...  users.  It should NOT be
kept on an NFS exported or mounted file system.  It should be
carefully pruned and copied, perhaps on an hourly basis.

Now some administrators have fallen in love with network based printers;
do not believe ANYTHING that comes over a network connection without
some form of authentication;  PGP has some very nice Public Key
mechansims for handling this.  This is a major weakness in using a
database for keeping track of accounting - a weak authentication
mechanism may lead to denial of service attacks by students flooding
the database with bogus print usage reports;  suddenly NOBODY can print
and the administrator is driven to turning off accounting.

Good luck.  I am never surprised when I encounter yet another wrinkle in
this area.

Patrick ("You call me a Bean Counter?  Guido,  break this kid's fingers\\ 
~ ~ ~ ~ with an adding machine!") Powell


\subsection{How HP Printers Implement Page Counters}

The following is from
\url{http://www.hp.com/cposupport/printers/support\_doc/bpl02119.html}

{\bfseries HP LaserJet Printer Family - Page Count}

Description Of The Page Count Feature On HP LaserJet 4 Family
Printers

All HP LaserJet 4/5/6 family printers have a page count feature
built into the firmware. However, this feature works differently
depending on which HP LaserJet printer is being used. The following
is a description of how the page count feature works for each
printer within the HP LaserJet 4/5/6 printer families.
\begin{verbatim}
HP LaserJet 4/4M printers
HP LaserJet 4 Plus/4M Plus printers
HP LaserJet 4P/4MP printers
HP LaserJet 4Si/4Si MX printers
HP LaserJet 4ML printers
HP LaserJet 5P/5MP printers
HP LaserJet 6P/6MP printers
\end{verbatim}


All of the above printers use the same method for keeping track of
the number of copies. There are really two different page count
values: Primary and Secondary values. Every time a page is printed,
whether it is an internal job (such as a self-test) or a standard
print job, the Secondary page count increases by one. This value
is stored in standard RAM. Once the Secondary page count value
reaches 10, the Primary page count will increase by 10. The Primary
page count value is stored in a type of memory called NVRAM
(Non-Volatile RAM). This is important, since NVRAM is not cleared
when the printer is powered off. Standard RAM, on the other hand,
is cleared when the printer is turned off or reset. Thus, the
Primary page count only increases in increments of 10.

Example

You have a brand new HP LaserJet 6P printer and you print a self-test
page. When you look on the test page for the Page Count value, you
will see that it says 1. Next, you decide to print a two page letter
and, after that, another self-test. The page count value now says
4. Internally, the printers Secondary page count (stored in RAM)
has the value of 4 while the Primary page count (stored in NVRAM)
still has the value of 0. Now, you turn the printer off, then back
on, and print another self-test. The page count value again says
1 since the previous value of 4, stored in RAM, was cleared when
the printer was powered off. Finally, print a ten page document
and then turn the printer off. Upon turning the printer back on
and printing out another self test, you see that the page count
value is 11.  Internally, the Secondary page count value is back
at 1 while the Primary page count value (stored in NVRAM) is 10.
Added together, you end up with the resulting value seen on the
self-test page.

HP LaserJet 4L/5L/6L Printers

The reason that the page count method for the HP LaserJet 4L/5L/6L
printers differ from that of the other printers is that the HP
LaserJet 4L/5L/6L printers do not have any NVRAM available. Thus,
no way exists for the printer to retain a page count value once
the printer is powered off. The HP LaserJet 4L/5L/6L printers have
only a single page count value that increases in increments of one
until the printer is powered off. At that point, the page count
value is reset and begins from 0 once again.

\label{accountingserver}


\subsection{Accounting Printcap Options}

The accounting facilities are controlled and enabled by the following
entries in the printcap file.  The default value is indicated.

\begin{table}[tbp]
\begin{center}
\begin{tabular}{{$|$}l{$|$}l{$|$}l{$|$}}
Tag& Default Value& Purpose\\ 
af& NULL& accounting file name\\ 
as& "jobstart \$H \$n \$P \$k \$b \$t"& accounting info for job start\\ 
ae& "jobend \$H \$n \$P \$k \$b \$t"& accounting info for job end\\ 
accounting\_server& NULL\\ 
achk& FALSE\\ 
la& TRUE& do accounting for 'local' printer\\ 
ar& FALSE& do accounting for 'remote' transfers\\ 
\end{tabular}
\end{center}
\end{table}





\subsection{Accounting File}

The most common method of accounting is to record the start and end
times of a job and its size to the accounting file. A typical entry
for the printcap defaults are shown below.
\begin{verbatim}
jobstart -H'taco.astart.com' -n'root' -P'ps' -k'cfA938taco.astart.com' \
    -b'1093' -t'Nov  5 19:39:59'
start -p'12942' -k'cfA938taco.astart.com' -n'root' -h'taco.astart.com' -P'ps' \
    -c'0' -F'o' -t'Sun Nov  5 19:39:25 1995'
start -p'12944' -k'cfA938taco.astart.com' -n'root' -h'taco.astart.com' -P'ps' \
    -c'0' -F'f' -t'Sun Nov  5 19:39:27 1995'
end -p'12944' -k'cfA938taco.astart.com' -n'root' -h'taco.astart.com' -P'ps' \
    -b'3' -c'0' -F'f' -t'Sun Nov  5 19:39:58 1995'
end -p'12942' -k'cfA938taco.astart.com' -n'root' -h'taco.astart.com' -P'ps' \
    -b'2' -c'0' -F'o' -t'Sun Nov  5 19:39:59 1995'
jobend -H'taco.astart.com' -n'root' -P'ps' -k'cfA938taco.astart.com' \
    -b'1093' -t'Nov  5 19:39:59'
\end{verbatim}


The {\ttfamily jobstart} and {\ttfamily jobend} lines are added by the LPD server,  as
specified by the {\ttfamily as} and {\ttfamily ae} printcap options;
the -b (byte count) indicates the numbers of bytes in the job.

The {\ttfamily start} and {\ttfamily end}
lines are produced by the filters;
the of filter has an -Fo, and the if filter a -Ff entry.
The filters in the LPRng distribution produce the
indicated output format by default.
The -p value is the current value of a page counter device (if any),
and the -b value indicates the total number of pages used.

It should be clear that a simple AWK or Perl script will be able to
process an accounting file and update accounting information for
accounting purposes;  the usual problems with truncation, time stamps,
etc., are left as an exercise for the system administrator.

Note that the accounting file must exist; LPRng will not create it
(and also will not create the log file).  This prevents accidentally
growing log and accounting files.


\subsection{Remote Server Accounting}

To accommodate even more aggressive and centralized accounting,
a method to make a connection to a print server and send information
to the server has been provided as well.
If {\ttfamily achk} option is set,
it is assumed that the {\ttfamily af} entry specifies a connection to
server on a remote host.
The {\ttfamily lpd} server will send the {\ttfamily as} string to the server,
and then wait for a single line of text from the remote server.
If the first word on the return line is
{\ttfamily accept} or {\ttfamily hold},
the job will be either accepted for printing or held.
Any other value will cause the job to be deleted.

At the end of the job the {\ttfamily ae} string will be sent to the server.
No response is expected.  Example:

\begin{verbatim}
:af=accounting.site.com%2300,tcp
:achk
:as=starting
:ae=ending
\end{verbatim}


The port that the connection originates from will be in the range
set by the configuration or printcap
{\ttfamily \ref{originateport} {(originate\_port)}}
option.


\subsection{Using Filters For Accounting}

Some sites have expressed interest in using a central accounting
mechanism to check that users have permissions.  This can be done by
using the an alternative form of the as (accounting start) and ae
(accounting end) printcap tags.  If the as and ae are filter
specifications,  then a filter is invoked.  If the as (accounting
start) filter returns a non-zero exit status,  then its value
is used to handle the job as indicated by
the
\ref{termination} {(Abnormal Termination)}
codes for filters.
At the end of the job the :ae: filter will be invoked in a similar manner,
but its exit status is ignored.

When using an accounting filter,
the STDIN  is attached (read/write) to the accounting file or remote host
specified by the {\ttfamily af} printcap option,
STDOUT to the output device,
and STDERR to the log file.
The filter program would be invoked with the default filter options.

For example, here is a sample entry to check and update accounting
\begin{verbatim}
printer
   :as=|/usr/local/lib/filters/accounting.pl start
   :ae=|/usr/local/lib/filters/accounting.pl end
\end{verbatim}



\subsection{Accounting Utility accounting.pl}

In order to provide a framework for doing using the outlined accounting
methods,  the LPRng distribution
{\ttfamily UTILS} directory has a {\ttfamily accounting.pl} script.
This script does the following.
\begin{enumerate}
\item It is assumed that the accounting filter is invoked with the
following printcap entry.
The start and end is used by the filter to determine at which point in
the accounting process it is invoked.
\begin{verbatim}
printer
   :as=|/usr/local/lib/filters/accounting.pl start
   :ae=|/usr/local/lib/filters/accounting.pl end
\end{verbatim}
\item It maintains the accounting file as a set of entries in the following format:
\begin{verbatim}
START [job identification]
start -pnn ...
...
end -pnn+pagecount ...
END -ppagecount [job identification]
\end{verbatim}
\item Each time the filter is invoked with the {\ttfamily start}
tags,
it will add a {\ttfamily START} record to the end of the accounting file.
\item When it is invoked with the {\ttfamily end} option,
it will update the accounting file and add an {\ttfamily END} entry.
\item It will handle aborted jobs by looking for jobs with have a {\ttfamily START}
entry and a following {\ttfamily start} line and assuming that they
progressed to the point of starting print operations,
i.e. - the printer page counter was accessed and reported.
It will then look for the next {\ttfamily START} entry with a
following {\ttfamily start} line,
and assume that the pages between the two points were used by the
aborted job.
\end{enumerate}


Administrators can use this script as a starting point for more advanced
accounting.
For example,
rather than just recording the information,
at the job start the script can query either a local database
or a remote server to see if the user has permissions to access the printer.
At the end of the job or when an {\ttfamily END} line is written to the
accounting file,
the local database or remote accounting server can be updated.
\label{authref}


\section{Authentication and Encryption}

One of the major problems in a print spooler system is providing
privacy and authentication services for users.  One method is to
construct a specific set of protocols which will be used for
providing the privacy or authentication;  another is to provide a
simple interface to a set of tools that will do the authentication
and/or encryption.  The LPRng system adopts this latter approach.


\subsection{Authentication}

A careful study of the authentication problem shows that it should be done
during reception of commands and/or jobs from a remote user and/or
spooler.  At this time the following must be done:
\begin{enumerate}
\item The received command must be checked for consistency,  and the
remote user and host must be determined.
\item The remote user and host must be authenticated.
\item The command and/or spooling operation must be carried out.
\item The results must be returned to the remote system.
\end{enumerate}





\subsection{Identifiers}

When a user logs into a system,  they are assigned a user name
and a corresponding UserID.  This user name is used by the LPRng
software when transferring jobs to identify the user.

When we look into the problem of authentication,  we will possibly
have a more global user identification to deal with, the
authentication identifier (AuthID).  One way to deal with this problem is to
give LPRng intimate knowledge of the UserID and AuthID relationship.
While this is possible,  it may be difficult to deal with in a
simple and extensible manner.  An alternate solution is to provide
a mapping service,  where the authentication procedure provides
a map between the UserID and AuthID.




\subsection{RFC1179 Protocol Extensions}

The RFC1179 protocol specifies that a LPD server command sent on
a connection has the form:
\begin{verbatim}
\nnn[additional fields]\n
\end{verbatim}


{\ttfamily $\backslash$nnn} is a one octet (byte) value with the following meaning:

\begin{verbatim}
REQ_START   1    start printer
REQ_RECV    2    transfer a printer job
REQ_DSHORT  3    print short form of queue status
REQ_DLONG   4    print long form of queue status
REQ_REMOVE  5    remove jobs
\end{verbatim}


The LPRng system extends the protocol with the following additional
types:
\begin{verbatim}
REQ_CONTROL 6    do control operation
REQ_BLOCK   7    transfer a block format print job
REQ_SECURE  8    do operation with authentication
\end{verbatim}


The REQ\_CONTROL allows a remote user to send LPC commands to the
server.  The REQ\_BLOCK provides an alternate method to transfer a
job.  Rather than transferring the control and data files individually,
this format transfers one file.  The REQ\_AUTH provides a mechanism
for providing an authentication mechanism and is described in this
document.

\label{useauth}
\label{defaultauth}
\label{remoteuser}
\label{serveruser}
\label{userauthcommand}


\subsection{Client Operations for Client To lpd Server Authentication}

Options used:
\begin{itemize}
\item  {\ttfamily use\_auth=}{\itshape Authentication type\/}
\item  {\ttfamily default\_auth=}{\itshape Default authentication type\/}
\item  {\ttfamily remote\_user=}{\itshape Remote server identification \/}
\item  {\ttfamily server\_user=}{\itshape Server identification\/}
\item  {\ttfamily user\_auth\_command=}{\itshape User to server authentication program\/}
\end{itemize}

\begin{enumerate}
\item First, the {\ttfamily  use\_auth } option is checked to see if it specifies
an authentication type.
If it does, then the {\ttfamily use\_auth} value is used to identify the
type of authentication to be done.
\item If,  by using a command line flag to the {\ttfamily lpr}, {\ttfamily lpq},
etc program,
the user specifies that an authenticated transfer is to be done
and the {\ttfamily use\_auth} value is not set,
then {\ttfamily use\_auth} is set to the {\ttfamily default\_auth} value.
\item If after the above actions {\ttfamily use\_auth} has a value,
then an authenticated transfer will be done.
\item Some sort of identifier specific  to the remote system must be
provided to the authentication facility.
For client to server operations,
the remote system is identified by the
{\ttfamily remote\_user}
and
{\ttfamily server\_user}
printcap option values.
If the {\ttfamily remote\_user} value is not specified, then
it will be set to {\ttfamily server\_user}
(default {\ttfamily daemon}).
As discussed below,
the {\ttfamily server\_user} is usually used to identify the
{\ttfamily lpd} server on an originating host,
but a general form of identification can be used.
\item The {\ttfamily userid} is the value obtained by using the current UID
of the program as the search value for {\ttfamily getpwuid()}.
\item The client will open a connection to the server
and sends a command with the following format:
\begin{verbatim}
\008printer C userid use_auth\n          - for commands
\008printer C userid use_auth controlfilename\n - for print jobs
\end{verbatim}

Note that $\backslash$008 is a one byte code indicating an authenticated
transfer.  Printer is the spool queue name, C in the character 'C'
indicating a client request, userid is the login id of the user,
use\_auth is a keyword identifying the authentication type,
and controlfile name is the name of a controlfile to be transferred.

\item On reception of this command,  the server will send a one byte
success code.
If an error is indicated by a non-zero response,
additional error status may follow
the non-zero success code byte.  At the end of this information
the connection will be terminated.
The values used by LPRng are:
\begin{verbatim}
   ACK_SUCCESS 0   success
   ACK_STOP_Q  1   failed; no spooling to the remote queue
   ACK_RETRY   2   failed; retry later
   ACK_FAIL    3   failed; job rejected, no retry
\end{verbatim}

If the success code is zero, the sender or client will start the
client side authentication program specified by the
{\ttfamily user\_auth\_command} option.
This program will be passed the same options as normal filter
program.
See
\ref{secfilter} {(Filters)} for details.
The authentication program will have the following IO assignments:
\begin{verbatim}
FD  Options Purpose
0  R/W     socket connection to remote host (R/W)
1  W       pipe or file descriptor,  for responses to client
2  W       error log
\end{verbatim}


Command line arguments:
\begin{verbatim}
program -C -Pprinter -nuser -asend_auth -Rremote_user -Ttempfile
\end{verbatim}


The authenticator program can create additional temporary or working
files with the pathnames {\ttfamily tempfile.ext};  these will be deleted
after the authentication process has been completed.

The command line arguments will undergo replacement of \%H and \%R
values.  This means that when authenticating to host {\itshape nowhere.com\/},
a {\ttfamily remote\_user=lpr@\%R} will be expanded to
{\ttfamily remote\_user=lpr@}{\itshape nowhere.com\/}.

\item If the authentication type is for a built-in type,
then the built-in facilities will be used.
Commonly built-in facilities are {\ttfamily kerberos} authentication.
The same actions are carried out.
\item The {\ttfamily  tempfile } will contain either a command line as would be
transferred using the standard RFC1179 protocol,
or a print job in block format.
See
\ref{rfc1179ref} {(RFC1179 Protocol)} for details.
The client authenticator program will open and transfer
the contents of {\ttfamily tempfile} to the server authenticator,
using FD 0
and a format compatible with the underlying authentication mechanism.
If the transfer fails the client
authenticator will log error information on FD 2 and then exit
with error code JFAIL.

\item The server will send the client authentication program
any error or logging information over the FD 0 connection,
in a form appropriate to the authentication operation.
The client authenticator will write this information to FD 1.
If data transfer or authentication fails,  the authenticator
will write an error message to FD 2 and exit with error code
JFAIL
\item If no error has occured the client authenticator will
then exit with error code JSUCC.
\end{enumerate}

\label{serverauthcommand}


\subsection{Server Operations for Client To lpd Server Authentication}

Options used:
\begin{itemize}
\item  {\ttfamily server\_auth\_command=}{\itshape Server (lpd) authentication program\/}
\end{itemize}

\begin{enumerate}
\item When an authentication command arrives at the server,
it has the following form:
\begin{verbatim}
\008printer C userid use_auth\n          - for commands
\008printer C userid use_auth controlfilename\n - for print jobs
\end{verbatim}

The server will decode the various fields,  and set the following permission keys:\\ 
PRINTER={\ttfamily printer}\\ 
USER={\ttfamily user}\\ 
AUTHTYPE={\ttfamily use\_auth}\\ 
AUTH={\ttfamily USER}

\item The server will attempt to find the printcap for the specified printer.
For some operations this printer will be a dummy entry;
this will simply cause the following operations to use the default
information in the {\ttfamily lpd} configuration.
\item If a print job is being performed and the spool queue does not exist,
then the job will be rejected.
A non-zero error code will be written to the connection and the operation
will terminate.
\item If the AUTHTYPE is not built in,
and the {\ttfamily server\_auth\_command} value is not specified,
then authentication will fail.
An error message will be logged to the server log file,
and a non-zero error code and message will be written to the connection
to the remote client program.

\item If the authentication program exists,
a 0 success code is written to the connection
and authentication proceeds.
(Note that the client side of the authentication will use this
as an indication to start the client side authentication program).
\item Many authentication programs require that the
users provide some form of key or identification.
The {\ttfamily server\_user} option is used for this purpose.
If there is no value specified,
{\ttfamily server\_user} is set to the {\ttfamily user}
(default {\ttfamily daemon}) option value.
\item The server will start the server authenticator program and provide the
following open file descriptors for it.  The program
will run as the same UID as the {\ttfamily lpd} server.
If this is a print job transfer,
the current directory will be the spool directory of the print queue.
\begin{verbatim}
FD  Options Purpose
0  R/W     socket connection to remote host (R/W)
1  W       pipe or file descriptor,  for information for server
2  W       error log
3  R       pipe or file descriptor,  for responses to client
\end{verbatim}

Command line arguments:
\begin{verbatim}
program -S -PPRINTER -nUSER -aAUTHTYPE -Rserver_user -Ttempfile
\end{verbatim}


The authenticator can create additional temporary or working
files with the pathnames tempfile.ext;  these will be deleted
after the authentication process has been completed.

\item After performing the necessary authentication operations,
the client side authenticator will transfer a file containing either
commands or a print job to the server side authenticator.
The server authenticator will put this file in the specified
{\ttfamily tempfile}.
In order for the LPRng software to perform permissions checking,
it needs an authenticated identifier for the user.
The server authenticator will write such an identifier to FD 1.
This should be a single line, of a maximum of 127 characters
(LPRng LINEBUFFER maximum size), i.e.:
\begin{verbatim}
authentication_info\n
\end{verbatim}


If the transfer step or authentication fails,  then the server
authenticator
will write an error message to FD 2 and exit with error code
JFAIL.

\item The {\ttfamily lpd} server will record the
authentication information returned by the server in the
AUTHUSER permissions key.
If a print job is being transferred, it will also be stored in the control
file.
This allows job forwarding as is discussed below.

\item The {\ttfamily lpd} server will perform the usual permissions checks,
with the addition of the indicated permission keys and associated values.
During this process,
any error messages or logging information normally returned to client
programs will be written to the authentication program FD 3.
\item The {\ttfamily lpd} server will carry out either the commands or
print job specified in the temporary file.
During this process,
any error messages or logging information normally returned to client
programs will be written to the authentication program FD 3.
\item At the end of the remote servers operations,
the FD 3 file descriptor will be closed and the {\ttfamily lpd} server
will wait for the authentication process to exit.
\item  The server authentication process will read
input from FD 3 until the end of input,
and then transfer the received information to the client
side authenticator.
It may use the tempfile to hold the information during the
reading and transfer process.
If the transfer of the logging information fails,
then the authenticator process will exit with
error code JFAIL, otherwise it will exit with error code JSUCC.

\end{enumerate}

\label{forwardauth}


\subsection{lpd Server to Server Authentication}

Options used:
\begin{itemize}
\item  {\ttfamily forward\_auth=}{\itshape Server forwarding authentication type\/}
\end{itemize}


The Server to Server authentication procedure is used by one server
to forward jobs or commands to another server.  It should be noted
that this forwarding operation puts an implicit trust in the security
of the client to server to server chain.
\begin{enumerate}
\item The {\ttfamily lpd} server will perform an authenticated transfer to
another server when it either needs to transfer a job to a remote printer
or when it needs to propagate a
{\ttfamily lpq},
{\ttfamily lprm},
or
{\ttfamily lprc} operation.
The
\ref{remotesupport} {( {$<$}tt{$>$}remote\_support{$<$}/tt{$>$})}
command can be used to control this forwarding
operation.
\item When propagating a command,
the server uses the authentication information provided for the remote
user by the client to server authentication program.
When propagating or forwarding a job,
the server will use the authentication information stored in the job
control or hold file.
This information will be represented as AUTHUSER in the following discussion.
\item The identification for the sending server and receiving server for the
authentication programs is generated.
For the sending server,
the {\ttfamily server\_user} value is used.
If it is not specified, the {\ttfamily server\_user} value is set to the
{\ttfamily user} (default {\ttfamily daemon}) value.
For the remote server,
the {\ttfamily remote\_user} value is used.
If it is not specified, the {\ttfamily remote\_user} value is set to the
{\ttfamily user} (default {\ttfamily daemon}) value.
\item If there is no user authentication information,
then a normal, non-authenticated transfer will be done.
\item The {\ttfamily server\_auth\_command} will be used for the forwarding
operation.
If it does not have a value,
then a normal, non-authenticated transfer will be done.
\item The sending server takes the part of the client, and will
transfer a job acting similar to a client.  The initial information
transfer from the sending server will have the format:
\begin{verbatim}
\008printer F server_user authtype \n          - for commands
\008printer F server_user authtype controlfilename\n - for print jobs
\end{verbatim}
\item The sending server will invoke its authenticator with the arguments:
\begin{verbatim}
server_auth_command -F -Pprinter -nserver_user -aauthtype \
    -Rremote_user -Ttempfile
\end{verbatim}
\item The tempfile containing the job or command information to be sent
will have the form:
\begin{verbatim}
user_authentication\n
<normal file contents>
\end{verbatim}

That is,
the user authentication information is place in the tempfile.
\item The tempfile will be transferred to the remote server in the same fashion
as for a user job.
Any error or logging information returned will either be written to the
{\ttfamily lpd} log file or to the previous {\ttfamily lpd} process in
the transfer chain.
\item On the destination server the same operations
for receiving an authentication request from a client
is performed.
The USER and AUTHTYPE values will be the derived from the
authentication request {\ttfamily server\_user} and {\ttfamily authtype}
fields in the command sent to the server.
The {\ttfamily server\_user} value is obtained as for client to server
transfers.
The server side authenticator is invoked with the arguments:
\begin{verbatim}
server_auth_command -S -Pprinter -nUSER -aAUTHTYPE \
   -Rremote_user -Ttempfile
\end{verbatim}
\item As for client to server operations,
the authenticator will write the authenticated user name on FD 1,
and the FWDUSER is set to this value.
\item The {\ttfamily lpd} server will remove the first line of the transferred file,
which contains the user authentication information,
and set
AUTHUSER to this value.
\item Authentication is performed using the indicated values.
\item If authentication succeeds,
then the command line or print job control file is processed
in the normal manner.
This might now add more permissions values to tags,
but the authentication information will not be changed.
\end{enumerate}



\subsection{Permission Checking}

The following patterns and values can be used
to check that a particular type of authentication
has been used,
and what the authenticated user information is.
\begin{itemize}
\item AUTH=[NONE,USER,FWD]  - authentication\\ 
Values can be:
\begin{verbatim}
AUTH=NONE     - no authentication
AUTH=USER     - authentication from a client
AUTH=FWD      - forwarded authentication from a lpd server
\end{verbatim}
\item AUTHUSER=globmatch\\ 
For a command received from a client, the value is auth\_user information
returned by the authenticator

For a command received from a server (i.e.- forwarded by a server),
the value is the original auth\_user\_id determined by the remote server.

\item FWDUSER=globmatch\\ 
For a command received from a server (i.e.- forwarded by a server),
the value is the the forwarding servers authentication information.

\end{itemize}


For example,  to reject non-authenticated operations, the following
line could be put in the permissions file.
\begin{verbatim}
REJECT AUTH=NONE
\end{verbatim}


To reject server forwarded authentication as well, we use:
\begin{verbatim}
REJECT AUTH=NONE,FWD
\end{verbatim}


If a remote server has id information FFEDBEEFDEAF,  then the
following will accept only forwarded jobs from this server.  Note
that AUTHUSER will only match on authenticated transfers;
FWDUSER will only match on forwarded transfers.
\begin{verbatim}
ACCEPT FWDUSER=FFEDBEEFDEAF
REJECT AUTH=FWD
\end{verbatim}



\subsection{Using PGP for Authentication}

PGP is a well known encryption and authentication program.
For more details see the web site
\url{http://www.pgp.net}
or the ftp site
\url{ftp://ftp.pgp.net}.


\subsubsection{authenticate\_pgp}

The
{\ttfamily LPRng/src/AUTHENTICATOR/authenticate\_pgp.sh}
program uses the standard {\ttfamily pgp} program and
facilities to do authentication.
It uses the following {\ttfamily pgp} key organization.
\begin{enumerate}
\item Each user should have a private keyring in their home directory,
in the ~/.pgp directory, i.e. - the default used by PGP.
The users public key identification should have the format:
\begin{verbatim}
User Name <userid@host> <userid1@host> ...
\end{verbatim}

{\ttfamily userid} must be the userid used for submitting jobs.
Note that that different userids can be put
into the key string as long as there is one entry for
each userid that the user has.

For example,  suppose that
user John Smith has several accounts on different hosts:
john, jsmith, jsmith1. Then his key should have in it:
\begin{verbatim}
   John Smith <john@whereever> <jsmith@nowhere> <jsmith1@whatever> ...
\end{verbatim}


If the user is daring,  then the pass phrase can be put in the file:
{\ttfamily   \~{}/.pgp/clientkey }.  This file will be read by the
{\ttfamily authenticate\_pgp} script and the contents passed to
PGP as the key.

This file MUST have 0400 permissions (read only by user)
and MUST owned by the user.  This is very dangerous;
but so is setting the PGPPASS environment variable.



\item Each server must have a private keyring for user daemon,
or whatever you run the LPD server as.  This must be in the
in the {\ttfamily \~{}daemon/.pgp} directory, i.e. - the default used by PGP.
The daemon public key identification should have the format:
\begin{verbatim}
daemon_hostname daemon <daemon_hostname@hostname>
\end{verbatim}

In addition,  the pass phrase for the daemon user must be
put in the file
{\ttfamily  \~{}daemon/.pgp/serverkey}.

Note: you may have one daemon user with the same key for ALL
servers, or you may have different ones for different servers.

\item Each user who wants to send jobs to the server must have the
daemons public key on their public keyring.  The server must
have their public key on its public keyring.
\item When a job is submitted,  the server will search for the users
public key using the username submitted by the LPRng client.
This will be the same as their login name.
\item The LPRng software searches the printcap database for the tag
to be used for the server key lookup.  The :server\_user:
value is checked for first;  if it is not found the configuration
user value (default 'daemon') is used.
\end{enumerate}



\subsubsection{Installing authenticate\_pgp}

By default, the
{\ttfamily authenticate\_pgp} script and several helper
programs,  {\ttfamily readfilecount} and {\ttfamily removeoneline},
will be installed in the standard executable locations.


\subsubsection{Printcap/Configuration Modifications}

You must set the following printcap and/or configuration
variable to on.  Note that the printcap keys override the
configuration keys.
\begin{verbatim}
user_auth_command=/usr/local/.../authenticate_pgp
use_auth=pgp
server_auth=pgp
server_user=daemon_id_for_server
pass_env=PGPPASS,PGPPATH
\end{verbatim}


Example printcap entry:
\begin{verbatim}
pr: 
    :lp=pr@wayoff
    :use_auth=pgp
    :server_auth=pgp
    :server_user=daemon_wayoff
\end{verbatim}





\subsubsection{Permissions Modifications:}

If you wish to enforce the use of authentication,  then you
should modify the lpd.perms file.  Here are some examples.
\begin{verbatim}
   # force authentication
   REJECT AUTH=NONE
   # in addition to above,
   # do not accept forwarded authentication
   REJECT AUTH=FWD
   # if the above is too strong,  you can
   # reject forwarded authentication unless from specified server
   # note: U1, U2, etc. are the userids of the remote server
   REJECT AUTH=FWD NOT FWDUSER=U1@*,U2@*,U3@*
   # you can be paranoid and also check to see that that host
   # agrees with the userid reported.
   REJECT AUTH=FWD FWDUSER=U1@host1
\end{verbatim}



\subsubsection{Client/User Configuration}

The user should either have the PGPPASS environment variable defined,
or have in his home directory the file ~/.pgp/clientkey.  This file will
be read by the script and used for the value of the PGPPASS
environment variable.  If neither of these is available,  then the
pgp program will interactively request this information.


\subsubsection{Checking authenticate\_pgp Operation}

\begin{enumerate}
\item In order to use the script in debug mode, you must first create
the user 'daemon' private keys on your private keyring for
testing purposes.
\begin{verbatim}
pgp -kg
    User ID: daemon_test <daemon_test@host>
    Pass phrase: daemon_test
pgp -kg
    User ID: user_test <user_test@host>
    Pass phrase: user_test
\end{verbatim}
\item  Put the pass phrases for daemon\_test in ~/.pgp/serverkey
and the pass phrases for user\_test in ~/.pgp/clientkey
\begin{verbatim}
echo user_test >~/.pgp/serverkey
echo user_test >~/.pgp/clientkey
\end{verbatim}
\item   The first test will ensure that you have the pgp software
installed in an accessible manner.  Execute the script as a user:
\begin{verbatim}
sh authenticate_pgp -D -nuser_test -Rdaemon_test
\end{verbatim}

The output should resemble:
\begin{verbatim}
server PGPPASS daemon_test
ORIGKEY PRaTACFJGcQV92TE6bX72W2JHNNGPRIR7
SERVER AUTH TRANSFERFILE temp.str
398
-----BEGIN PGP MESSAGE-----
Version: 2.6.3i
...
-----END PGP MESSAGE-----
client PGPPASS user_test
\end{verbatim}


If there is an error, an error message will be printed.

\end{enumerate}



\subsubsection{Setting up and Testing Daemon Keys}

The next test will make sure that the daemon user can access its
public and secret keyring when running as user daemon.
\begin{enumerate}
\item As a user, extract your user public key.  As the user do:
\begin{verbatim}
pgp -kxa userid userid_public_key
\end{verbatim}
\item  You should have a user {\ttfamily deamon } with a home directory
that is owned and readable only by
{\ttfamily daemon}.
You do not need a password (logon) capabilities for
{\ttfamily daemon}.
Create the ~daemon/.pgp directory,  and make sure that
it has 0700 permissions.

\item  Use the SU command to run as {\ttfamily daemon}.
The SU command does not update the \$HOME environment variable.
Do the following to set \$HOME:
\begin{verbatim}
export HOME=`eval echo ~daemon`
\end{verbatim}
\item  Create a pgp key for the daemon.  As user daemon do:
the following to create the permanent daemon PGP key
({\ttfamily host} should be the host name for this server).
Set the pass phrase to a suitable value.
Make a note of these values - you will need them later.
\begin{verbatim}
pgp -kg
   User ID: daemon_host <daemon_host@host>
   Pass phrase: ....
\end{verbatim}
\item  Extract the public key for daemon\_host into
a file. As user daemon do:
\begin{verbatim}
pgp -kxa daemon_host daemon_public_key
\end{verbatim}
\item  Add the user's public key to the user daemon public key ring.
The {\ttfamily userid\_public\_key} was created previously.
As daemon do:
\begin{verbatim}
pgp -ka userid_public_key
\end{verbatim}
\item  Add the daemon's public key to the user public key ring.
As user do:
\begin{verbatim}
pgp -ka daemon_public_key  (from step 4.5 above).
\end{verbatim}
\item  As user,
encrypt a message check to see if it can be decoded by daemon.  As user:
\begin{verbatim}
echo hi >/tmp/msg
pgp -seat msg daemon_host -u userid -o /tmp/msg.pgp
chmod 777 /tmp/msg.pgp
\end{verbatim}

As daemon, check to see if you can decode this message.
\begin{verbatim}
pgp /tmp/msg.pgp -o /tmp/msg.dec
diff /tmp/msg /tmp/msg.dec
\end{verbatim}


\item  As user daemon, encode a message for user and see if it can be
decoded by user.  As daemon:
\begin{verbatim}
pgp -seat /tmp/msg.dec userid -o /tmp/msg.pgp -u daemon_host
chmod 777 /tmp/msg.pgp
\end{verbatim}

As user, decode the message for user.
\begin{verbatim}
pgp /tmp/msg.pgp -o /tmp/msg.dec2
diff /tmp/msg.dec2 /tmp/msg
\end{verbatim}


\end{enumerate}



\subsubsection{Testing authenticate\_pgp}

This test will check the actual authentication process carried
out by
{\ttfamily authenticate\_pgp}.
\begin{enumerate}
\item   Compile the
{\ttfamily setupauth}
program
and install it in a temporary location.
Note that
{\ttfamily setupauth}
is not
an installed part of the LPRng distribution, but is a
accessory.
\begin{verbatim}
cd LPRng/src
make setupauth
mv setupauth /tmp/setupauth
\end{verbatim}
\item {\ttfamily setupauth} has the command line:
\begin{verbatim}
setupauth clientid 'client command' serverid 'servercommand'
\end{verbatim}

For example:
\begin{verbatim}
/tmp/setupauth \
   papowell "/bin/ksh -c 'echo CLIENT; printenv ;'" \
   papowell "/bin/ksh -c 'echo SERVER; printenv ;'"
\end{verbatim}


This would display the environment variables set up by
the setupauth program.  This are similar to those used
by LPRng.

\item The LPRng/src/AUTHENTICATE/testauth script has some simple
tests you might want to run.  Uncomment out the
appropriate ones and substitute the appropriate user
name for papowell and daemon.
\begin{verbatim}
#!/bin/sh
user=${USER:-`whoami`}
# show environment variables
#/tmp/setupauth \
#   "${user}" "/bin/ksh -c 'echo CLIENT; printenv ;'" \
#   "${user}" "/bin/ksh -c 'echo SERVER; printenv ;'"
#
#exit 0;
#
# check bidirectionality of data transfer
#  /tmp/setupauth \
#   "${user}" "/bin/ksh -c 'echo CLIENT STARTING SENDING 1>&2; echo hi 1>&0;'" \
#   "${user}" "/bin/ksh -c 'echo SERVER READING; cat ;'" \
# sleep 3;
#  /tmp/setupauth \
#   "${user}" "/bin/ksh -c 'echo CLIENT STARTING READING; cat '" \
#   "${user}" "/bin/ksh -c 'echo SERVER SENDING 1>&2; echo hi 1>&0'"
# 
# check the authenticate pgp operation
#  Note: you can also use
#  'sh -x ./authenticate_pcp ...' to see the detailed actions.
#  Note: you must be root to run the next test.
#
rm /tmp/tempc /tmp/temps
echo Hi $$ >/tmp/tempc
chmod 777 /tmp/tempc
/tmp/setupauth \
    "${user}" './authenticate_pgp -C -n"${user}" -R"${user}" -T/tmp/tempc' \
    "${user}" './authenticate_pgp -S -n"${user}" -R"${user}" -T/tmp/temps'
rm /tmp/tempc /tmp/temps
echo Hi $$ >/tmp/tempc
chmod 777 /tmp/tempc
/tmp/setupauth \
    "${user}" './authenticate_pgp -C -n"${user}" -Rdaemon -T/tmp/tempc' \
    daemon './authenticate_pgp -S -n"${user}" -Rdaemon -T/tmp/temps'
\end{verbatim}
\item You must now SU to ROOT,
as {\ttfamily testauth} needs to run as root to change userids.
As {\ttfamily root},
Set the USER environment variable to the user you desire to simulate and
execute the testauth script.
\begin{verbatim}
USER=myself
/tmp/testauth
\end{verbatim}



\end{enumerate}



\subsubsection{Testing authentication}

\begin{enumerate}
\item Add the following lines to one of the printcap entries:
\begin{verbatim}
:user_auth=pgp
:user_authentication_command=/usr/local/lib/authenticate_pgp
:server_auth=pgp
:server_authentication_command=/usr/local/lib/authenticate_pgp
\end{verbatim}
\item restart the server, using  lpc lpd, to force it to read the
new printcap information.
\item  test the authentication facilities by using lpr to send a job
to the appropriate spool queue.
\end{enumerate}



\subsubsection{Key distribution}

You can distribute the daemon PGP public key fairly easily -
see the PGP documentation for key server information.

Each daemon must have the user's PGP key installed,  or must
in some way get the key from a trusted server.  This is
very site dependent and needs to be done by each site administrator.


\subsection{Using Kerberos for Authentication}

The LPRng
use of Kerberos authentication was
based on the
Kerberos5-1.0 release as of December 20, 1996.  This was obtained
from MIT:
\begin{enumerate}
\item  ftp to ATHENA-DIST.MIT.EDU (18.159.0.42), login anonymous, password
your\_email\_address
\item  Change into the directory '/pub/kerberos/
\item  Get the README files and look at the details of using FTP to get
the distribution.  Note that there are also patches available
which you might want to use.
\end{enumerate}


Note that the distribution has only the most superficial documentation.
There are no man pages for any of the support libraries, etc. etc.
\label{kerberoskeytab}
\label{kerberoslife}
\label{kerberosrenew}
\label{kerberosservice}
\label{kerberosserverprinciple}


\subsubsection{Kerberos Installation Procedure}

\begin{enumerate}
\item  Get the Kerberos 5 distribution.
\item  Compile and install the distribution.
\item  Create the /etc/krb5.conf, /usr/local/var/krb5kdc/kdc.conf
files using templates from the src/conf-files subdirectory.
See the Installation notes and the System Administrators Guide.
\item  Don't forget to create the /usr/local/var/krb5kdc/kdc.acl file;
I did and it took me HOURS to figure out what was wrong...
\item  Start up the KDC and KADMIN servers - you might want to put
the following in your rc.local or equivalent file:
\begin{verbatim}
if [ -f /etc/krb5.conf -a -f /usr/local/var/krb5kdc/kdc.conf  ]; then
    echo -n ' krb5kdc ';    /usr/local/sbin/krb5kdc;
    echo -n ' kadmind ';    /usr/local/sbin/kadmind;
fi
\end{verbatim}
\item  use kadmin (or kadmin.local) to create principals for your users.
\item  Now you need to create principals for the lprng servers.  I have been
using:  lpr/hostname.REALM  as a template-
i.e. lpr/astart1.astart.com@astart.com for an example
Do this for all the servers.  You should use fully qualified domain names
for the principals.

\item  Now you need to extract the keytab for each of the servers:
\begin{verbatim}
kadmin ...
ktadd -k file_for_host  lpr/hostname.REALM
\end{verbatim}

The 'file\_for\_host' contains the keytab information, which is the
equivalent information for the server.

\item  Copy the 'file\_for\_host' to the server (you might want to encrypt
or use a secure transfer for this).  You need to put this in
{\ttfamily /etc/lpd.keytab}.
Make sure that this file is readable only by user {\ttfamily daemon},
as it will try to read the file to get its server key.
\begin{verbatim}
#> ls -l /etc/lpd.keytab
-rw-------  1 daemon  wheel  128 Jan 16 11:06 /etc/lpd.keytab
\end{verbatim}
\item  Add the following entries to lpd.conf:
\begin{verbatim}
use_auth=kerberos
default_auth=kerberos
kerberos_keytab=/etc/lpd.keytab
kerberos_service=lpr
kerberos_life=
kerberos_renew=
\end{verbatim}

The kerberos\_keytab entry is the location of the keytab file;
kerberos\_service is the service that will be used to generate
a server principal name.  This is the "lpr" that
appears in the above operations.

kerberos\_life and kerberos\_renew determine the lifetime and renewability
of Kerberos tickets.  The lifetime defaults to 10
hours,  and the ticket will be refreshed when it expires
if necessary.

\item   You might like to check out the authentication using the sclient and
sserver test programs.  These link in the kerberos authentication and
allow you to test it without all of LPD being involved.
\begin{verbatim}
cd LPRng/src; make sserver sclient
usage: sserver [-D] [-p port] [-s service] [-S keytab] file
   -D turns debugging on
   1. opens TCP   port 'port' (default 1234)
   2. waits for a connection
   3. when a connection comes in,  uses 'service' to get the principal
       name of the server,  and looks up the key in keytab file.
   4. Goes through the kerberos authentication.
   5. Copies the input from remote server to 'file'
   6. exits.
 usage: sclient [-D] [-p port] [-s service] host file
   -D turns debugging on
   1. opens a connection to port on host (i.e. - host%port)
   2. does the authentication.  You must have done kinit to get
       for your ticket to be valid.
   3. sends the file to remote host.
\end{verbatim}

To test this, start up sserver on one host/window, then run sclient.
The error messages are pretty straight forward,
and when in doubt,
look at the source code which has more than sufficient information.

\end{enumerate}



\subsubsection{Testing Transfers}

Restart the server,
and then try getting information using LPQ.

You can turn on tracing at LPQ to see if authentication is being used
and is working:
\begin{verbatim}
lpq -Dnetwork,database 
\end{verbatim}


If the lpq works,
then try send a job and see if the transfer is successful.


\subsubsection{Explicit Server Principal Name}

If you are using printers in different domains,  then you can
put the explicit principal name of the server in the printcap file,
using the server\_principal entry.  For example:
\begin{verbatim}
lp_offsite
    :lp=printer@erehwon.org
    :use_auth=kerberos
    :kerberos_server_principal=lpr/erehwon.org@BLUESKY.ORG
\end{verbatim}

\label{statusref}
\label{stalledtime}


\section{Status Monitoring and Logging}

Options used:
\begin{itemize}
\item {\ttfamily stalled\_time\#}{\itshape time after which to report a stalled active job\/}
\end{itemize}


The most commonly used tool for LPRng status is LPQ.
However,
the LPC command can be used,
and you can also get real time logging of status to a remote host.




\subsection{LPQ status reporting}

The LPQ status display produced by LPRng has three formats.


\subsection{LPQ Short Format (lpq -s)}

This is one line per spool queue:
\begin{verbatim}
% lpq -sa
t1@astart110  (printing disabled) 1 job
t2@astart110  (routed/bounce to t1@astart110.astart.com) 0 jobs
t3@astart110  (forwarding to t3a@astart110.astart.com)
t3a@astart110  (forwarding to t2@astart110.astart.com)
t4@astart110  (subservers t5, t6)  0 jobs
t5@astart110  (serving t4) 0 jobs
t6@astart110  (serving t4) 0 jobs
\end{verbatim}


Note that the name of the printer/host is first,
followed by optional status information, followed by
the number of jobs.  Only printcap entries with
spool queues have a jobs word in the last position.
The
{\ttfamily -a} option forces status for all queues or the
queues in the {\ttfamily all} printcap entry to be returned.

The {\ttfamily stalled\_time} (default 120 seconds) printcap option can be used to set a
time after which active jobs will be reported as stalled.


\subsection{LPQ Long Format (lpq default)}

This is the default status display.
It is a nicely formatted, extremely verbose format
that is suitable for humble human interpretation. For example:
\begin{verbatim}
% lpq -a
Printer: t1@astart110  'Test Printer 1' (printing disabled)
 Queue: 1 printable job
 Server: no server active
 Status: finished operations at 09:44:00
 Rank   Owner/ID                   Class Job  Files               Size Time    
1       papowell@astart110+202228663    A 10663 /tmp/hi               3 20:22:29
Printer: t2@astart110  'Test Printer 2' (routed/bounce to t1@astart110.astart.com)
 Queue: no printable jobs in queue
 Status: finished operations at 16:30:08
Printer: t3@astart110  (forwarding to t3a@astart110.astart.com)
Printer: t3a@astart110  (forwarding to t2@astart110.astart.com)
Printer: t4@astart110  (subservers t5, t6) 
 Queue: no printable jobs in queue
 Status: finished operations at 09:44:06
Server Printer: t5@astart110  (serving t4)
 Queue: no printable jobs in queue
 Status: finished operations at 09:44:06
Server Printer: t6@astart110  (serving t4)
 Queue: no printable jobs in queue
 Status: finished operations at 09:10:00
\end{verbatim}



\subsection{LPQ Verbose Format (lpq -v)}

This uses an extension to the RFC1179 protocol,
and is supported only by LPRng.
The amount of information displayed is the brutal,
and in effect does a total database dump
of the LPD.
This has been developed in order to provide diagnostic
and status information for databases that need to keep track of
job progress through a spool queue.
\begin{verbatim}
% lpq -v
Printer: t1@astart110
 Comment: Test Printer 1
 Printing: no
 Spooling: yes
 Queue: 1 printable job
 Server: no server active
 Status: accounting at end 'papowell@astart110+094352860' at 09:44:00
 Status: printing 'papowell@astart110+094352860', closing device at 09:44:00
 Status: printing 'papowell@astart110+094352860', finished  at 09:44:00
 Status: subserver status 'JSUCC' for 'papowell@astart110+094352860' \
            on attempt 1 at 09:44:00
 Status: finished operations at 09:44:00
 Job: papowell@astart110+202228663 status= 1
 Job: papowell@astart110+202228663 CONTROL=
 - Hastart110.astart.com
 - Ppapowell
 - J/tmp/hi
 - CA
 - Lpapowell
 - Apapowell@astart110+202228663
 - Qt1
 - fdfA010663astart110.astart.com
 - N/tmp/hi
 - UdfA010663astart110.astart.com
 Job: papowell@astart110+202228663 HOLDFILE=
 - active 0
 - done 0
 - hold 0
 - move 0
....
\end{verbatim}



\subsection{lpc status}

The LPC status command is used to show the status of the queues
currently being managed by the LPRng server.
Note that this form of the command is supported only by LPRng,
and is not backwards compatible with BSD LPR implementations.
\begin{verbatim}
%lpc status all
 Printer           Printing Spooling Jobs  Server   Slave Redirect Status/Debug
lw4@astart4         enabled  enabled    0    none    none
lw5@astart4         enabled  enabled    0    none    none
\end{verbatim}


The status display has a heading line and summary of the server status.


\subsection{Remote Logger Operation}

Several sites have wanted a way to provide central logging of job
status and/or information.  In order to do this,  the following functionality
is provided with LPRng.
\label{loggerdestination}
\label{defaultloggerport}
\label{defaultloggerprotocol}


\subsubsection{Logger Network Communication}

Options used:
\begin{itemize}
\item {\ttfamily default\_logger\_port=}{\itshape default destination port for logging information\/}
\item {\ttfamily default\_logger\_protocol=}{\itshape default protocol for logging information\/}
\item {\ttfamily logger\_destination=}{\itshape logger information destination\/}
\end{itemize}


The printcap/configuration variable {\ttfamily logger\_destination} specifies
a destination in the following format:
\begin{verbatim}
host[%port][/(TCP|UPD)]
\end{verbatim}


Host is the destination host, and can be a name or IP address.
Port is the port on the destination host;
if not specified the {\ttfamily default\_logger\_port} (default 2001) is  used.
TCP or UDP is the protocol to be used;
if not specified the {\ttfamily default\_logger\_protocol} (default TCP) is  used.


\subsubsection{Logger Message Format}

Messages are sent to the logger with the following format.
They are written as a single TCP write or UDP message.
\begin{verbatim}
IDENTIFIER id AT timestamp
STATUS | TRACE | FILTER_STATUS PID nnnn
  ... data
.
\end{verbatim}


Examples:
\begin{verbatim}
IDENTIFIER papowell@astart1+560 at Sat Aug 31 08:47:19 1996
STATUS
printing 'cfA560astart1.astart.com', sending trailer
.
IDENTIFIER papowell@astart1+560 at Sat Aug 31 08:47:19 1996
STATUS
accounting at end 'cfA560astart1.astart.com'
.
IDENTIFIER papowell@astart1+560 at Sat Aug 31 08:47:19 1996
STATUS
job 'cfA560astart1.astart.com', closing device
.
IDENTIFIER papowell@astart1+560 at Sat Aug 31 08:47:19 1996
FILTER_STATUS PID 2564
FINISHED
.
IDENTIFIER papowell@astart1+560 at Sat Aug 31 08:47:19 1996
STATUS
job 'cfA560astart1.astart.com' finished
.
IDENTIFIER papowell@astart1+560 at Sat Aug 31 08:47:19 1996
STATUS
subserver status 'SUCCESS' for 'papowell@astart1+560' on attempt 1
.
IDENTIFIER papowell@astart1+560 at Sat Aug 31 08:47:19 1996
TRACE
t1@astart1.astart.com: job printed
.
\end{verbatim}


The IDENTIFIER line reports the job identifier and timestamp
for the following message.  The STATUS, TRACE, and FILTER\_STATUS
messages identify the information that follows.
\label{mail}


\subsubsection{LPR -mhost\%port and user logging support}

The {\ttfamily lpr -m} option is used to request that {\ttfamily lpd}
send mail to the user when a job has completed.
LPRng extends this to allow mail addresses of the form
{\ttfamily  host[\%port][/(TCP$|$UPD)]} to request that logging information
be sent to the user as well.

The administrator should be aware that this is a possible security loophole,
and that the
\label{allowuserlogging}
{\ttfamily allow\_user\_logging}
flag must be enabled to
allow this operation.
\label{rfc1179ref}


\section{RFC 1179 - Line Printer Daemon Protocol}

RFC1179 can be obtained from the LPRng distribution, in the DOC/rfc1179 directory,
or from one of many sites which mirror the RFCs.

This RFC is an {\itshape informational\/} RFC,
which means that the information in it is meant as a guide to users,
and not as a fixed standard.
In addition,
the RFC tried to document the behavior of the BSD LPD print server,
and left out many details dealing with error recover,
error messages,
extensions to the protocol,
etc.

In this section,
I will try to explain what RFC1179 specifies as a protocol,
and many of the problems encountered in trying to use it.
\label{lpdport}
\label{originateport}
\label{reuseaddr}
\label{retryeconnrefused}
\label{retrynolink}
\label{socketlinger}


\subsection{Ports and Connections}

Options used:
\begin{itemize}
\item  {\ttfamily lpd\_port=}{\itshape Port for LPD to accept connection\/}
\item  {\ttfamily originate\_port=}{\itshape Ports to originate connections on\/}
\item  {\ttfamily reuse\_addr}{\itshape ~~Set SO\_REUSEADDR flag on connection\/}
\item  {\ttfamily retry\_econnrefused}{\itshape ~~Retry on connect ECONNREFUSED error\/}
\item  {\ttfamily retry\_nolink}{\itshape ~~Retry on device open or connection ffailure\/}
\item  {\ttfamily socket\_linger\#}{\itshape ~~Linger time for sockets\/}
\end{itemize}


RFC1179 requires that the {\ttfamily lpd} server listen for TCP/IP connections
on port 515.
This port is registered with the Internet Naming Authority,
and the {\ttfamily /etc/services} file or TCP/IP services database usually has an entry:
\begin{verbatim}
printer     515/tcp     spooler     # line printer spooler
\end{verbatim}


RFC1179 explicitly states that all connections to port 515 must originate from
ports 721-731.
The reason for this restriction is due to the UNIX concept of {\itshape reserved\/}
and {\itshape privileged\/} ports.
By convention,
ports in the range 1-1023 can only {\bfseries bound} by processes whose Effective User ID (EUID)
is 0 (root).
This,
ordinary users could not originate a connection from the reserved or privileged port range.

In a UNIX environment,  this means that the user programs
{\ttfamily lpr},
{\ttfamily lprm},
{\ttfamily lpq},
and
{\ttfamily lpc}
would have to be SETUID root.

As experience has shown, for security purposes,
the fewer programs that need to have privileged status,
the better.
LPRng uses the
{\ttfamily lpd\_port=printer} configuration option to set the actual port to be use.
By default, this is port 515, but can be set to other values.

The restriction of originating ports to 721-731 causes another set of problems.
Part of the TCP/IP protocol is concerned with avoiding communications problems
resulting from the arrival of old or {\itshape stale\/} packets.
When a connection between
{\ttfamily sourcehost, sourceport} and {\ttfamily desthost, destport}
is made,
a set of sequence numbers is established and used for sending and acknowledgement of data.
When the connection terminates,
the TCP/IP protocol restricts the establishment of a new connection between
{\ttfamily sourcehost, sourceport} and {\ttfamily desthost, destport} for a period long
enough for all {\itshape stale\/} packets to be removed from the system.
This is approximately 10 minutes long.

In order to simplify assignments of ports,
timing out connections, and other matters,
many TCP/IP packages do keep track of explicit connections
{\itshape originating\/} from a port,
but simply prevent the port from being reused for either origination
or reception of a connection.
They do,
however,
keep track of the active connections {\bfseries to} a port,
and perform timeouts on these.
This is usually much simpler to implement,
as it can be done with a list attached to the port.

This implementation method creates some problems when
a large number of connections must be originated from a
relatively small number of port numbers.
Observe what happens when host 1 tries to send a large number of jobs to a server 2.
The following connections are established and terminated:\\ 
{\ttfamily host 1, port 721} and {\ttfamily host 2, port 515}\\ 
{\ttfamily host 1, port 722} and {\ttfamily host 2, port 515}\\ 
{\ttfamily host 1, port 723} and {\ttfamily host 2, port 515}\\ 
{\ttfamily host 1, port 724} and {\ttfamily host 2, port 515}\\ 
{\ttfamily host 1, port 725} and {\ttfamily host 2, port 515}\\ 
{\ttfamily host 1, port 726} and {\ttfamily host 2, port 515}\\ 
{\ttfamily host 1, port 727} and {\ttfamily host 2, port 515}\\ 
{\ttfamily host 1, port 728} and {\ttfamily host 2, port 515}\\ 
{\ttfamily host 1, port 729} and {\ttfamily host 2, port 515}\\ 
{\ttfamily host 1, port 730} and {\ttfamily host 2, port 515}\\ 
{\ttfamily host 1, port 731} and {\ttfamily host 2, port 515}

Now according to the RFC1179 rules and the TCP/IP protocol,
we will have to wait until one of these connections terminates before we
can make another.
On the system originating system,
if the TCP/IP implementation does timeouts on the originating port,
we will have to wait for the timeout to elapse,
and then we can make a new connection.
Unfortunately,  there is no way to find out what the status of the port
is,  so we will have to try them each in turn until we get
a successful connection.

The LPRng code has tried to provide several methods to deal with
these problems.
Firstly,
the
{\ttfamily originate\_port=512 1023}
option specifies the range
of ports used to originate connections
when the software is running either as ROOT or SETUID root.
By strict RFC1179 rules,
this should be
{\ttfamily originate\_port=721 731},
but it turns out that most BSD LPD based implementations only
check for a {\itshape reserved\/} originating port.
By using 512 ports we get a greatly reduced rate of errors due
to lack of ports due to pending timeouts.

However,
on some systems which are acting as servers for a large number of
printers even increasing this port range is insufficient,
and steps need to be taken use the originating port numbers
more efficiently.
The Berkeley TCP/IP implementation
{\ttfamily getsockopt()}
and
{\ttfamily setsockopt()}
allows the user to manipulate some of the underlying timeouts and options
of the TCP/IP network.
When a TCP/IP connection is established,
the
{\ttfamily setsockopt()}
facility can be used to set the
{\ttfamily SO\_REUSEADDR}
flag on the connection.
This flag effectively sets the timeout value on the ports
and connections to 0,
allowing immediate reuse of the ports.
When done on an originating end of a connection,
this will allow the originating port number to be reused immediately.

It would appear that by setting
{\ttfamily SO\_REUSEADDR}
on the originating end that we have solved our problems.
However,
unless the destination end of the connection sets its
{\ttfamily SO\_REUSEADDR}
flag on the connection,
it will still do a timeout.
Thus when we try to make a connection from a port
that was active within a short period of time to the
same host,
then it will reject the connection until the
timeout is over.

The
{\ttfamily reuse\_addr}
flag (default off) forces
the LPRng software to set the
{\ttfamily SO\_REUSEADDR}
flag on originating connections.
As indicated,
this will allow ports to be reused immediately for outgoing connections,
rather than waiting for a timeout.

While the
{\ttfamily reuse\_addr}
flag usually allows us to reuse ports,
there is still the problem of dealing with connections failing due to the
remote site rejecting the connection due to a pending timeout
from a previous connection.
A careful study of the original BSD TCP/IP network code and of some
others indicates that when a connection fails due to a pending timeout,
an ECONNREFUSED error code is returned to a
{\ttfamily connect()} system call.
If this happens and we suspect that the remote site is rejecting
the connection due to a timeout problem,
then we should retry making the connection but from a new port,
and continue retrying until all possible ports are used.

The {\ttfamily retry\_econnrefused} (default on) flag is used to
specify that we retry connections in this manner.
When this is set,
a {\ttfamily connection refused}
error causes the connection to be retried using a new port.
This will be repeated until all available ports have been tried.

When 
printing a job and the {\ttfamily lpd} server connection to a remote
site or device open fails,
the {\ttfamily retry\_nolink} (default on)
will cause the attempt to be retried indefinately.
The combination of {\ttfamily retry\_econnrefused} and {\ttfamily retry\_nolink}
will provide robust connection attempts to remote systems.

While the above problems cause difficulties when making connections,
there are also problems when terminating connections.
After closing a socket,
the TCP/IP software will try to flush any pending data to the destination.
Unfortunately,
on some systems it will only do this while the process is active.
This has caused problems on systems which terminate
a process it has received an abnormal (signal caused) termination.

The {\ttfamily setsockopt()} SO\_LINGER option allows the user to specify
that when a socket is closed normally,
that the process should block until pending data is flushed or
for the {\ttfamily socket\_linger} period.
If {\ttfamily socket\_linger} is 0,
then no SO\_LINGER operation is done.

In summary, if you experience problems with connection failures due
to port exhaustion,
first try setting the
{\ttfamily reuse\_port} flag,
and you should see a reduction.
Check to ensure that the {\ttfamily retry\_econnrefused}
and {\ttfamily retry\_nolink} flags are set,
and the error code in the log and status files.
If the failures continue,  then the problem is caused by the
remote end having timeout limitations and there is little you
can do except to set a very long {\ttfamily connect\_retry}
interval, say {\ttfamily connect\_retry=120} (2 minutes).
\label{remotesupport}


\subsection{Protocol Requests and Replies}

Options used:
\begin{itemize}
\item  {\ttfamily remote\_support=}{\itshape Remote operations supported\/}
\end{itemize}


After a connection has been established,
a request can be sent to the {\ttfamily lpd}
server.
The request consists of a single octect indicating the request type,
followed by the printer (or print queue) name, followed by
a set of options for the request,
followed by a LF (line feed) character.
\begin{verbatim}
\NNNprinter[ options]\n
  NNN    Operation
\end{verbatim}


\begin{table}[tbp]
\begin{center}
\begin{tabular}{{$|$}l{$|$}l{$|$}l{$|$}l{$|$}}
NNN& RFC1179& Operation& program\\ 
1& yes& start print& {\ttfamily lpc}\\ 
2& yes& transfer a printer job& {\ttfamily lpr}\\ 
3& yes& print short form of queue status& {\ttfamily lpq}\\ 
4& yes& print long form of queue status& {\ttfamily lpq}\\ 
5& yes& remove jobs& {\ttfamily lprm}\\ 
6& LPRng& do control operation& {\ttfamily lpc}\\ 
7& LPRng& transfer a block format print job& {\ttfamily lpr}\\ 
8& LPRng& secure command transfer& {\ttfamily lpc}\\ 
9& LPRng& verbose status information& {\ttfamily lpq}\\ 
\end{tabular}
\end{center}
\end{table}


After the request has been sent,
then a reply will be returned.
In general the reply has the following form:
\begin{verbatim}
\000\n    Success
\NNN\n    Failure (NNN is error code)
text\n    Text or status information
\end{verbatim}


As can be seen,
this protocol is extremely simple,
but there are a set of problems due to the loosely written language of RFC1179.
\begin{enumerate}
\item Firstly,
while RFC1179 sets limits on the lengths of commands,
it does not strictly set limits on the characters set used in the commands.
This can result in problems when trying to print status information,
headers on banners,
and other details.
\item The original RFC1179 protocol did not provide any way to do remote control
of queues or LPD servers.
This has been added to the protocol.
As a side effect,
if you try to use
{\ttfamily lpc} to control a non-LPRng printer,
it will not work.
\item You can specify that a network printer is non-LPRng by using the
{\ttfamily remote\_support=RQVMC} option.
The letters R, Q, V, M, and C stand for
{\ttfamily lpr},
{\ttfamily lpq},
{\ttfamily lpq -v} (verbose),
verbose {\ttfamily lpq},
{\ttfamily lprm},
and {\ttfamily lpc} operations respectively.
If {\ttfamily remote\_support} does not allow a particular operation,
then the LPRng software will not send a corresponding request to the printer.
\end{enumerate}

\label{senddatafirst}
\label{longnumber}
\label{useshorthost}


\subsection{Job Transfer}

Options used:
\begin{itemize}
\item  {\ttfamily longnumber}{\itshape ~~Long job number (6 digits)\/}
\item  {\ttfamily send\_data\_first}{\itshape ~~Send data files first\/}
\item  {\ttfamily use\_shorthost}{\itshape ~~Use short hostname\/}
\end{itemize}


A job transfer operation starts with a job transfer request,
followed by several file transfer operations.
At the end of the file transfers,
the connection should be closed.

A file transfer request has the form:
\begin{table}[tbp]
\begin{center}
\begin{tabular}{{$|$}l{$|$}l{$|$}l{$|$}l{$|$}}
Command& Purpose\\ 
$\backslash$001$\backslash$n& abort\\ 
$\backslash$002nnnn cfname& control file transfer\\ 
$\backslash$003nnnn dfname& data file transfer\\ 
\end{tabular}
\end{center}
\end{table}


The abort operation is used to terminate job transfer and indicate that
the job should not be processed for printing.
The connection will be closed and the partly transferred job
will be discarded.

The control file and data file transfer commands have a length (in bytes)
of the file and the name of the file to be transferred.
When the command is received,
the server will reply with a status line:
\begin{table}[tbp]
\begin{center}
\begin{tabular}{{$|$}l{$|$}l{$|$}l{$|$}l{$|$}}
Status& Purpose\\ 
$\backslash$000& Accepted, proceed\\ 
$\backslash$nnn& Rejected with error code\\ 
\end{tabular}
\end{center}
\end{table}


The reply is only a single octect.
Some defective implementations of RFC1179 send a LF after the octet,
which makes life very difficult to deal with.
LPRng makes efforts to detect these non-conforming RFC1179 systems
and will accept jobs from them.
However,  it will not send jobs to them.

If LPRng sends a reject code, as an extension to RFC1179 it also
sends an error message.   Note that the values for error codes
are not defined,
nor are their causes.
LPRng uses the following values for error codes,
which appear to be compatible with many,
but not all, of the BSD LPD based systems:
\begin{table}[tbp]
\begin{center}
\begin{tabular}{{$|$}l{$|$}l{$|$}l{$|$}l{$|$}}
Code& Error\\ 
$\backslash$000& Accepted, proceed\\ 
$\backslash$001& Queue not accepting jobs\\ 
$\backslash$002& Queue temporarily full, retry later\\ 
$\backslash$003& Bad job format, do not retry\\ 
\end{tabular}
\end{center}
\end{table}


When the sender gets the reply indicating success,
it sends the {\ttfamily nnnn} bytes of the control or data file,
followed by a {\ttfamily $\backslash$000} octet.
The receiver will then reply as above;
a single {\ttfamily $\backslash$000} octet indicating success.

The above procedure is carried out until all data files and the control
file of a job are transferred.

RFC1179 is silent on the following issues:
\begin{enumerate}
\item When sending a job,
do you send the control file first, followed by the data files,
or the data files first?
\item When sending multiple jobs,
can you send them on a single connection,
or do you have to establish a new connection for each job?
\end{enumerate}


LPRng will {\itshape accept\/} jobs whether they are sent control or data files
first.
By default,
it sends the control file first,
followed by the data file.
If the destination system requires that the data files
be sent first,
the {\ttfamily send\_data\_first} printcap option can be used to force
data files to be sent first.

RFC1179 states that:
\begin{quotation}
The name of the control file ... should start with ASCII "cfA", followed by a three
digit job number, followed by the host name which has constructed the
control file.
\end{quotation}


The {\itshape should\/} in this wording indicates that this is simply a guideline,
and that other formats are possible.
Some of the major problems with this format are as follows:
\begin{enumerate}
\item  The restriction to 3 digits means that at most 1000 jobs
can be in a queue.
Strangely,  some systems generate far more than 1000 jobs a day,
and need to archive them on a regular basis.
The {\ttfamily longnumber} option can allows LPRng to use a 6 digit
job number for files in the print queue.
\item The host name format is not specified.
Some implementations consider that this is the short host name,
while others think it is the fully qualified domain name (FQDN).
LPRng,
by default,
will use the FQDN host name.
However,  the {\ttfamily use\_shorthost} option will force it to
use short host names in control and data files.
\item The {\ttfamily cfA} control file name was modified to allow the
job priority to be used as the A letter of the control file.
By default,
this is A (lowest, i.e. {\ttfamily cfA}) and
but can range to Z (highest, i.e. {\ttfamily cfZ}).
All known spoolers except LPRng seem to ignore the actual value of
the letter.
\end{enumerate}



\subsection{Data File Transfer}

As discussed,
a data file is transferred using the command below.
\begin{table}[tbp]
\begin{center}
\begin{tabular}{{$|$}l{$|$}l{$|$}l{$|$}l{$|$}}
Command& Purpose\\ 
$\backslash$003nnnn dfname& data file transfer\\ 
\end{tabular}
\end{center}
\end{table}


From RFC1179:
\begin{quotation}
The data file may contain any 8 bit values at all.  The total number
of bytes in the stream may be sent as the first operand, otherwise
the field should be cleared to 0.  The name of the data file should
start with ASCII "dfA".  This should be followed by a three digit job
number.  The job number should be followed by the host name which has
constructed the data file.  Interpretation of the contents of the
data file is determined by the contents of the corresponding control
file.
\end{quotation}


There are several surprises in RFC1179.
\begin{enumerate}
\item Apparently a job should only consist of a single data file.
This is a severe limitation,  and in fact the BSD LPR and other
print spoolers process jobs with multiple data files.
By convention, these data files have names of the form
{\ttfamily dfA},
{\ttfamily dfB},
...
{\ttfamily dfZ},
{\ttfamily dfa},
{\ttfamily dfz}.
\item The RFC does not specify that the control file and data file job numbers
must be identical.
Most implementations follow this convention, which simplifies life
tremendously.
\item The RFC does not specify that the control file and data file job host names
must be identical.
Most implementations follow this convention, which simplifies life
tremendously.
\item A zero length data file does not cause a data transfer to take place.
LPRng modifies this action to be slightly different.
When a zero length data file transfer is indicated,
all of the input until the connection is closed is used as the
contents of the data file.
When 'piping' into the {\ttfamily lpr} program,
this can be very useful as it eliminates the need to create temporary
files on the senders host.
The the {\ttfamily lpr -k} option for details.
Note that some print spoolers do not use this interpretation,
and this options should be used carefully.

\end{enumerate}



\subsection{Control File Contents}

The control file consists of a set of lines which either provide
printing information or specify data files to be printed.
The information lines start with upper case letters or digits,
while the data files lines start with lower case letters.
Here is a sample control file:
\begin{verbatim}
Hastart4.astart.com
J(stdin)
CA
Lpapowell
Apapowell@astart4+955
Ppapowell
fdfA955astart4.astart.com
N(stdin)
UdfA955astart4.astart.com
\end{verbatim}


The following are the letters and their meanings in the control file.
\begin{table}[tbp]
\begin{center}
\begin{tabular}{{$|$}l{$|$}l{$|$}l{$|$}l{$|$}}
X& RFC1179& Meaning\\ 
A& LPRng& Identifier for job\\ 
C& RFC1179& Class for banner page\\ 
H& RFC1179& Host name\\ 
I& RFC1179& Indent Printing\\ 
J& RFC1179& Job name for banner page\\ 
L& RFC1179& Print banner page\\ 
M& RFC1179& Mail When Printed\\ 
N& RFC1179& Name of source file\\ 
P& RFC1179& User identification\\ 
Q& LPRng& Queue name\\ 
R& LPRng& Accounting info\\ 
S& RFC1179& Symbolic link data\\ 
T& RFC1179& Title for pr\\ 
U& RFC1179& Unlink data file\\ 
W& RFC1179& Width of output\\ 
Z& LPRng& Filter options\\ 
1& RFC1179& troff R font\\ 
2& RFC1179& troff I font\\ 
3& RFC1179& troff B font\\ 
4& RFC1179& troff S font\\ 
c& RFC1179& Plot CIF file\\ 
d& RFC1179& Print DVI file\\ 
f& RFC1179& Print formatted file\\ 
g& RFC1179& Plot file\\ 
k& RFC1179& Reserved for use by Kerberized LPR clients and servers.\\ 
l& RFC1179& Print file leaving control characters\\ 
n& RFC1179& Print ditroff output file\\ 
o& RFC1179& Print Postscript output file\\ 
p& RFC1179& Print file with 'pr' format\\ 
r& RFC1179& File to print with FORTRAN carriage control\\ 
t& RFC1179& Print troff output file\\ 
v& RFC1179& Print raster file\\ 
z& RFC1179& Reserved for future use with the Palladium print system.\\ 
\end{tabular}
\end{center}
\end{table}


The
{\ttfamily A} (Identifier)
line was introduced to record a unique
system wide job identifier for LPRng submitted jobs.
This is basically formed from the user name,
job number, and host at the time of submission.
For example: {\ttfamily papowell@astart4+955}
is job number 995 submitted by papowell from host astart4.

The
{\ttfamily C} (Class)
line is set by the {\ttfamily lpr -C class} option,
and the value can be used to control printing.
For example,
the {\ttfamily lpc class zone } command would restrict job printing to
only jobs with class {\ttfamily zone}.

The
{\ttfamily H} (hostname),
{\ttfamily P} (username),
and
{\ttfamily J} (jobname)
fields are used to identify the host and user which sent the job,
and to provide information to be displayed by {\ttfamily lpq}
when reporting job status.

The
{\ttfamily L} (print banner page) field is one that has caused many
problems for users.
RFC1179 indicates that its presence causes the banner page to be printed,
and its absense suppresses banner pages.
The {\ttfamily lpr -h} option suppresses putting this line into the
control file.
Usually the {\ttfamily L} field is a duplicate of the {\ttfamily P}
field.

The {\ttfamily M} (mail information)
field supplies a mail address for LPRng to send mail to when
a job is completed.
See
\ref{mail} {(LPR -m and user logging)}
for more details.

The {\ttfamily N} (file name) field is usually provided to identify
the file name corresponding to the data file.
This can be used to print names on page separators, etc.
LPRng largely ignores this line.

The
{\ttfamily I} (indent)
and
{\ttfamily W} (width)
fields are supposed to specify a page indent and width for printing.
These fields are passed to filters if they are present.

The {\ttfamily Q} (queue name)
field is an LPRng extension,
and contains the name of the print queue the job was originally sent to.
See
\ref{qq} {(qq printcap option)} for details.

The {\ttfamily R} (accounting info) field was added by LPRng to allow
a specified account to be billed for job printing.
The {\ttfamily lpr -Rname} option can be used to specify the accounting name.

The
{\ttfamily S} (symbolic link)
and
{\ttfamily U} (unlink after printing)
lines were used by the original BSD LPD print system to control
how it passed files to the print server.
LPRng ignores these lines.
In fact, it will remove {\ttfamily S} lines and force the {\ttfamily U}
lines to refer only to job data files.
This closes a nasty security loophole on non-LPRng print spoolers.

The {\ttfamily T} (pr job title) is used with the {\ttfamily lpr -p}
operation to supply a banner to the {\ttfamily pr} program.

The {\ttfamily Z} (filter options) value is specified with
{\ttfamily lpr -Zoption} and is passed to the data file filters
during the printing operation.
See
\ref{secfilter} {(Filters)} for details on how the
this is used during the printing process.

All of the lower case letters are reserved for format specifications for
data files.
In the control file, these are followed by the name of the data file
to which they correspond.
While in principle different data files in the control file can have
different formats,
this has not been implement in any known spooling system.
See
\ref{secfilter} {(Filters)} for details on how the
data file formats are used during the printing process.


\subsection{LPQ Requests}

The RFC1179 protocol specifies that {\ttfamily lpq} print status
requests can be sent to the {\ttfamily lpd} server.
The lpq requests have the format:
\begin{verbatim}
\003printer [id]* \n    short
\004printer [id]* \n    long
\009printer [id]* \n    LPRng extension- verbose
\end{verbatim}


The {\ttfamily lpd} print server will then return queue status
and close the data connection.

RFC1179 does not state in any manner what the format of the queue status
should be.
Thus, implementors have been free to augment or change the status as
they like.
Even the BSD LPR status format has been changed from different versions.

See
\ref{statusref} {(Status Monitoring and Logging)}
for information on the formats returned.

The {\ttfamily id} values are used to select the jobs to be displayed.
LPRng displays any job whose ID, hostname, or user name information
from the control file
{\ttfamily A},
{\ttfamily H},
or
{\ttfamily P} fields match any of the id values.

Note that since there is no identification of the information requestor,
then restriction of information is almost impossible.




\subsection{LPRM Requests}

The RFC1179 protocol specifies that {\ttfamily lprm} job removal
requests can be sent to the {\ttfamily lpd} server.
The lpq requests have the format:
\begin{verbatim}
\003printer user [id]* \n
\end{verbatim}


The {\ttfamily lpd} print server will search the specified print queue
will remove any job whose ID, hostname, or user name information
from the control file
{\ttfamily A},
{\ttfamily H},
or
{\ttfamily P} fields match any of the id values
and for which the user has permission to perform a removal operation.
See the
\ref{lpdpermsref} {(/etc/lpd.perms)} file for details on
permissions.

Most RFC1179 compatible spoolers use the user information in the
request as the name of the user which spooled the job.
However,
in a network environment this is extremely easy to fabricate,
and is at best a weak type of authentication.
\label{lpcreread}


\subsection{LPC Requests}

LPRng has extended the RFC1179 protocol to allow queue and printer control
commands to be sent to the LPD server.
The format of these commands are:

\begin{verbatim}
\006printer user key [options]
\end{verbatim}


The following commands are supported.
\begin{table}[tbp]
\begin{center}
\begin{tabular}{{$|$}l{$|$}l{$|$}l{$|$}l{$|$}}
Command& Operation\\ 
{\ttfamily  active [printer[@host]]}& check to see if server accepting connections\\ 
{\ttfamily  abort   (printer[@host] $|$ all)  }& terminate server process printing job\\ 
{\ttfamily  disable (printer[@host] $|$ all)  }& disable queueing\\ 
{\ttfamily  debug   (printer[@host] $|$ all) debugparms }& set debug level for printer\\ 
{\ttfamily  enable  (printer[@host] $|$ all)  }& enable queueing\\ 
{\ttfamily  hold    (printer[@host] $|$ all) (name[@host] $|$ job $|$ all)* }& hold job\\ 
{\ttfamily  holdall (printer[@host] $|$ all)  }& hold all jobs on\\ 
{\ttfamily  kill    (printer[@host] $|$ all)  }& stop and restart server\\ 
{\ttfamily  lpd [printer[@host]]  }& get LPD PID for server\\ 
{\ttfamily  lpq (printer[@host] $|$ all) (name[@host] $|$ job $|$ all)*     }& invoke LPQ\\ 
{\ttfamily  lprm (printer[@host] $|$ all) (name[@host]$|$host$|$job$|$ all)*  }& invoke LPRM\\ 
{\ttfamily  move printer (user$|$jobid)* target }& move jobs to new queue\\ 
{\ttfamily  noholdall (printer[@host] $|$ all)  }& hold all jobs off\\ 
{\ttfamily  printcap (printer[@host] $|$ all) }& report printcap values\\ 
{\ttfamily  quit                            }& exit LPC\\ 
{\ttfamily  redirect (printer[@host] $|$ all) (printer@host $|$ off )*    }& redirect jobs\\ 
{\ttfamily  release  (printer[@host] $|$ all) (name[@host] $|$ job $|$ all)* }& release job\\ 
{\ttfamily  reread [printer[@host]]}& LPD reread database information\\ 
{\ttfamily  start   (printer[@host] $|$ all)  }& start printing\\ 
{\ttfamily  status  (printer[@host] $|$ all)  }& status of printers\\ 
{\ttfamily  stop    (printer[@host] $|$ all)  }& stop printing\\ 
{\ttfamily  topq    (printer[@host] $|$ all) (name[@host] $|$ job $|$ all)* }& reorder job\\ 
{\ttfamily  defaultq                         }& default queue for LPD server\\ 
\end{tabular}
\end{center}
\end{table}


Many of these commands support extremely specialized operations for
print queue management,
However, the following are the most commonly used and are supported by
the BSD LPD print spooling system as well:
\begin{itemize}
\item {\ttfamily  start, stop, enable, disable }\\ 
 Start and stop will start and stop printing for a specified queue.
Enable and disable enable and disable sending and/or accepting jobs
for the queue.
\item {\ttfamily  abort, kill }\\ 
Abort will cause the process doing the actual job printing to be terminated.
Kill does an abort, and then restarts the printing process.
These commands are used to restart a queue printing after some disaster.
\item {\ttfamily  topq }
Places selected jobs at the top of the print queue.
\item {\ttfamily  status }\\ 
Shows a status display of the print spools on the server.
\end{itemize}


The following commands are extensions to the basic set provided by the
BSD LPD system.
\begin{itemize}
\item {\ttfamily  lpq, lprm }\\ 
Invokes the lpq or lprm program from lpc.
Useful when in the interactive mode.
\item {\ttfamily  hold, holdall, release }\\ 
The hold command will cause the selected jobs to be held until
released.
The holdall jobs sets all jobs submitted to the queue to be held until
released.
The release command releases jobs for printing.
If a job has had an error and is in the error state,
the release command will cause it to be reprinted.
\item {\ttfamily  move, redirect }\\ 
The move command will move selected jobs to the specified spool queue.
The redirect command sends all jobs submitted to the queue to be
sent to the specified queue.
\item {\ttfamily  active, lpd, reread }\\ 
The active command will connect to the server for the printer.
This is used to check to see if non-LPRng print servers are active.
The lpd command will connect to the server and
get the process id (PID) of the {\ttfamily lpd} server.
The reread command causes a SIGHUP signal to be sent to the lpd process,
causing it to reread the
{\ttfamily /etc/lpd.conf},
{\ttfamily /etc/printcap},
or
{\ttfamily /etc/lpd.perms} files.
This is usually done when some important configuration information has
been modified and the administrator wants to have the server use the
new information.
\item {\ttfamily  debug }\\ 
This is a desperation facility for developers that allows dynamic enabling
of debug information generation.
Not normally used in general operation.
\end{itemize}

\label{sendblockformat}
\label{blocktransfer}


\subsection{Block Job Transfer}

Options used:
\begin{itemize}
\item  {\ttfamily send\_block\_format}{\itshape ~~Transfer job as a block\/}
\end{itemize}


In normal job transfer operations,
the sender and receiver have a handshake interaction in order to transfer
a print job.
Each file is sent individually.
The {\ttfamily send\_block\_format} option forces
a Block Job Transfer operation.
This causes the sender to transfer a single file containing all the
job printing information,
including control file and data files.

The transfer command line has the form:
\begin{verbatim}
\006printer user@host size\n
\end{verbatim}


The receiver will return any acknowledgement of a single 0 octet,
and then the size bytes of the job will be transferred by the sender.
At the end of the transfer a single 0 octet is added,
and the receiver will indicate success by returning a single 0 octet.
Any other value returned by the receiver indicates an error condition.

The file transferred by the sender is simply the command lines that it
would have normally sent for job transfer,
followed by the control or data file values.


\subsection{Authenticated Transfer}

RFC1179 does not provide any authentication or encryption mechanism
for the transfer of jobs or commands to the {\ttfamily lpd}
print server.
The Authenticated Transfer operation was added to allow an encrypted
or authenticated transfer of print jobs or commands.

Since there are various restrictions on the incorporation of authentication
facilities into programs,
LPRng supports authentication by providing a simple interface to
encryption programs.

The idea is that when authentication is required when sending a job,
LPRng will generate a block transfer job as described for the
\ref{blocktransfer} {(Block Transfer operation,)}
and then invoke a set of programs to encryt and transfer the file,
and encrypt and transfer the returned status.

Similarly,
when sending a command,
the command information will be placed in a file
and the encrypted file will be transferred.

This technique means that the programs and support to do encryption
are external to LPRng,
and can use any type of method that they choose to implement the
secure and/or authenticated transfer.

See
\ref{authref} {(Authentication and Encryption)}
for details on the authentication interface.


\section{Acknowledgements}

First of all, I'd like to thank Patrick Powell for the abundant
documentation for his package, and for his relentless effort to fix
bugs.

Next, I'd like to thank the proof-readers from the LPRng mailing list,
in particular: Lars Anderson, Bertrand Decouty, Horst Fickenscher,
Philip Griffith, Gordon Haverland, John Perkins, Richard S. Shuford,
James H. Young and the ones I forgot.

Finally,  Patrick would like to thank all of the LPRng users
who so relentlessly tried the incredible number of permutations and
combinations of printers and software,
and made requests for {\itshape just one more feature\/}.

\end{document}
