<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<TITLE> LPRng-HOWTO: RFC 1179 - Line Printer Daemon Protocol</TITLE>
</HEAD>
<BODY>
<A HREF="LPRng-HOWTO-15.html">Next</A>
<A HREF="LPRng-HOWTO-13.html">Previous</A>
<A HREF="LPRng-HOWTO.html#toc14">Contents</A>
<HR>
<H2><A NAME="s14">14. RFC 1179 - Line Printer Daemon Protocol</A></H2>

<P>RFC1179 can be obtained from the LPRng distribution, in the DOC/rfc1179 directory,
or from one of many sites which mirror the RFCs.
<P>This RFC is an <EM>informational</EM> RFC,
which means that the information in it is meant as a guide to users,
and not as a fixed standard.
In addition,
the RFC tried to document the behavior of the BSD LPD print server,
and left out many details dealing with error recover,
error messages,
extensions to the protocol,
etc.
<P>In this section,
I will try to explain what RFC1179 specifies as a protocol,
and many of the problems encountered in trying to use it.
<A NAME="lpdport"></A> 
<A NAME="originateport"></A> 
<A NAME="reuseaddr"></A> 
<A NAME="retryeconnrefused"></A> 
<A NAME="retrynolink"></A> 
<A NAME="socketlinger"></A> <H2><A NAME="ss14.1">14.1 Ports and Connections</A>
</H2>

<P>Options used:
<UL>
<LI> <CODE>lpd_port=</CODE><EM>Port for LPD to accept connection</EM></LI>
<LI> <CODE>originate_port=</CODE><EM>Ports to originate connections on</EM></LI>
<LI> <CODE>reuse_addr</CODE><EM>&nbsp;&nbsp;Set SO_REUSEADDR flag on connection</EM></LI>
<LI> <CODE>retry_econnrefused</CODE><EM>&nbsp;&nbsp;Retry on connect ECONNREFUSED error</EM></LI>
<LI> <CODE>retry_nolink</CODE><EM>&nbsp;&nbsp;Retry on device open or connection ffailure</EM></LI>
<LI> <CODE>socket_linger#</CODE><EM>&nbsp;&nbsp;Linger time for sockets</EM></LI>
</UL>
<P>RFC1179 requires that the <CODE>lpd</CODE> server listen for TCP/IP connections
on port 515.
This port is registered with the Internet Naming Authority,
and the <CODE>/etc/services</CODE> file or TCP/IP services database usually has an entry:
<PRE>
printer     515/tcp     spooler     # line printer spooler
</PRE>
<P>RFC1179 explicitly states that all connections to port 515 must originate from
ports 721-731.
The reason for this restriction is due to the UNIX concept of <EM>reserved</EM>
and <EM>privileged</EM> ports.
By convention,
ports in the range 1-1023 can only <B>bound</B> by processes whose Effective User ID (EUID)
is 0 (root).
This,
ordinary users could not originate a connection from the reserved or privileged port range.
<P>In a UNIX environment,  this means that the user programs
<CODE>lpr</CODE>,
<CODE>lprm</CODE>,
<CODE>lpq</CODE>,
and
<CODE>lpc</CODE>
would have to be SETUID root.
<P>As experience has shown, for security purposes,
the fewer programs that need to have privileged status,
the better.
LPRng uses the
<CODE>lpd_port=printer</CODE> configuration option to set the actual port to be use.
By default, this is port 515, but can be set to other values.
<P>The restriction of originating ports to 721-731 causes another set of problems.
Part of the TCP/IP protocol is concerned with avoiding communications problems
resulting from the arrival of old or <EM>stale</EM> packets.
When a connection between
<CODE>sourcehost, sourceport</CODE> and <CODE>desthost, destport</CODE>
is made,
a set of sequence numbers is established and used for sending and acknowledgement of data.
When the connection terminates,
the TCP/IP protocol restricts the establishment of a new connection between
<CODE>sourcehost, sourceport</CODE> and <CODE>desthost, destport</CODE> for a period long
enough for all <EM>stale</EM> packets to be removed from the system.
This is approximately 10 minutes long.
<P>In order to simplify assignments of ports,
timing out connections, and other matters,
many TCP/IP packages do keep track of explicit connections
<EM>originating</EM> from a port,
but simply prevent the port from being reused for either origination
or reception of a connection.
They do,
however,
keep track of the active connections <B>to</B> a port,
and perform timeouts on these.
This is usually much simpler to implement,
as it can be done with a list attached to the port.
<P>This implementation method creates some problems when
a large number of connections must be originated from a
relatively small number of port numbers.
Observe what happens when host 1 tries to send a large number of jobs to a server 2.
The following connections are established and terminated:<BR>
<CODE>host 1, port 721</CODE> and <CODE>host 2, port 515</CODE><BR>
<CODE>host 1, port 722</CODE> and <CODE>host 2, port 515</CODE><BR>
<CODE>host 1, port 723</CODE> and <CODE>host 2, port 515</CODE><BR>
<CODE>host 1, port 724</CODE> and <CODE>host 2, port 515</CODE><BR>
<CODE>host 1, port 725</CODE> and <CODE>host 2, port 515</CODE><BR>
<CODE>host 1, port 726</CODE> and <CODE>host 2, port 515</CODE><BR>
<CODE>host 1, port 727</CODE> and <CODE>host 2, port 515</CODE><BR>
<CODE>host 1, port 728</CODE> and <CODE>host 2, port 515</CODE><BR>
<CODE>host 1, port 729</CODE> and <CODE>host 2, port 515</CODE><BR>
<CODE>host 1, port 730</CODE> and <CODE>host 2, port 515</CODE><BR>
<CODE>host 1, port 731</CODE> and <CODE>host 2, port 515</CODE>
<P>Now according to the RFC1179 rules and the TCP/IP protocol,
we will have to wait until one of these connections terminates before we
can make another.
On the originating system,
if the TCP/IP implementation does timeouts on the originating port,
we will have to wait for the timeout to elapse before we can make a new
connection.
Unfortunately,  there is no way to find out what the status of the port
is,  so we will have to try them each in turn until we get
a successful connection.
<P>The LPRng code has tried to provide several methods to deal with
these problems.
Firstly,
the
<CODE>originate_port=512 1023</CODE>
option specifies the range
of ports used to originate connections
when the software is running either as ROOT or SETUID root.
By strict RFC1179 rules,
this should be
<CODE>originate_port=721 731</CODE>,
but it turns out that most BSD LPD based implementations only
check for a <EM>reserved</EM> originating port.
By using 512 ports we get a greatly reduced rate of errors due
to lack of ports due to pending timeouts.
<P>However,
on some systems which are acting as servers for a large number of
printers even increasing this port range is insufficient,
and steps need to be taken use the originating port numbers
more efficiently.
The Berkeley TCP/IP implementation
<CODE>getsockopt()</CODE>
and
<CODE>setsockopt()</CODE>
allows the user to manipulate some of the underlying timeouts and options
of the TCP/IP network.
When a TCP/IP connection is established,
the
<CODE>setsockopt()</CODE>
facility can be used to set the
<CODE>SO_REUSEADDR</CODE>
flag on the connection.
This flag effectively sets the timeout value on the ports
and connections to 0,
allowing immediate reuse of the ports.
When done on an originating end of a connection,
this will allow the originating port number to be reused immediately.
<P>It would appear that by setting
<CODE>SO_REUSEADDR</CODE>
on the originating end that we have solved our problems.
However,
unless the destination end of the connection sets its
<CODE>SO_REUSEADDR</CODE>
flag on the connection,
it will still do a timeout.
Thus when we try to make a connection from a port
that was active within a short period of time to the
same host,
then it will reject the connection until the
timeout is over.
<P>The
<CODE>reuse_addr</CODE>
flag (default off) forces
the LPRng software to set the
<CODE>SO_REUSEADDR</CODE>
flag on originating connections.
As indicated,
this will allow ports to be reused immediately for outgoing connections,
rather than waiting for a timeout.
<P>While the
<CODE>reuse_addr</CODE>
flag usually allows us to reuse ports,
there is still the problem of dealing with connections failing due to the
remote site rejecting the connection due to a pending timeout
from a previous connection.
A careful study of the original BSD TCP/IP network code and of some
others indicates that when a connection fails due to a pending timeout,
an ECONNREFUSED error code is returned to a
<CODE>connect()</CODE> system call.
If this happens and we suspect that the remote site is rejecting
the connection due to a timeout problem,
then we should retry making the connection but from a new port,
and continue retrying until all possible ports are used.
<P>The <CODE>retry_econnrefused</CODE> (default on) flag is used to
specify that we retry connections in this manner.
When this is set,
a <CODE>connection refused</CODE>
error causes the connection to be retried using a new port.
This will be repeated until all available ports have been tried.
<P>When 
printing a job and the <CODE>lpd</CODE> server connection to a remote
site or device open fails,
the <CODE>retry_nolink</CODE> (default on)
will cause the attempt to be retried indefinately.
The combination of <CODE>retry_econnrefused</CODE> and <CODE>retry_nolink</CODE>
will provide robust connection attempts to remote systems.
<P>While the above problems cause difficulties when making connections,
there are also problems when terminating connections.
After closing a socket,
the TCP/IP software will try to flush any pending data to the destination.
Unfortunately,
on some systems it will only do this while the process is active.
This has caused problems on systems which terminate
a process it has received an abnormal (signal caused) termination.
<P>The <CODE>setsockopt()</CODE> SO_LINGER option allows the user to specify
that when a socket is closed normally,
that the process should block until pending data is flushed or
for the <CODE>socket_linger</CODE> period.
If <CODE>socket_linger</CODE> is 0,
then no SO_LINGER operation is done.
<P>In summary, if you experience problems with connection failures due
to port exhaustion,
first try setting the
<CODE>reuse_port</CODE> flag,
and you should see a reduction.
Check to ensure that the <CODE>retry_econnrefused</CODE>
and <CODE>retry_nolink</CODE> flags are set,
and the error code in the log and status files.
If the failures continue,  then the problem is caused by the
remote end having timeout limitations and there is little you
can do except to set a very long <CODE>connect_retry</CODE>
interval, say <CODE>connect_retry=120</CODE> (2 minutes).
<A NAME="remotesupport"></A> <H2><A NAME="ss14.2">14.2 Protocol Requests and Replies</A>
</H2>

<P>Options used:
<UL>
<LI> <CODE>remote_support=</CODE><EM>Remote operations supported</EM></LI>
</UL>
<P>After a connection has been established,
a request can be sent to the <CODE>lpd</CODE>
server.
The request consists of a single octet indicating the request type,
followed by the printer (or print queue) name, followed by
a set of options for the request,
followed by a LF (line feed) character.
<PRE>
\NNNprinter[ options]\n
  NNN    Operation
</PRE>
<P>
<CENTER><TABLE BORDER><TR><TD>
<BR>
NNN</TD><TD>RFC1179</TD><TD>Operation</TD><TD>program</TD></TR><TR><TD>
1</TD><TD>yes</TD><TD>start print</TD><TD><CODE>lpc</CODE></TD></TR><TR><TD>
2</TD><TD>yes</TD><TD>transfer a printer job</TD><TD><CODE>lpr</CODE></TD></TR><TR><TD>
3</TD><TD>yes</TD><TD>print short form of queue status</TD><TD><CODE>lpq</CODE></TD></TR><TR><TD>
4</TD><TD>yes</TD><TD>print long form of queue status</TD><TD><CODE>lpq</CODE></TD></TR><TR><TD>
5</TD><TD>yes</TD><TD>remove jobs</TD><TD><CODE>lprm</CODE></TD></TR><TR><TD>
6</TD><TD>LPRng</TD><TD>do control operation</TD><TD><CODE>lpc</CODE></TD></TR><TR><TD>
7</TD><TD>LPRng</TD><TD>transfer a block format print job</TD><TD><CODE>lpr</CODE></TD></TR><TR><TD>
8</TD><TD>LPRng</TD><TD>secure command transfer</TD><TD><CODE>lpc</CODE></TD></TR><TR><TD>
9</TD><TD>LPRng</TD><TD>verbose status information</TD><TD><CODE>lpq</CODE></TD></TR><TR><TD>

</TD></TR></TABLE></CENTER>
<P>After the request has been sent,
then a reply will be returned.
In general the reply has the following form:
<PRE>
\000\n    Success
\NNN\n    Failure (NNN is error code)
text\n    Text or status information
</PRE>
<P>As can be seen,
this protocol is extremely simple,
but there are a set of problems due to the loosely written language of RFC1179.
<OL>
<LI>Firstly,
while RFC1179 sets limits on the lengths of commands,
it does not strictly set limits on the characters set used in the commands.
This can result in problems when trying to print status information,
headers on banners,
and other details.</LI>
<LI>The original RFC1179 protocol did not provide any way to do remote control
of queues or LPD servers.
This has been added to the protocol.
As a side effect,
if you try to use
<CODE>lpc</CODE> to control a non-LPRng printer,
it will not work.</LI>
<LI>You can specify that a network printer is non-LPRng by using the
<CODE>remote_support=RQVMC</CODE> option.
The letters R, Q, V, M, and C stand for
<CODE>lpr</CODE>,
<CODE>lpq</CODE>,
<CODE>lpq -v</CODE> (verbose),
verbose <CODE>lpq</CODE>,
<CODE>lprm</CODE>,
and <CODE>lpc</CODE> operations respectively.
If <CODE>remote_support</CODE> does not allow a particular operation,
then the LPRng software will not send a corresponding request to the printer.</LI>
</OL>

<A NAME="senddatafirst"></A> 
<A NAME="longnumber"></A> 
<A NAME="useshorthost"></A> <H2><A NAME="ss14.3">14.3 Job Transfer</A>
</H2>

<P>Options used:
<UL>
<LI> <CODE>longnumber</CODE><EM>&nbsp;&nbsp;Long job number (6 digits)</EM></LI>
<LI> <CODE>send_data_first</CODE><EM>&nbsp;&nbsp;Send data files first</EM></LI>
<LI> <CODE>use_shorthost</CODE><EM>&nbsp;&nbsp;Use short hostname</EM></LI>
</UL>
<P>A job transfer operation starts with a job transfer request,
followed by several file transfer operations.
At the end of the file transfers,
the connection should be closed.
<P>A file transfer request has the form:
<CENTER><TABLE BORDER><TR><TD>
<BR>
Command</TD><TD>Purpose</TD></TR><TR><TD>
\001\n</TD><TD>abort</TD></TR><TR><TD>
\002nnnn cfname</TD><TD>control file transfer</TD></TR><TR><TD>
\003nnnn dfname</TD><TD>data file transfer</TD></TR><TR><TD>

</TD></TR></TABLE></CENTER>
<P>The abort operation is used to terminate job transfer and indicate that
the job should not be processed for printing.
The connection will be closed and the partly transferred job
will be discarded.
<P>The control file and data file transfer commands have a length (in bytes)
of the file and the name of the file to be transferred.
When the command is received,
the server will reply with a status line:
<CENTER><TABLE BORDER><TR><TD>
<BR>
Status</TD><TD>Purpose</TD></TR><TR><TD>
\000</TD><TD>Accepted, proceed</TD></TR><TR><TD>
\nnn</TD><TD>Rejected with error code</TD></TR><TR><TD>

</TD></TR></TABLE></CENTER>
<P>The reply is only a single octet.
Some defective implementations of RFC1179 send a LF after the octet,
which makes life very difficult.
LPRng makes an effort to detect these non-conforming RFC1179 systems
and will accept jobs from them.
However,  it will not send jobs to them.
<P>If LPRng sends a reject code, as an extension to RFC1179 it also
sends an error message.   Note that the values for error codes
are not defined,
nor are their causes.
LPRng uses the following values for error codes,
which appear to be compatible with many,
but not all, of the BSD LPD based systems:
<CENTER><TABLE BORDER><TR><TD>
<BR>
Code</TD><TD>Error</TD></TR><TR><TD>
\000</TD><TD>Accepted, proceed</TD></TR><TR><TD>
\001</TD><TD>Queue not accepting jobs</TD></TR><TR><TD>
\002</TD><TD>Queue temporarily full, retry later</TD></TR><TR><TD>
\003</TD><TD>Bad job format, do not retry</TD></TR><TR><TD>

</TD></TR></TABLE></CENTER>
<P>When the sender gets the reply indicating success,
it sends the <CODE>nnnn</CODE> bytes of the control or data file,
followed by a <CODE>\000</CODE> octet.
The receiver will then reply as above;
a single <CODE>\000</CODE> octet indicating success.
<P>The above procedure is carried out until all data files and the control
file of a job are transferred.
<P>RFC1179 is silent on the following issues:
<OL>
<LI>When sending a job,
do you send the control file first, followed by the data file(s),
or the data files first?</LI>
<LI>When sending multiple jobs,
can you send them on a single connection,
or do you have to establish a new connection for each job?</LI>
</OL>
<P>LPRng will <EM>accept</EM> jobs whether they are sent control or data files
first.
By default,
it sends the control file first,
followed by the data file.
If the destination system requires that the data files
be sent first,
the <CODE>send_data_first</CODE> printcap option can be used to force
data files to be sent first.
<P>RFC1179 states that:
<BLOCKQUOTE>
The name of the control file ... should start with ASCII "cfA", followed by a three
digit job number, followed by the host name which has constructed the
control file.
</BLOCKQUOTE>
<P>The <EM>should</EM> in this wording indicates that this is simply a guideline,
and that other formats are possible.
Some of the major problems with this format are as follows:
<OL>
<LI> The restriction to 3 digits means that at most 1000 jobs
can be in a queue.
Strangely,  some systems generate far more than 1000 jobs a day,
and need to archive them on a regular basis.
The <CODE>longnumber</CODE> option will allow LPRng to use a 6 digit
job number for files in the print queue.</LI>
<LI>The host name format is not specified.
Some implementations consider that this is the short host name,
while others think it is the fully qualified domain name (FQDN).
LPRng,
by default,
will use the FQDN host name.
However,  the <CODE>use_shorthost</CODE> option will force it to
use short host names in control and data files.</LI>
<LI>The <CODE>cfA</CODE> control file name was modified to allow the
job priority to be used as the A letter of the control file.
By default,
this is A (lowest, i.e. <CODE>cfA</CODE>) and
but can range to Z (highest, i.e. <CODE>cfZ</CODE>).
All known spoolers except LPRng seem to ignore the actual value of
the letter.</LI>
</OL>
<H2><A NAME="ss14.4">14.4 Data File Transfer</A>
</H2>

<P>As discussed,
a data file is transferred using the command below.
<CENTER><TABLE BORDER><TR><TD>
<BR>
Command</TD><TD>Purpose</TD></TR><TR><TD>
\003nnnn dfname</TD><TD>data file transfer</TD></TR><TR><TD>

</TD></TR></TABLE></CENTER>
<P>From RFC1179:
<BLOCKQUOTE>
The data file may contain any 8 bit values at all.  The total number
of bytes in the stream may be sent as the first operand, otherwise
the field should be cleared to 0.  The name of the data file should
start with ASCII "dfA".  This should be followed by a three digit job
number.  The job number should be followed by the host name which has
constructed the data file.  Interpretation of the contents of the
data file is determined by the contents of the corresponding control
file.
</BLOCKQUOTE>
<P>There are several surprises in RFC1179.
<OL>
<LI>Apparently a job should only consist of a single data file.
This is a severe limitation,  and in fact the BSD LPR and other
print spoolers process jobs with multiple data files.
By convention, these data files have names of the form
<CODE>dfA</CODE>,
<CODE>dfB</CODE>,
...
<CODE>dfZ</CODE>,
<CODE>dfa</CODE>,
<CODE>dfz</CODE>.</LI>
<LI>The RFC does not specify that the control file and data file job numbers
must be identical.
Most implementations follow this convention, which simplifies life
tremendously.</LI>
<LI>The RFC does not specify that the control file and data file job host names
must be identical.
Most implementations follow this convention, which simplifies life
tremendously.</LI>
<LI>A zero length data file does not cause a data transfer to take place.
LPRng modifies this action to be slightly different.
When a zero length data file transfer is indicated,
all of the input until the connection is closed is used as the
contents of the data file.
<P>When 'piping' into the <CODE>lpr</CODE> program,
this can be very useful as it eliminates the need to create temporary
files on the senders host.
The <CODE>lpr -k</CODE> option for details.
Note that some print spoolers do not use this interpretation,
and this option should be used carefully.
</LI>
</OL>
<H2><A NAME="ss14.5">14.5 Control File Contents</A>
</H2>

<P>The control file consists of a set of lines which either provide
printing information or specify data files to be printed.
The information lines start with upper case letters or digits,
while the data files lines start with lower case letters.
Here is a sample control file:
<PRE>
Hastart4.astart.com
J(stdin)
CA
Lpapowell
Apapowell@astart4+955
Ppapowell
fdfA955astart4.astart.com
N(stdin)
UdfA955astart4.astart.com
</PRE>
<P>The following are the letters and their meanings in the control file.
<CENTER><TABLE BORDER><TR><TD>
<BR>
X</TD><TD>RFC1179</TD><TD>Meaning</TD></TR><TR><TD>
A</TD><TD>LPRng</TD><TD>Identifier for job</TD></TR><TR><TD>
C</TD><TD>RFC1179</TD><TD>Class for banner page</TD></TR><TR><TD>
H</TD><TD>RFC1179</TD><TD>Host name</TD></TR><TR><TD>
I</TD><TD>RFC1179</TD><TD>Indent Printing</TD></TR><TR><TD>
J</TD><TD>RFC1179</TD><TD>Job name for banner page</TD></TR><TR><TD>
L</TD><TD>RFC1179</TD><TD>Print banner page</TD></TR><TR><TD>
M</TD><TD>RFC1179</TD><TD>Mail When Printed</TD></TR><TR><TD>
N</TD><TD>RFC1179</TD><TD>Name of source file</TD></TR><TR><TD>
P</TD><TD>RFC1179</TD><TD>User identification</TD></TR><TR><TD>
Q</TD><TD>LPRng</TD><TD>Queue name</TD></TR><TR><TD>
R</TD><TD>LPRng</TD><TD>Accounting info</TD></TR><TR><TD>
S</TD><TD>RFC1179</TD><TD>Symbolic link data</TD></TR><TR><TD>
T</TD><TD>RFC1179</TD><TD>Title for pr</TD></TR><TR><TD>
U</TD><TD>RFC1179</TD><TD>Unlink data file</TD></TR><TR><TD>
W</TD><TD>RFC1179</TD><TD>Width of output</TD></TR><TR><TD>
Z</TD><TD>LPRng</TD><TD>Filter options</TD></TR><TR><TD>
1</TD><TD>RFC1179</TD><TD>troff R font</TD></TR><TR><TD>
2</TD><TD>RFC1179</TD><TD>troff I font</TD></TR><TR><TD>
3</TD><TD>RFC1179</TD><TD>troff B font</TD></TR><TR><TD>
4</TD><TD>RFC1179</TD><TD>troff S font</TD></TR><TR><TD>
c</TD><TD>RFC1179</TD><TD>Plot CIF file</TD></TR><TR><TD>
d</TD><TD>RFC1179</TD><TD>Print DVI file</TD></TR><TR><TD>
f</TD><TD>RFC1179</TD><TD>Print formatted file</TD></TR><TR><TD>
g</TD><TD>RFC1179</TD><TD>Plot file</TD></TR><TR><TD>
k</TD><TD>RFC1179</TD><TD>Reserved for use by Kerberized LPR clients and servers.</TD></TR><TR><TD>
l</TD><TD>RFC1179</TD><TD>Print file leaving control characters</TD></TR><TR><TD>
n</TD><TD>RFC1179</TD><TD>Print ditroff output file</TD></TR><TR><TD>
o</TD><TD>RFC1179</TD><TD>Print Postscript output file</TD></TR><TR><TD>
p</TD><TD>RFC1179</TD><TD>Print file with 'pr' format</TD></TR><TR><TD>
r</TD><TD>RFC1179</TD><TD>File to print with FORTRAN carriage control</TD></TR><TR><TD>
t</TD><TD>RFC1179</TD><TD>Print troff output file</TD></TR><TR><TD>
v</TD><TD>RFC1179</TD><TD>Print raster file</TD></TR><TR><TD>
z</TD><TD>RFC1179</TD><TD>Reserved for future use with the Palladium print system.</TD></TR><TR><TD>

</TD></TR></TABLE></CENTER>
<P>The
<CODE>A</CODE> (Identifier)
line was introduced to record a unique
system wide job identifier for LPRng submitted jobs.
This is basically formed from the user name,
job number, and host at the time of submission.
For example: <CODE>papowell@astart4+955</CODE>
is job number 995 submitted by papowell from host astart4.
<P>The
<CODE>C</CODE> (Class)
line is set by the <CODE>lpr -C class</CODE> option,
and the value can be used to control printing.
For example,
the <CODE>lpc class zone </CODE> command would restrict job printing to
only jobs with class <CODE>zone</CODE>.
<P>The
<CODE>H</CODE> (hostname),
<CODE>P</CODE> (username),
and
<CODE>J</CODE> (jobname)
fields are used to identify the host and user which sent the job,
and to provide information to be displayed by <CODE>lpq</CODE>
when reporting job status.
<P>The
<CODE>L</CODE> (print banner page) field is one that has caused many
problems for users.
RFC1179 indicates that its presence causes the banner page to be printed,
and its absense suppresses banner pages.
The <CODE>lpr -h</CODE> option suppresses putting this line into the
control file.
Usually the <CODE>L</CODE> field is a duplicate of the <CODE>P</CODE>
field.
<P>The <CODE>M</CODE> (mail information)
field supplies a mail address for LPRng to send mail to when
a job is completed.
See
<A HREF="LPRng-HOWTO-13.html#mail">LPR -m and user logging</A>
for more details.
<P>The <CODE>N</CODE> (file name) field is usually provided to identify
the file name corresponding to the data file.
This can be used to print names on page separators, etc.
LPRng largely ignores this line.
<P>The
<CODE>I</CODE> (indent)
and
<CODE>W</CODE> (width)
fields are supposed to specify a page indent and width for printing.
These fields are passed to filters if they are present.
<P>The <CODE>Q</CODE> (queue name)
field is an LPRng extension,
and contains the name of the print queue the job was originally sent to.
See
<A HREF="LPRng-HOWTO-5.html#qq">qq printcap option</A> for details.
<P>The <CODE>R</CODE> (accounting info) field was added by LPRng to allow
a specified account to be billed for job printing.
The <CODE>lpr -Rname</CODE> option can be used to specify the accounting name.
<P>The
<CODE>S</CODE> (symbolic link)
and
<CODE>U</CODE> (unlink after printing)
lines were used by the original BSD LPD print system to control
how it passed files to the print server.
LPRng ignores these lines.
In fact, it will remove <CODE>S</CODE> lines and force the <CODE>U</CODE>
lines to refer only to job data files.
This closes a nasty security loophole on non-LPRng print spoolers.
<P>The <CODE>T</CODE> (pr job title) is used with the <CODE>lpr -p</CODE>
operation to supply a banner to the <CODE>pr</CODE> program.
<P>The <CODE>Z</CODE> (filter options) value is specified with
<CODE>lpr -Zoption</CODE> and is passed to the data file filters
during the printing operation.
See
<A HREF="LPRng-HOWTO-5.html#secfilter">Filters</A> for details on how the
this is used during the printing process.
<P>All of the lower case letters are reserved for format specifications for
data files.
In the control file, these are followed by the name of the data file
to which they correspond.
While in principle different data files in the control file can have
different formats,
this has not been implemented in any known spooling system.
See
<A HREF="LPRng-HOWTO-5.html#secfilter">Filters</A> for details on how the
data file formats are used during the printing process.
<H2><A NAME="ss14.6">14.6 LPQ Requests</A>
</H2>

<P>The RFC1179 protocol specifies that <CODE>lpq</CODE> print status
requests can be sent to the <CODE>lpd</CODE> server.
The lpq requests have the format:
<PRE>
\003printer [id]* \n    short
\004printer [id]* \n    long
\009printer [id]* \n    LPRng extension- verbose
</PRE>
<P>The <CODE>lpd</CODE> print server will then return queue status
and close the data connection.
<P>RFC1179 does not state in any manner what the format of the queue status
should be.
Thus, implementors have been free to augment or change the status as
they like.
Even the BSD LPR status format has been changed from different versions.
<P>See
<A HREF="LPRng-HOWTO-12.html#statusref">Status Monitoring and Logging</A>
for information on the formats returned.
<P>The <CODE>id</CODE> values are used to select the jobs to be displayed.
LPRng displays any job whose ID, hostname, or user name information
from the control file
<CODE>A</CODE>,
<CODE>H</CODE>,
or
<CODE>P</CODE> fields match any of the id values.
<P>Note that since there is no identification of the information requestor,
then restriction of information is almost impossible.
<P>
<H2><A NAME="ss14.7">14.7 LPRM Requests</A>
</H2>

<P>The RFC1179 protocol specifies that <CODE>lprm</CODE> job removal
requests can be sent to the <CODE>lpd</CODE> server.
The lpq requests have the format:
<PRE>
\003printer user [id]* \n
</PRE>
<P>The <CODE>lpd</CODE> print server will search the specified print queue
and remove any job whose ID, hostname, or user name information
from the control file
<CODE>A</CODE>,
<CODE>H</CODE>,
or
<CODE>P</CODE> fields match any of the id values
and for which the user has permission to perform a removal operation.
See the
<A HREF="LPRng-HOWTO-8.html#lpdpermsref">/etc/lpd.perms</A> file for details on
permissions.
<P>Most RFC1179 compatible spoolers use the user information in the
request as the name of the user which spooled the job.
However,
in a network environment this is extremely easy to fabricate,
and is at best a weak type of authentication.
<A NAME="lpcreread"></A> <H2><A NAME="ss14.8">14.8 LPC Requests</A>
</H2>

<P>LPRng has extended the RFC1179 protocol to allow queue and printer control
commands to be sent to the LPD server.
The format of these commands are:
<P>
<PRE>
\006printer user key [options]
</PRE>
<P>The following commands are supported.
<CENTER><TABLE BORDER><TR><TD>
<BR>
Command</TD><TD>Operation</TD></TR><TR><TD>
<CODE> active [printer[@host]]</CODE></TD><TD>check to see if server accepting connections</TD></TR><TR><TD>
<CODE> abort   (printer[@host] | all)  </CODE></TD><TD>terminate server process printing job</TD></TR><TR><TD>
<CODE> disable (printer[@host] | all)  </CODE></TD><TD>disable queueing</TD></TR><TR><TD>
<CODE> debug   (printer[@host] | all) debugparms </CODE></TD><TD>set debug level for printer</TD></TR><TR><TD>
<CODE> enable  (printer[@host] | all)  </CODE></TD><TD>enable queueing</TD></TR><TR><TD>
<CODE> hold    (printer[@host] | all) (name[@host] | job | all)* </CODE></TD><TD>hold job</TD></TR><TR><TD>
<CODE> holdall (printer[@host] | all)  </CODE></TD><TD>hold all jobs on</TD></TR><TR><TD>
<CODE> kill    (printer[@host] | all)  </CODE></TD><TD>stop and restart server</TD></TR><TR><TD>
<CODE> lpd [printer[@host]]  </CODE></TD><TD>get LPD PID for server</TD></TR><TR><TD>
<CODE> lpq (printer[@host] | all) (name[@host] | job | all)*     </CODE></TD><TD>invoke LPQ</TD></TR><TR><TD>
<CODE> lprm (printer[@host] | all) (name[@host]|host|job| all)*  </CODE></TD><TD>invoke LPRM</TD></TR><TR><TD>
<CODE> move printer (user|jobid)* target </CODE></TD><TD>move jobs to new queue</TD></TR><TR><TD>
<CODE> noholdall (printer[@host] | all)  </CODE></TD><TD>hold all jobs off</TD></TR><TR><TD>
<CODE> printcap (printer[@host] | all) </CODE></TD><TD>report printcap values</TD></TR><TR><TD>
<CODE> quit                            </CODE></TD><TD>exit LPC</TD></TR><TR><TD>
<CODE> redirect (printer[@host] | all) (printer@host | off )*    </CODE></TD><TD>redirect jobs</TD></TR><TR><TD>
<CODE> release  (printer[@host] | all) (name[@host] | job | all)* </CODE></TD><TD>release job</TD></TR><TR><TD>
<CODE> reread [printer[@host]]</CODE></TD><TD>LPD reread database information</TD></TR><TR><TD>
<CODE> start   (printer[@host] | all)  </CODE></TD><TD>start printing</TD></TR><TR><TD>
<CODE> status  (printer[@host] | all)  </CODE></TD><TD>status of printers</TD></TR><TR><TD>
<CODE> stop    (printer[@host] | all)  </CODE></TD><TD>stop printing</TD></TR><TR><TD>
<CODE> topq    (printer[@host] | all) (name[@host] | job | all)* </CODE></TD><TD>reorder job</TD></TR><TR><TD>
<CODE> defaultq                         </CODE></TD><TD>default queue for LPD server</TD></TR><TR><TD>

</TD></TR></TABLE></CENTER>
<P>Many of these commands support extremely specialized operations for
print queue management,
However, the following are the most commonly used and are supported by
the BSD LPD print spooling system as well:
<UL>
<LI><CODE> start, stop, enable, disable </CODE><BR>
 Start and stop will start and stop printing for a specified queue.
Enable and disable enable and disable sending and/or accepting jobs
for the queue.</LI>
<LI><CODE> abort, kill </CODE><BR>
Abort will cause the process doing the actual job printing to be terminated.
Kill does an abort, and then restarts the printing process.
These commands are used to restart a queue printing after some disaster.</LI>
<LI><CODE> topq </CODE>
Places selected jobs at the top of the print queue.</LI>
<LI><CODE> status </CODE><BR>
Shows a status display of the print spools on the server.</LI>
</UL>
<P>The following commands are extensions to the basic set provided by the
BSD LPD system.
<UL>
<LI><CODE> lpq, lprm </CODE><BR>
Invokes the lpq or lprm program from lpc.
Useful when in the interactive mode.</LI>
<LI><CODE> hold, holdall, release </CODE><BR>
The hold command will cause the selected jobs to be held until
released.
The holdall jobs sets all jobs submitted to the queue to be held until
released.
The release command releases jobs for printing.
If a job has had an error and is in the error state,
the release command will cause it to be reprinted.</LI>
<LI><CODE> move, redirect </CODE><BR>
The move command will move selected jobs to the specified spool queue.
The redirect command sends all jobs submitted to the queue to be
sent to the specified queue.</LI>
<LI><CODE> active, lpd, reread </CODE><BR>
The active command will connect to the server for the printer.
This is used to check to see if non-LPRng print servers are active.
The lpd command will connect to the server and
get the process id (PID) of the <CODE>lpd</CODE> server.
The reread command causes a SIGHUP signal to be sent to the lpd process,
causing it to reread the
<CODE>/etc/lpd.conf</CODE>,
<CODE>/etc/printcap</CODE>,
or
<CODE>/etc/lpd.perms</CODE> files.
This is usually done when some important configuration information has
been modified and the administrator wants to have the server use the
new information.</LI>
<LI><CODE> debug </CODE><BR>
This is a desperation facility for developers that allows dynamic enabling
of debug information generation.
Not normally used in general operation.</LI>
</UL>

<A NAME="sendblockformat"></A> 
<A NAME="blocktransfer"></A> <H2><A NAME="ss14.9">14.9 Block Job Transfer</A>
</H2>

<P>Options used:
<UL>
<LI> <CODE>send_block_format</CODE><EM>&nbsp;&nbsp;Transfer job as a block</EM></LI>
</UL>
<P>In normal job transfer operations,
the sender and receiver have a handshake interaction in order to transfer
a print job.
Each file is sent individually.
The <CODE>send_block_format</CODE> option forces
a Block Job Transfer operation.
This causes the sender to transfer a single file containing all the
job printing information,
including control file and data files.
<P>The transfer command line has the form:
<PRE>
\006printer user@host size\n
</PRE>
<P>The receiver will return any acknowledgement of a single 0 octet,
and then the size bytes of the job will be transferred by the sender.
At the end of the transfer a single 0 octet is added,
and the receiver will indicate success by returning a single 0 octet.
Any other value returned by the receiver indicates an error condition.
<P>The file transferred by the sender is simply the command lines that it
would have normally sent for job transfer,
followed by the control or data file values.
<H2><A NAME="ss14.10">14.10 Authenticated Transfer</A>
</H2>

<P>RFC1179 does not provide any authentication or encryption mechanism
for the transfer of jobs or commands to the <CODE>lpd</CODE>
print server.
The Authenticated Transfer operation was added to allow an encrypted
or authenticated transfer of print jobs or commands.
<P>Since there are various restrictions on the incorporation of authentication
facilities into programs,
LPRng supports authentication by providing a simple interface to
encryption programs.
<P>The idea is that when authentication is required when sending a job,
LPRng will generate a block transfer job as described for the
<A HREF="#blocktransfer">Block Transfer operation,</A>
and then invoke a set of programs to encryt and transfer the file,
and encrypt and transfer the returned status.
<P>Similarly,
when sending a command,
the command information will be placed in a file
and the encrypted file will be transferred.
<P>This technique means that the programs and support to do encryption
are external to LPRng,
and can use any type of method that they choose to implement the
secure and/or authenticated transfer.
<P>See
<A HREF="LPRng-HOWTO-11.html#authref">Authentication and Encryption</A>
for details on the authentication interface.
<HR>
<A HREF="LPRng-HOWTO-15.html">Next</A>
<A HREF="LPRng-HOWTO-13.html">Previous</A>
<A HREF="LPRng-HOWTO.html#toc14">Contents</A>
</BODY>
</HTML>
