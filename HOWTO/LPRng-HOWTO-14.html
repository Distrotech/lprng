<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
 <META NAME="GENERATOR" CONTENT="SGML-Tools 1.0.9">
 <TITLE> LPRng-HOWTO: Permissions and Authentication</TITLE>
 <LINK HREF="LPRng-HOWTO-15.html" REL=next>
 <LINK HREF="LPRng-HOWTO-13.html" REL=previous>
 <LINK HREF="LPRng-HOWTO.html#toc14" REL=contents>
</HEAD>
<BODY>
<A HREF="LPRng-HOWTO-15.html">Next</A>
<A HREF="LPRng-HOWTO-13.html">Previous</A>
<A HREF="LPRng-HOWTO.html#toc14">Contents</A>
<HR>
<H2><A NAME="lpdpermsref"></A> <A NAME="s14">14. Permissions and Authentication</A></H2>

<P>The contents of the <CODE>/etc/lpd.perms</CODE> file
is used to specify the restrictions on the use
of the LPRng software,
printers,
and other facilities.
The model used for permission granting is similar to packet filters.
An incoming request is tested against a list of rules,
and the first match found determines the action to be taken.
The action is either <CODE>ACCEPT</CODE> or the request is granted,
or <CODE>REJECT</CODE> and the request is denied.
You can also establish a default action.
<P>The following is a sample <CODE>lpd.perms</CODE> file.
<P>
<BLOCKQUOTE><CODE>
<PRE>
# allow root on server to control jobs
ACCEPT SERVICE=C SERVER REMOTEUSER=root
REJECT SERVICE=C
#
# allow same user on originating host to remove a job
ACCEPT SERVICE=M SAMEHOST SAMEUSER
# allow root on server to remove a job
ACCEPT SERVICE=M SERVER REMOTEUSER=root
REJECT SERVICE=M
# all other operations allowed
DEFAULT ACCEPT
</PRE>
</CODE></BLOCKQUOTE>
<P>A rule will ACCEPT or REJECT a request
if all of the patterns specified in the rule match.
If there is a match failure,
the next rule in sequence will be applied.
If all of the rules are exhausted,
then the last specified default authorization will be used.
<P>The sense of a pattern match can be inverted using the NOT keyword.
For example,
the rules with
<CODE>ACCEPT NOT REMOTEUSER=john,bill</CODE>
succeeds only if the REMOTEUSER value is defined and
is not <CODE>john</CODE> or <CODE>bill</CODE>.
<P>The following patterns and matching are applied.
<P>
<CENTER><TABLE BORDER><TR><TD>
<BR>
Keyword</TD><TD>Match</TD></TR><TR><TD>
<CODE>DEFAULT</CODE></TD><TD>default result</TD></TR><TR><TD>
<CODE>SERVICE</CODE></TD><TD>lpC, lpR, lprM, lpQ requests, and Printing jobs</TD></TR><TR><TD>
<CODE>USER</CODE></TD><TD>user name in print job.This check will always succeed when checking for spool queue permissions,and only be done when checking for job permissions.</TD></TR><TR><TD>
<CODE>REMOTEUSER</CODE></TD><TD>user making request</TD></TR><TR><TD>
<CODE>HOST</CODE></TD><TD>host name in print job.This check will always succeed when checking for spool queue permissions,and only be done when checking for job permissions.</TD></TR><TR><TD>
<CODE>REMOTEHOST</CODE></TD><TD>host making request</TD></TR><TR><TD>
<CODE>IP</CODE></TD><TD>IP address and mask of host in print jobThis check will always succeed when checking for spool queue permissions,and only be done when checking for job permissions.</TD></TR><TR><TD>
<CODE>REMOTEIP</CODE></TD><TD>IP address and mask of host making request</TD></TR><TR><TD>
<CODE>PORT</CODE></TD><TD>TCP/IP port of host making request</TD></TR><TR><TD>
<CODE>SAMEUSER</CODE></TD><TD>USER and REMOTEUSER same</TD></TR><TR><TD>
<CODE>SAMEHOST</CODE></TD><TD>HOST and REMOTEHOST same</TD></TR><TR><TD>
<CODE>SERVER</CODE></TD><TD>request originates on lpd server</TD></TR><TR><TD>
<CODE>FORWARD</CODE></TD><TD>destination of job is not host</TD></TR><TR><TD>
<CODE>GROUP</CODE></TD><TD>USER is in the specified group</TD></TR><TR><TD>
<CODE>LPC</CODE></TD><TD>LPC command in the LPC request.This must be preceeded by SERVICE=C clause.</TD></TR><TR><TD>
<CODE>REMOTEGROUP</CODE></TD><TD>REMOTEUSER is in the specified group</TD></TR><TR><TD>
<CODE>CONTROLLINE</CODE></TD><TD>match a line in control file</TD></TR><TR><TD>
<CODE>AUTH</CODE></TD><TD>authentication type</TD></TR><TR><TD>
<CODE>AUTHUSER</CODE></TD><TD>authenticated user</TD></TR><TR><TD>
<CODE>AUTHFROM</CODE></TD><TD>authenticated forwarder</TD></TR><TR><TD>
<CODE>AUTHJOB</CODE></TD><TD>authenticated job in queue</TD></TR><TR><TD>

</TD></TR></TABLE></CENTER>
<P>Most of the patterns can be lists of alternative values to match,
and can even contain wild cards.
The full details of the rules and keywords are detailed in
the <CODE>lpd.conf(5)</CODE> man page.
<H2><A NAME="ss14.1">14.1 Information for matching</A>
</H2>

<P>In order to do matching,
the <CODE>lpd</CODE> server obtains and sets up the following information:
<OL>
<LI>If the request is coming over a network connection,
then the IP address (REMOTEIP)
port (PORT) of the source of the connection and
FQDN of the remote host (REMOTEHOST) are obtained
and the indicated values are set.
To be specific,
the IP address of the remote host is obtained using
<CODE>getpeername()</CODE>.
The <CODE>gethostbyaddr()</CODE> is used to look up the
host's fully qualified domain name,
which is then assigned to the REMOTEHOST value.
The REMOTEIP value is the
<EM>set</EM> or <EM>list</EM> of IP addresses that could be
used by this host.
This is possible in the IPV6 environment.</LI>
<LI>If the request contains the name of the user,
then REMOTEUSER is assigned the name.</LI>
<LI>If the request contains the name of the printer,
then PRINTER is assigned the name.</LI>
<LI>If permissions checking is to be done for a particular
job in a spool queue,
then the USER, HOST, IP, and PRINTER are set to the
user name, host, and printer information in the control file for the
print job.
The HOST entry in the control file is used by
<CODE>gethostbyname()</CODE> to get the fully qualified domain name of the host.
The IP value is assigned a 
<EM>set</EM> or <EM>list</EM> of IP addresses that could be
used by this host.</LI>
<LI>If one of the optional authentication methods is being used,
(see
<A HREF="LPRng-HOWTO-16.html#authref">Authentication and Encryption</A>),
then AUTH is true and 
AUTHTYPE is set to the type of authentication used.
AUTHUSER to the authenticated originating user of the request
and AUTHFROM is when the originating program is a server.
The AUTHSAMEUSER will be true when the remote client authentication information
matches the authentication information used to create the job on the server.
The AUTHJOB will be true when checking for job permissions and the job
has been authenticated.</LI>
</OL>
<H2><A NAME="ss14.2">14.2 Permission Checks</A>
</H2>

<P>When a connection is made to the <CODE>lpd</CODE> server,
the originating site's IP address and hostname are determined,
and a check with <CODE>SERVICE=X</CODE>
and valid REMOTEHOST,
REMOTEIP,
and PORT information is done.
<P>If the connection was not rejected,
then the request information is read
and the
SERVICE,
REMOTEUSER,
REMOTEHOST,
REMOTEIP,
PORT,
PRINTER,
and other authentication values will be defined.
The SERVICE value will be Q, R, M, or C for
<CODE>lpq</CODE>,
<CODE>lpr</CODE>,
<CODE>lprm</CODE>,
or
<CODE>lpc</CODE> respectively.
The permissions file will be scanned to determine if the
request should be immediately discarded based on the print queue
it is for.
During this stage of processing,
permissions checks which require information from jobs in spool queues
will be ignored and treated as though a match had succeeded.
<P>If the request is not rejected,
then it will be processed or carried out.
If the request is for an operation on one or more user jobs in
a spool queue,
then the spool queue for the jobs are scanned and permissions are
again checked against individual jobs.
At this stage in the processing,
the
USER and
HOST 
information obtained from the job file will be used in permissions checking.
This two levels of checks are necessary in order to allow
find control over individual jobs and users.
<P>There is a problem with permissions checking for <CODE>lpq</CODE> (SERVICE=Q)
requests.
Since the user name is not passed as part of the request,
it is impossible to use the REMOTEUSER clause to restrict <CODE>lpq</CODE>
operations.
<P>The <CODE>SERVICE=R</CODE> and <CODE>SERVICE=P</CODE>
facilities are provided to handle problems with print spoolers that
do not recognize a <I>lack of permission</I> error code,
and will indefinately retry sending a job to the <CODE>lpd</CODE> server.
If this is the case,
then the <CODE>SERVICE=R</CODE> clause can be used to accept jobs,
and then the <CODE>SERVICE=P</CODE> clause will cause the <CODE>lpd</CODE>
server to remove of the job when it is scheduled for printing.
<H2><A NAME="ss14.3">14.3 Match Procedure</A>
</H2>

<P>
<BLOCKQUOTE><CODE>
<PRE>
key=pattern                         substring match
key=pattern1,pattern2,pattern3,...  glob and exact
key=IP1/mask1,IP2/mask2,...         IP address
</PRE>
</CODE></BLOCKQUOTE>
<P>Each of the indicated values is matched against a list of patterns.
The following types of matches are used:
<OL>
<LI>substring match.
The indicated entry is present as a substring in the pattern.</LI>
<LI>GLOB matches.
The pattern is interpreted as a GLOB style pattern,
where * matches 0 or more characters,
and ? matches a single character,
and
<CODE>[L-H]</CODE>
specifies a range of characters from
<CODE>L</CODE> to <CODE>H</CODE>,
in ASCII order.</LI>
<LI>IP address match.  The address must be specified in the
standard <CODE>nn.nn.nn.nn</CODE> format.
The mask must be either an integer number
corresponding to the number of significant bits,
or in the standard <CODE>nn.nn.nn.nn</CODE> format.
Addresses are compared by doing
<BLOCKQUOTE><CODE>
<PRE>
( IPaddr XOR IP ) AND mask
</PRE>
</CODE></BLOCKQUOTE>

<P>If the result is 0, then a match results.
Note that there may be one or more addresses being checked for;
this can occur when a host may have multiple IP addresses assigned to it.
</LI>
<LI>integer range match.
The pattern has the form <CODE>low-high</CODE>,
where low and high are integer numbers.
The match succeeds if the value is in the specified range.</LI>
<LI>Same IP Address Match.
This compares two lists of IP addresses;
a match is found when there is one or more common addresses.</LI>
</OL>
<H3>DEFAULT</H3>

<P>
<BLOCKQUOTE><CODE>
<PRE>
DEFAULT ACCEPT
DEFAULT REJECT
</PRE>
</CODE></BLOCKQUOTE>
<P>The DEFAULT rule specifies the default if no rule matches.
Normally,
there is one DEFAULT entry in a permissions file.
<H3>SERVICE</H3>

<P>Match type: substring
<P>The SERVICE key is based on the type of request.
<CENTER><TABLE BORDER><TR><TD>
<BR>
Key</TD><TD>Request</TD></TR><TR><TD>
<CODE>C</CODE></TD><TD>LPC Control Request</TD></TR><TR><TD>
<CODE>M</CODE></TD><TD>LPRM Removal Request</TD></TR><TR><TD>
<CODE>P</CODE></TD><TD>Job Printing</TD></TR><TR><TD>
<CODE>Q</CODE></TD><TD>LPQ Status Request</TD></TR><TR><TD>
<CODE>R</CODE></TD><TD>LPR Job Transfer</TD></TR><TR><TD>
<CODE>X</CODE></TD><TD>Connection Request</TD></TR><TR><TD>

</TD></TR></TABLE></CENTER>
<P>Each of the above codes corresponds either directly to the user command,
or a set of subcommands.
<P>If you have an LPC request,
you can add an <CODE>LPC=xxx</CODE> clause to refine the
permissions checking to allow or disallow
<CODE>lpc</CODE> commands such as <CODE>lpc status, printcap, active, </CODE>.
<H3>USER</H3>

<P>Match type: GLOB
<P>The USER information is taken from the <CODE>P</CODE> (person or logname)
information in the print job control file.
<H3>REMOTEUSER</H3>

<P>Match type: GLOB
<P>The REMOTEUSER information is taken from the user information sent
with a service request.
<P>Note that one of the flaws of
<A HREF="LPRng-HOWTO-6.html#rfc1179">RFC1179</A>
is that an LPQ (print status)
request does not provide a REMOTEUSER name.
<H3>HOST</H3>

<P>Match type: GLOB
<P>The HOST information is taken from the <CODE>H</CODE> (host)
information in the print job control file.
<H3>REMOTEHOST</H3>

<P>Match type: GLOB
<P>The REMOTEHOST information is obtained by doing a reverse IP name lookup
on the remote host address.
If there is no FQDN available,
then the IP address in text form will be used.
<H3>PORT</H3>

<P>Match type: integer range
<P>The PORT value is obtained from the originating port of the TCP/IP
connection.
The match succeeds if it is in the specified range.
<H3>IP</H3>

<P>Match type: IPaddr
<P>The IP information is obtained by doing a DNS lookup on the
H (host) information in the control file.
If there is no host information, the IP address is undefined.
Note that for a single host name there may be multiple IP addresses;
address matches are performed against the list of addresses and succeeds
if there is one or more individual address matches.
<H3>REMOTEIP</H3>

<P>Match type: IPaddr
<P>The REMOTEIP information is the IP address of the host making the
service request.
Note that the REMOTEIP value is obtained by using the
<CODE>gethostbyaddr</CODE> lookup to obtain the DNS information for the
remote host.  This information may include multiple IP addresses;
address matches are performed against the list of addresses and succeeds
if there is one or more individual address matches.
<H3>LPC</H3>

<P>Match type: GLOB
<P>If you are doing an LPC command,
this matches the command.
This allows the following permissions line to be used:
<BLOCKQUOTE><CODE>
<PRE>
#allow remoteuser admin on server to use LPC topq and hold
ACCEPT LPC=topq,hold SERVER REMOTEUSER=x
</PRE>
</CODE></BLOCKQUOTE>
<P>
<H3>SAMEUSER</H3>

<P>Match type: exact string match
<P>Both the REMOTEUSER and USER information must be present and identical.
<H3>SAMEHOST</H3>

<P>Match type: Same IP Address
<P>The REMOTEHOST and HOST address lists are checked;
if there is a common value the match succeeds.
<H3>SERVER</H3>

<P>Match type: Same IP Address
<P>One of the REMOTEHOST addresses 
must be the same as one of the addresses of the <CODE>lpd</CODE> server host,
or must be one of the addresses found by looking up the <CODE>localhost</CODE>
name using <CODE>gethostbyname()</CODE>.
<H3>FORWARD</H3>

<P>Match type: Address Match
<P>The list of REMOTEHOST and HOST addresses must not have a common entry.
This is identical to NOT SAMEHOST.
This is usually the case when a remote <CODE>lpd</CODE> server is forwarding
jobs to the <CODE>lpd</CODE> server.
<H3>GROUP</H3>

<P>Match type: modified GLOB
<P>If the pattern does not start with a <CODE>@</CODE> character,
then the USER information must be present
and the USER must be present in
one of the groups in <CODE>/etc/group</CODE> or whatever permissions mechanism is used
to determine group ownership
which matches the GLOB pattern.
<P>If the pattern starts with a <CODE>@</CODE> character,
then the USER information must be present
and the user must be in the specified <CODE>netgroup</CODE>.
This match will be performed only if the <CODE>netgroup</CODE>
mechanism is supported on the system and the specified netgroup
exists.
No wildcard match will be done for netgroups.
<H3>REMOTEGROUP</H3>

<P>The same rules as for GROUP,
but using the REMOTEUSER value.
<H3>CONTROLLINE</H3>

<P>Match type: GLOB
<P>A <CODE>CONTROLLINE</CODE> pattern has the form
<BLOCKQUOTE><CODE>
<PRE>
X=pattern1,pattern2,...
</PRE>
</CODE></BLOCKQUOTE>
<P>X is a single upper case letter.
The corresponding line must be present in a control file,
and the pattern is applied to the line contents.
<P>This pattern can be used to select only files with specific control
file information for printing.
<H3>AUTH</H3>

<P>Match type: GLOB
<P>The AUTH value can be NONE,
indicating that no authentication was done.
If authentication was done,
then AUTH=USER checks to see if there was user information,
and AUTH=FWD checks to see if there was forwarding system identification.
<H3>AUTHUSER</H3>

<P>Match type: GLOB
<P>If AUTH=USER check succeeds,
the AUTHUSER rule will check to see if the user identification
matches the pattern.
<H3>FWDUSER</H3>

<P>Match type: GLOB
<P>If AUTH=FWD check succeeds,
the FWDUSER rule will check to see if the forwarding system identification
matches the pattern.
<H3>IFIP</H3>

<P>Match type: IPmatch, but for IPV6 as well as IPV4
<P>There is a subtle problem with names and IP addresses which are
obtained for 'multi-homed hosts', i.e. - those with multiple
ethernet interfaces,  and for IPV6 (IP Version 6),  in which a host
can have multiple addresses,  and for the normal host which can have
both a short name and a fully qualified domain name.
<P>The IFIP (interface IP) field can be used to check the IP address
of the origination of the request,  as reported by the information
returned by the accept() system call.  Note that this information may
be IPV4 or IPV6 information,  depending on the origination of the
system.  This information is used by gethostbyaddr() to obtain the
originating host fully qualified domain name (FQDN) and set of IP addresses.
Note that this FQDN will be for the originating interface,  and may
not be the canonical host name.  Some systems which use the Domain Name Server
(DNS) system may add the canonical system name as an alias.
<H2><A NAME="permspath"></A> <A NAME="ss14.4">14.4 Permission File Location</A>
</H2>

<P>Options used:
<UL>
<LI> <CODE>perms_path=</CODE><EM> directory path list</EM></LI>
</UL>
<P>The <CODE>perms_path=</CODE> configuration variable specifies the
location of the default permissions file.
The default value is:
<BLOCKQUOTE><CODE>
<PRE>
perms_path=/etc/lpd.perms:/usr/etc/lpd.perms
</PRE>
</CODE></BLOCKQUOTE>
<P>The <CODE>lpd.perms</CODE> file can be obtained by running a program,
in a similar manner to the <CODE>/etc/printcap</CODE> file.
See
<A HREF="LPRng-HOWTO-13.html#secfilter">Filters</A> for details on how
the program would be invoked.
For example, assume the configuration information specified:
<BLOCKQUOTE><CODE>
<PRE>
perms_path=|/usr/local/libexec/get_perms
</PRE>
</CODE></BLOCKQUOTE>
<P>Then the <CODE>get_perms</CODE> program would be invoked with STDIN attached
to <CODE>/dev/null</CODE> and the complete set of permission information
would be read from its STDOUT.
<H2><A NAME="ss14.5">14.5 Example Permission File</A>
</H2>

<P>
<BLOCKQUOTE><CODE>
<PRE>
# allow root on server to control jobs
ACCEPT SERVICE=C SERVER REMOTEUSER=root
REJECT SERVICE=C
#
# allow same user on originating host to remove a job
ACCEPT SERVICE=M SAMEHOST SAMEUSER
# allow root on server to remove a job
ACCEPT SERVICE=M SERVER REMOTEUSER=root
REJECT SERVICE=M
# all other operations allowed
DEFAULT ACCEPT
</PRE>
</CODE></BLOCKQUOTE>
<P>In the above sample, we first specify that
lp<CODE>C</CODE>
commands from user <CODE>root</CODE> on the lpd server will be accepted.
This is traditionally the way that most lpc commands operate.
<P>Next,  we reject any other lpc requests.
<P>We accept
lpr<CODE>M</CODE>
requests from the host and user that submitted the job,
as well as from root on the server,
and reject any others.
<P>Finally,
all other types of commands (lpq, lpr) are allowed by default.
<H2><A NAME="ss14.6">14.6 Complex Permission Checking</A>
</H2>

<P>One of the more useful types of permission checking is to
restrict access to your printers from users outside your
networks.
The IP pattern can specify a list of IP addresses and netmasks
to apply to them.
<P>For example
<CODE>IP=10.3.4.0/24</CODE> would match all hosts with the IP
addresses
<CODE>IP=10.3.4.0</CODE> to
<CODE>IP=10.3.4.255</CODE>.
<P>Similarly, the HOST pattern can specify a set of hostnames
or patterns to match against based on the GLOB notation.
<P>For example
<CODE>REMOTEHOST=*.astart.com</CODE>
would match all hosts with a DNS entry which ended with
<CODE>astart.com</CODE>.
<P>The NOT keyword reverses the match sense.  For example
<CODE>REJECT NOT REMOTEHOST=*.astart.com,*.murphy.com</CODE>
would reject all requests from hosts which did not have a DNS entry
ending in
<CODE>astart.com</CODE>
or
<CODE>murphy.com</CODE>.
<H2><A NAME="ss14.7">14.7 More Examples</A>
</H2>

<P>The following is a more complex lpd.perms file.
<BLOCKQUOTE><CODE>
<PRE>
# All operations allowed except those specifically forbidden
DEFAULT ACCEPT
#Reject connections which do not originate from hosts with an
# address on 130.191.0.0 or from localhost,
# or name is not assigned to Engineering pc's
REJECT SERVICE=X NOT IFIP=130.191.0.0/16,127.0.0.1/32
REJECT SERVICE=X NOT REMOTEHOST=engpc*
#Do not allow anybody but root or papowell on
#astart1.astart.com or the server to use control
#facilities.
ACCEPT SERVICE=C SERVER REMOTEUSER=root
ACCEPT SERVICE=C REMOTEHOST=astart1.astart.com REMOTEUSER=papowell
#Allow root on talker.astart.com to control printer hpjet
ACCEPT SERVICE=C HOST=talker.astart.com PRINTER=hpjet REMOTEUSER=root
#Reject all others
REJECT SERVICE=C
#Do not allow forwarded jobs or requests
REJECT SERVICE=R,C,M FORWARD
# allow same user on originating host to remove a job
ACCEPT SERVICE=M SAMEHOST SAMEUSER
# allow root on server to remove a job
ACCEPT SERVICE=M SERVER REMOTEUSER=root
</PRE>
</CODE></BLOCKQUOTE>
<HR>
<A HREF="LPRng-HOWTO-15.html">Next</A>
<A HREF="LPRng-HOWTO-13.html">Previous</A>
<A HREF="LPRng-HOWTO.html#toc14">Contents</A>
</BODY>
</HTML>
