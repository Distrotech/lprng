<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
 <META NAME="GENERATOR" CONTENT="SGML-Tools 1.0.9">
 <TITLE> LPRng-HOWTO: Job Processing</TITLE>
 <LINK HREF="LPRng-HOWTO-13.html" REL=next>
 <LINK HREF="LPRng-HOWTO-11.html" REL=previous>
 <LINK HREF="LPRng-HOWTO.html#toc12" REL=contents>
</HEAD>
<BODY>
<A HREF="LPRng-HOWTO-13.html">Next</A>
<A HREF="LPRng-HOWTO-11.html">Previous</A>
<A HREF="LPRng-HOWTO.html#toc12">Contents</A>
<HR>
<H2><A NAME="jobsteps"></A> <A NAME="s12">12. Job Processing</A></H2>

<P>Much of the flexibility of the LPRng software is obtained
from the ability to control the details of each step of job processing.
The following section details each step in the processing of a job,
and explains the printcap options used to control each operation.
<P>Assume the <CODE>pr</CODE>
printcap entry has the form:
<BLOCKQUOTE><CODE>
<PRE>
pr
    :lp=/dev/lp  OR  :lp=rp@rm
    :sd=/var/spool/lpd/pr
    :lf=log
    :of=/usr/local/bin/lpf
    :if=/usr/local/bin/lpf
</PRE>
</CODE></BLOCKQUOTE>
<P>Assume that we have used the following command to print
a set of files.
<BLOCKQUOTE><CODE>
<PRE>
lpr -Ppr file1 file2
</PRE>
</CODE></BLOCKQUOTE>
<P>This will create a control file
in the
<CODE>/var/spool/lpd/pr</CODE>
directory with the following contents (this is an example -
in practice there may be minor differences between the example
and an actual control file):
<BLOCKQUOTE><CODE>
<PRE>
Hastart4.astart.com
J/tmp/file1 /tmp/file2
CA
Lpapowell
Ppapowell
fdfA002230astart4.astart.com
N/tmp/file1
UdfA002230astart4.astart.com
fdfB002230astart4.astart.com
N/tmp/file2
UdfB002230astart4.astart.com
</PRE>
</CODE></BLOCKQUOTE>
<P>
<H2><A NAME="servertmpdir"></A> <A NAME="nb"></A> <A NAME="controlfilter"></A> <A NAME="connecttry"></A> <A NAME="connecttimeout"></A> <A NAME="connectinterval"></A> <A NAME="networkconnectgrace"></A> <A NAME="connectgrace"></A> <A NAME="rw"></A> <A NAME="ld"></A> <A NAME="ar"></A> <A NAME="la"></A> <A NAME="lpdev"></A> <A NAME="lk"></A> <A NAME="fo"></A> <A NAME="ff"></A> <A NAME="as"></A> <A NAME="af"></A> <A NAME="achk"></A> <A NAME="ss12.1">12.1 Opening the Output Device</A>
</H2>

<P>Options used:
<UL>
<LI> <CODE>achk</CODE><EM>&nbsp;&nbsp;Accounting check at start</EM></LI>
<LI> <CODE>af=</CODE><EM>Accounting File</EM></LI>
<LI> <CODE>ar</CODE><EM>&nbsp;&nbsp;Remote printer accounting enabled</EM></LI>
<LI> <CODE>as=</CODE><EM>Accounting at start</EM></LI>
<LI> <CODE>connect_grace#</CODE><EM>&nbsp;&nbsp;Time between jobs</EM></LI>
<LI> <CODE>connect_interval#</CODE><EM>&nbsp;&nbsp;Connection interval</EM></LI>
<LI> <CODE>connect_timeout#</CODE><EM>&nbsp;&nbsp;Connection timeout</EM></LI>
<LI> <CODE>control_filter=</CODE><EM>Control file filter</EM></LI>
<LI> <CODE>ff</CODE><EM>&nbsp;&nbsp;form feed</EM></LI>
<LI> <CODE>fo</CODE><EM>&nbsp;&nbsp;form feed on open</EM></LI>
<LI> <CODE>la</CODE><EM>&nbsp;&nbsp;Local printer accounting enabled</EM></LI>
<LI> <CODE>ld=</CODE><EM>leader on open (initialization string)</EM></LI>
<LI> <CODE>lk</CODE><EM>&nbsp;&nbsp;Lock IO device</EM></LI>
<LI> <CODE>lp=</CODE><EM>IO device pathname</EM></LI>
<LI> <CODE>nb</CODE><EM>&nbsp;&nbsp;Nonblocking device open</EM></LI>
<LI> <CODE>network_connect_grace#</CODE><EM>&nbsp;&nbsp;Time between jobs</EM></LI>
<LI> <CODE>of=</CODE><EM>of filter</EM></LI>
<LI> <CODE>retry_econnrefused#</CODE><EM>&nbsp;&nbsp;Retry if open failed</EM></LI>
<LI> <CODE>retry_nolink#</CODE><EM>&nbsp;&nbsp;Retry if open failed</EM></LI>
<LI> <CODE>rm</CODE><EM>&nbsp;&nbsp;the remote machine to send the job to</EM></LI>
<LI> <CODE>rp</CODE><EM>&nbsp;&nbsp;the remote print queue to send the job to</EM></LI>
<LI> <CODE>rw</CODE><EM>&nbsp;&nbsp;device opened RW flag</EM></LI>
<LI> <CODE>server_tmp_dir=</CODE><EM>temporary directory</EM></LI>
</UL>

Sequence of Operations:
<OL>
<LI>During the server operations,
it will try to create temporary files in the print queue spool directory.
If this is not desirable,
it will create them in the <CODE>server_tmp_dir</CODE> directory.</LI>
<LI>If the accounting file specified by
<CODE>af</CODE>
exists,
it is opened (af_fd) and the af_fd is passed as file descriptor
3 to all filters.
If the <CODE>af</CODE> value has the form <CODE>af=|/program</CODE>
then the program is started and the program STDIN is used as af_fd.
If the <CODE>af</CODE> value has the form <CODE>af=host%port</CODE>,
then a TCP/IP connection to the corresponding port on the remote host
is made and the port used as af_fd.
In the latter two cases,  the filter STDIN (file descriptor 0)
is actually opened read/write, and is used when information is needed
from the accounting filter or remote server.
See
<A HREF="LPRng-HOWTO-15.html#accountingserver">Accounting Printcap Options</A>
for more information on the LPRng accounting support.</LI>
<LI>
<A NAME="accountstart"></A> 
If <CODE>la</CODE> (local accounting) is true and we are printing a job
or <CODE>ar</CODE> (remote accounting) is true and we are transferring a job,
the <CODE>as</CODE> value is examined.
If it is a filter (program) specification,
then the program is started with its STDIN attached to
<CODE>/dev/null</CODE>, STDOUT will be read by the print spooler,
STDERR output will be written to the error log,
and file descriptor 3 output will be appended to the accounting file.
The lpd program will wait until the accounting filter program terminates,
and examine the error code for action, as for the filters
(see
<A HREF="#errorcodes">errorcodes</A> below).
If the exit status is 0,
(JSUCC) then the printing process will continue,
if JHOLD the job will be held,
if JREMOVE the job will be removed,
if JFAIL the job processing will terminate with a JFAIL indication,
otherwise
the job processing will terminate with a JABORT indication.</LI>
<LI>If the accounting filter exited with a JSUCC (no error code)
and the <CODE>achk</CODE> (accounting check) flag is set, 
the line read from the accounting filter STDOUT will be examined.
This line should be
<CODE>accept</CODE>,
<CODE>hold</CODE>,
<CODE>fail</CODE>,
<CODE>remove</CODE>,
otherwise the job processing terminates with a JABORT indication.
An <CODE>accept</CODE> will allow the job to be printed,
<CODE>hold</CODE> will hold the job,
<CODE>fail</CODE> will cause the job to fail,
<CODE>remove</CODE> will cause the job to be removed.</LI>
<LI>If the
<CODE>connect_grace</CODE>
value is non-zero and the server is opening a device or
<CODE>network_connect_grace</CODE> is non-zero and a network connection
is being made,
the server will pause the specified time.
This is to accommodate devices which need a recovery time between jobs.</LI>
<LI>The <CODE>lp</CODE> option is checked to determine the type of IO device.
<CENTER><TABLE BORDER><TR><TD>
<BR>
Format</TD><TD>Meaning</TD></TR><TR><TD>
<CODE>/pathname</CODE></TD><TD>Absolute pathname of IO device</TD></TR><TR><TD>
<CODE>pr@host</CODE></TD><TD>transfer to <CODE>pr</CODE> on remote <CODE>host</CODE></TD></TR><TR><TD>
<CODE>host%port</CODE></TD><TD>open a TCP/IP connection to port on host. host can be name or IP address</TD></TR><TR><TD>
<CODE>|filter</CODE></TD><TD>run the filter program; it STDIN will be used as device</TD></TR><TR><TD>

</TD></TR></TABLE></CENTER>
</LI>
<LI>The IO device specified by
<CODE>lp</CODE> is opened write-only or read-write if the
<CODE>rw</CODE>
flag is true, and the resulting file descriptor is io_fd.
If the <CODE>nb</CODE> flag is set,
a non-blocking open will be done as well.
If the <CODE>lk</CODE> (lock device) flag is true,
the device will be locked against use by other LPD servers.</LI>
<LI>If a <CODE>host%port</CODE> combination,
a TCP/IP connection will be opened to the remote port and the connection will
be used as io_fd.</LI>
<LI>If a filter program is specified,
the filter program will be run and the STDIN of the filter will be
used as the device file descriptor.</LI>
<LI>If a <CODE>rp@rm</CODE> combination,
or none of the above combinations are true and the
<CODE>rm</CODE> and <CODE>rp</CODE> values are non-zero,
then the job will be transferred to a remote printer.
The type of operation will be a job transfer,
rather than printing operation.</LI>
<LI>If the <CODE>connect_timeout</CODE> value is non-zero,
a timeout is setup for the device or socket open.
If the device or connection open does not succeed within the timeout,
then the open operation fails.</LI>
<LI>If a connection is to a network address
(i.e. - <CODE>connect()</CODE> system call)
and the connection attempt fails with an <CODE>ECONNREFUSED</CODE>
error,
if the <CODE>retry_econnrefused</CODE>
flag is set then the connection attempt is retried,
but this time using an alternative port number.
See
<A HREF="LPRng-HOWTO-18.html#rfc1179ref">RFC1179</A> for details.
This is repeated until all of the possible originating port numbers
are exhausted.</LI>
<LI>If the open or connect operation fails,
and the <CODE>retry_nolink</CODE> flag is set,
then the server will pause for a minimum of
<CODE>connect_grace</CODE> plus a multiple of
<CODE>connect_interval</CODE> seconds
based on the number of attempts
before retrying the open operation.
Note that the interval may increase as the number of attempts
increases.</LI>
<LI>If printing a job and the
<CODE>of</CODE> filter is specified,
it is created with its STDOUT (fd 1) attached to the io_fd.
Its stdin (of_fd) will be used in the steps listed below.
If there is no
<CODE>of</CODE> filter,
then the of_fd value will be the io_fd descriptor.</LI>
<LI>If transferring a job and the <CODE>control_filter</CODE> option is specified,
then the program specified by the <CODE>control_filter</CODE>
value will be run. It will have its STDIN set to the control file,
and its STDOUT output will be used as the new value of the control file
to transfer to the remote host.
See
<A HREF="LPRng-HOWTO-13.html#filtercmd">Filter Command Line Flags</A>
for details of options passed to the control filter,
and
<A HREF="#errorcodes">errorcodes</A> for the exit codes of the filter.</LI>
<LI>If the operation is a job transfer, the operation proceeds as outlined in
<A HREF="LPRng-HOWTO-18.html#rfc1179ref">RFC1179</A>,
and then the
<A HREF="#normalterm">Normal Termination</A> operations are
carried out.</LI>
<LI>If the operation is a print operation
and the
<CODE>ld</CODE> (leader on open) value is provided,
the string
is translated (escapes removed)
and written to the of_fd file descriptor.</LI>
<LI>If the
<CODE>fo</CODE> (form feed on open) flag is true, then the
<CODE>ff</CODE> (form feed) string
is translated (escapes removed)
and written to the of_fd file descriptor.</LI>
</OL>
<H2><A NAME="generatebanner"></A> <A NAME="bannerprinting"></A> <A NAME="of"></A> <A NAME="sh"></A> <A NAME="sb"></A> <A NAME="bs"></A> <A NAME="bp"></A> <A NAME="bl"></A> <A NAME="be"></A> <A NAME="hl"></A> <A NAME="ab"></A> <A NAME="ss12.2">12.2 Printing Banner At Beginning</A>
</H2>

<P>Options used:
<UL>
<LI> <CODE>ab</CODE><EM>&nbsp;&nbsp;Always print banner (default FALSE)</EM></LI>
<LI> <CODE>be=</CODE><EM>End banner generator program</EM></LI>
<LI> <CODE>bl=</CODE><EM>Short banner line format</EM></LI>
<LI> <CODE>bp=</CODE><EM>Banner generator program</EM></LI>
<LI> <CODE>bs=</CODE><EM>Start banner generator</EM></LI>
<LI> <CODE>generate_banner</CODE><EM>&nbsp;&nbsp;Generate banner for forwarded jobs</EM></LI>
<LI> <CODE>hl</CODE><EM>&nbsp;&nbsp;Banner (header) Last</EM></LI>
<LI> <CODE>of=</CODE><EM>Banner and File Separator Filter</EM></LI>
<LI> <CODE>sb</CODE><EM>&nbsp;&nbsp;Short banner (default FALSE)</EM></LI>
<LI> <CODE>sh</CODE><EM>&nbsp;&nbsp;Suppress header (banners) (default FALSE)</EM></LI>
</UL>
<P>Banner printing is one of the more complicated configuration options
of LPRng.
This is due mainly to historical evolution of the software,
as well as a lack of a well defined standard for
filter responsibilities.
In the original BSD print spoolers,
the philosophy was that banner printing should be delegated to the
filters,
as they were the most aware of the capabilities of the printers.
This required an
<EM>out of band</EM>
method to convey banner printing information to the filter,
and resulted in a complicated interface.
The original interface was:
<OL>
<LI>The filter doing banner printing was invoked as a special
<CODE>of</CODE> filter,
or passed a special flag.</LI>
<LI>The print spooling software would send a special
<B>single line</B>
of information telling it what the banner information should be.
Note that this line was never documented except for the source code,
and was inconsistent from version to version.
Also,
there was no indication of what to do with additional lines,
if any.</LI>
<LI>The filter would generate the banner,
discard the line,
and then pass other lines to the output device.</LI>
</OL>
<P>Adding to the confusion,
the original print spoolers had a <CODE>:sh</CODE> (suppress header or banner)
flag,
which was supposed to suppress banner printing.
It did this by having the print spooler not generate the magic banner
information line.
<P>A more sophisticated banner printing system would allow the
print spooler software to generate the banner,
and would then have the <CODE>of</CODE> filter act as a pass through.
Thus, we need configure the <CODE>of</CODE> filter NOT to use the first
line as banner printing information,
and to pass through all information to the device.
<P>Complicating this whole mess is the
<CODE>ld</CODE>  (leader option)
and
<CODE>tr</CODE>  (trailer option)
which is a string sent to the output device (<CODE>of</CODE> filter)
when the device (filter) is initialized or terminated.
This can sometimes be interpreted as the banner line,
leading to unexpected results.
<P>Sequence of Operations:
<OL>
<LI>If the
<CODE>sh</CODE> (suppress header) flag is true, no banner is
printed,
and the actions in this section are skipped.
No <I>banner information line</I>
is generated for the <CODE>of</CODE> filter,
and no banner printing program is invoked.
If the is an <CODE>of</CODE> filter and if it is expecting such a line
and you have <CODE>ld</CODE> or <CODE>tr</CODE> information
you may get unexpected results
(actually, catastrophic failure is a better term, but I digress).</LI>
<LI>If the <CODE>hl</CODE> (header last) flag is true the banner is printed at the end
of the job
and the actions in this section are done at the end of the job.</LI>
<LI>If the user does not want banner pages she can use the
<CODE>lpr -h </CODE> option.
This will cause the <CODE>lpr</CODE> program
to delete the <CODE>L</CODE> (banner name) line in the control file.
If there is no <CODE>L</CODE> line in the control file
and
<CODE>ab</CODE> (always print a banner) is false
(the default),
then no banner is printed
and the other actions in this section are skipped.
If
<CODE>ab</CODE> is true
and the <CODE>L</CODE> line is missing then the <CODE>N</CODE> (user login name) is used;
if it is missing as well,
then ANONYMOUS is used for the user name.</LI>
<LI>If a banner printing program is specified by <CODE>bp</CODE>, tt<CODE>bs</CODE>,
or <CODE>be</CODE> options,
then LPRng will invoke the
program to generate a banner and then send the generated
banner to the printer
via the <CODE>of</CODE> filter.
The banner printing program will be invoked using
the standard filter command line flags
(see
<A HREF="LPRng-HOWTO-13.html#filtercmd">Filter Command Line Flags</A>
for details),
with is STDIN attached to /dev/null
and STDOUT attached to a file to hold the output banner.</LI>
<LI>If no banner printing program is specified
and the
<CODE>sb</CODE> (short banner) option is TRUE (default is true),
then the <CODE>bl=...</CODE> (banner line) option value
is expanded and sent to the <CODE>of_fd</CODE>  (<CODE>of</CODE> filter or
device.
The default <CODE>bl</CODE> value is:
<CODE>bl=$-'C:$-'n Job: $-'J Date: $-'t</CODE>.
Using our example, this will get translated to:
<BLOCKQUOTE><CODE>
<PRE>
papowell:A Job: file1 file2 Date: Thu Nov 27 23:02:04 PST 1997
</PRE>
</CODE></BLOCKQUOTE>
</LI>
<LI>If no banner printing program is specified and we have <CODE>sb@</CODE>
(no short banner)
then we skip banner generation,
i.e. - we do <EM>not</EM> send a banner generation line
to the output (<CODE>of</CODE> filter).</LI>
<LI>If the queue is a normal forwarding queue,
then the
<CODE>generate_banner</CODE>
option will invoke the
<CODE>bp</CODE>, <CODE>bs</CODE> or <CODE>be</CODE>
program as appropriate to create a banner page file which is then made the
first (default) or last (<CODE>hl</CODE> flag or <CODE>be=...</CODE> present)
file in a job.
This option has no effect in other types of queues.
See the <CODE>
<A HREF="LPRng-HOWTO-8.html#translateformat">translate_format</A></CODE>
option as well.</LI>
</OL>
<H2><A NAME="format"></A> <A NAME="sf"></A> <A NAME="sendqueryrwtimeout"></A> <A NAME="sendjobrwtimeout"></A> <A NAME="ss12.3">12.3 Printing Job Files</A>
</H2>

<P>Options used:
<UL>
<LI> <CODE>Xf=</CODE><EM>Format Filter</EM></LI>
<LI> <CODE>if=</CODE><EM>Default F Format Filter</EM></LI>
<LI> <CODE>pr=</CODE><EM>pr formatting program</EM></LI>
<LI> <CODE>send_job_rw_timeout=</CODE><EM> print job read/write timeout </EM></LI>
<LI> <CODE>send_query_rw_timeout=</CODE><EM> status query operation read/write timeout </EM></LI>
<LI> <CODE>sf</CODE><EM>&nbsp;&nbsp;Suppress FF Print File Separators</EM></LI>
</UL>
<P>Sequence of Operations:
for each job in listed in the control file,
the following operations are done in turn.
<OL>
<LI>If there is an <CODE>of</CODE> filter present,
the suspend string <CODE>\031\001</CODE> is written to of_fd
and the no further action is taken until the of filter is suspended.</LI>
<LI>The control file line for the job is examined,
and the first letter of the data file specification is used as the format.</LI>
<LI>If the format is
<CODE>p</CODE>,
the job is first processed by the program specified by the
<CODE>pr</CODE>
program,
and the program output used as the print file.</LI>
<LI>If the format is
<CODE>f</CODE>,
<CODE>l</CODE>,
or
<CODE>p</CODE>
then the <CODE>if</CODE> filter is used,
otherwise the keyword
<CODE>Xf</CODE> is used.
Note that certain formats such as
<CODE>p, a, l</CODE>, may not be used as formats.</LI>
<LI>The filter program is started with an appropriate set of command line options
(see
<A HREF="LPRng-HOWTO-13.html#filtercmd">Filter Command Line Flags</A>),
and with its STDOUT attached to the printing device (io_fd),
STDERR to a pipe which results in the output being written
to the status file,
and file descriptor 3 to the accounting file or program.
If debugging is enabled,
then the STDERR output is also written to the error log file (lf).</LI>
<LI>When doing a read/write operation to a device or remote system,
a timeout can be specified.
When doing a print or job transfer operation,
the <CODE>send_job_rw_timeout</CODE> value is used.
When doing a status or query operation,
the <CODE>send_query_rw_timeout</CODE> value is used.
If a write or write operation does not complete within
the specified timeout seconds, then we have an error
condition and job processing or the query operation
is terminated with JFAIL status.
If the timeout value is 0, then no timeout is done.</LI>
<LI>
<A NAME="errorcodes"></A> 
<CODE>lpd</CODE> will then wait for the filter to exit.
The exit status can be as follows:
<BLOCKQUOTE><CODE>
<PRE>
Key      Value   Meaning
JSUCC    0       Successful
JFAIL    1, 32   Failed - retry later
JABORT   2, 33   Abort - terminate queue processing
JREMOVE  3, 34   Failed - remove job
JHOLD    6, 37   Failed - hold this job
Other            Abort - terminate queue processing
</PRE>
</CODE></BLOCKQUOTE>
</LI>
<LI>If the filter exit status was JSUCC (0), or no error indicated,
then processing will continue otherwise the job termination takes
(see
<A HREF="#termination">Abnormal Termination</A>).</LI>
<LI>If the <CODE>of</CODE> filter is present,
then it is reactivated with a <CODE>kill -CONT</CODE> signal.</LI>
<LI>If the <CODE>sf</CODE> (suppress FF print file separators ) is false,
then the
<CODE>ff</CODE> (form feed) string
will be interpreted and sent to the of_fd.</LI>
</OL>
<H2><A NAME="ss12.4">12.4 Printing Banner At End</A>
</H2>

<P>Options used:
<UL>
<LI> <CODE>hl</CODE><EM>&nbsp;&nbsp;Header (Banner) Last</EM></LI>
</UL>
<P>The actions taken in this step are identical to those for the
<A HREF="#bp">Printing Banner At Beginning</A>,
with the exception that the
<CODE>be</CODE> (end banner program) is used to select the banner generation program
rather than the
<CODE>bs</CODE> (start banner program).
<P>If we have <CODE>hl</CODE> true,
then we print a banner at the end of the job,
rather than start.
<P>
<H2><A NAME="exitlingertimeout"></A> <A NAME="waitforeof"></A> <A NAME="normalterm"></A> <A NAME="tr"></A> <A NAME="savewhendone"></A> <A NAME="fq"></A> <A NAME="ae"></A> <A NAME="ss12.5">12.5 Normal Termination</A>
</H2>

<P>Options used:
<UL>
<LI> <CODE>fq</CODE><EM>&nbsp;&nbsp;Form Feed on Close</EM></LI>
<LI> <CODE>la</CODE><EM>&nbsp;&nbsp;Local Printer Accounting</EM></LI>
<LI> <CODE>tr=</CODE><EM>Trailer on Close</EM></LI>
<LI> <CODE>ae=</CODE><EM>Accounting at end</EM></LI>
<LI> <CODE>save_when_done</CODE><EM>&nbsp;&nbsp;Save when done</EM></LI>
<LI> <CODE>wait_for_eof</CODE><EM>&nbsp;&nbsp;Wait for EOF before closing device</EM></LI>
<LI> <CODE>exit_linger_timeout</CODE><EM>&nbsp;&nbsp;connection linger on close timeout</EM></LI>
</UL>
<P>Sequence of Operations:
<OL>
<LI>If we are printing and the <CODE>fq</CODE> flag is set and the
<CODE>sf</CODE> (suppress interfile FF) flag is set,
then the
<CODE>ff</CODE> (form feed) string
will be interpreted and sent to the of_fd.</LI>
<LI>If we are printing, the <CODE>tr</CODE> (trailer) string
will be interpreted and sent to the of_fd.</LI>
<LI>If printing and the <CODE>la</CODE> (local printer accounting) flag is set
or transferring a job and the <CODE>ar</CODE> (remote accounting) flag is set,
the
<CODE>ae</CODE> is examined and accounting is done as described
for the
<CODE>
<A HREF="#accountstart">as</A> field.</CODE></LI>
<LI>If the <CODE>of</CODE> filter is present,
its STDIN is closed,
and the <CODE>lpd</CODE> server waits for it to exit.
The exit status is used as described above.</LI>
<LI>If the device is a socket or network connection,
the socket linger time is set to
<CODE>job_send_rw_timeout</CODE> value if nonzero or the
<CODE>exit_linger_timeout</CODE> value if nonzero,
a write <CODE>shutdown</CODE> is done,
and if the <CODE>wait_for_eof</CODE> option is true (default)
then a read is done on the connection until an EOF is found.
The device (io_fd) is then closed.</LI>
<LI>The job is marked as completed in the spool queue.</LI>
<LI>If the <CODE>save_when_done</CODE> flag is not specified,
the job is removed.</LI>
</OL>
<H2><A NAME="termination"></A> <A NAME="maxconnectinterval"></A> <A NAME="stoponabort"></A> <A NAME="sendmail"></A> <A NAME="mailoperatoronerror"></A> <A NAME="mailfrom"></A> <A NAME="sendfailureaction"></A> <A NAME="sendtry"></A> <A NAME="saveonerror"></A> <A NAME="ss12.6">12.6 Abnormal Termination</A>
</H2>

<P>Options used:
<UL>
<LI> <CODE>mail_from=</CODE><EM>Mail from user name</EM></LI>
<LI> <CODE>mail_operator_on_error=</CODE><EM>Mail to operator on error</EM></LI>
<LI> <CODE>send_try#</CODE><EM>&nbsp;&nbsp;Maximum Print or Transfer Attempts</EM></LI>
<LI> <CODE>save_on_error</CODE><EM>&nbsp;&nbsp;Do not delete on error</EM></LI>
<LI> <CODE>send_failure_action=</CODE><EM>Action on Failure</EM></LI>
<LI> <CODE>sendmail=</CODE><EM>sendmail path name and options</EM></LI>
<LI> <CODE>stop_on_abort</CODE><EM>&nbsp;&nbsp;Stop processing queue on filter abort</EM></LI>
</UL>
<P>If the job processing terminates abnormally,
the following sequence of events occurs:
<OL>
<LI>The job is marked as having an error during processing.</LI>
<LI>The LPD server will attempt to kill all filters and other associated process
by using a sequence of
<CODE>kill -INT</CODE>,
<CODE>kill -QUIT</CODE>,
and finally
<CODE>kill -KILL</CODE> operations.</LI>
<LI>If there is a <CODE>mail_operator_on_error</CODE> value,
the specified operator will be mailed an error indication.
The <CODE>sendmail</CODE> option specifies the pathname of the
<EM>sendmail</EM> program and the options needed to have it read
mail addresses from its standard input.
For example, <CODE>sendmail=/usr/sbin/sendmail -oi -t</CODE>
is a commonly used set of options.</LI>
<LI>The <CODE>mail_from</CODE> value specifies the user name used for
mail origination.  If not specified, the default is to use the print spool
queue or printer name.</LI>
<LI>If there is a <CODE>send_failure_action</CODE> specified,
then it is decoded and the corresponding action taken.
If the value is
<CODE>remove</CODE>,
<CODE>hold</CODE>,
<CODE>abort</CODE>,
or
<CODE>retry</CODE>,
then the job is removed, held, aborted, or retried.
If the value is <CODE>|/program</CODE>,
the program is executed and
the number of attempts are written to the filter STDIN.
The exit status of the filter will be used to determine the consequent actions.
That is, JSUCC (0) will be success, and the standard success action will
be taken;
JFAIL will cause retry,
JREMOVE will cause the job to be removed,
JHOLD will cause the job to be held,
JABORT or other status will abort processing.</LI>
<LI>If the status is ABORT and the
<CODE>stop_on_abort</CODE>
flag is set,
then further processing of jobs is terminated.
The job is not removed from the queue.</LI>
<LI>If the error status indicates removal,
and the <CODE>save_on_error</CODE> flag is clear
then the job is removed from the spool queue.</LI>
<LI>If the error status indicates that no further operations should
be performed on the queue,
then the <CODE>lpd</CODE> server will stop processing jobs.</LI>
<LI>If the error code indicated that the job should be retried,
and the
<CODE>send_try</CODE> value is 0 or the number of attempts is less than
the <CODE>send_try</CODE> value,
then the job is retried.
Between each attempt to transfer a job to a remote site.
This pause will double after each attempt,
reaching a maximum of <CODE>max_connect_interval</CODE> seconds.
If <CODE>max_connect_interval</CODE> is 0, there is no limit on the interval value.</LI>
</OL>
<H2><A NAME="maxserversactive"></A> <A NAME="lpdpolltime"></A> <A NAME="lpdforcepoll"></A> <A NAME="ss12.7">12.7 LPD Spool Queue Processing</A>
</H2>

<P>Options used:
<UL>
<LI> <CODE>lpd_force_poll=</CODE><EM>Force LPD to periodically poll print queues </EM></LI>
<LI> <CODE>lpd_poll_time#</CODE><EM>Time between polls</EM></LI>
<LI> <CODE>max_servers_active#</CODE><EM>Maximum number of active servers</EM></LI>
</UL>
<P>When the <CODE>lpd</CODE> server starts,
it will fork a set of subserver processes,
each which will handle an individual queue.
<P>If a system has a large number of queues,
then this forking operation may result in the <CODE>lpd</CODE> server
exhausting the process resources.
To control this,  the
<CODE>max_servers_active</CODE> value restricts the number of active
children to the specified value.
If this value is 0,
then 50% of the maximum system processes value will be used.
<P>Due to the limits on the number of processes,
there may be times when a job is placed in a queue,
but the <CODE>lpd</CODE> server is unable to start handling the job.
When all of the children of the main <CODE>lpd</CODE> server have
exited,
the server starts a timer.
After <CODE>lpd_poll_time</CODE> seconds,  it will scan the queues,
looking for jobs to process,
and starts a process to service them.
If it does not find any jobs it remains idle.
<P>The <CODE>lpd_force_poll</CODE> flag causes the server to periodically
poll the queues.
This is useful when there is a high possibility that jobs could fail to be
printed due to high loads on the server.
<HR>
<A HREF="LPRng-HOWTO-13.html">Next</A>
<A HREF="LPRng-HOWTO-11.html">Previous</A>
<A HREF="LPRng-HOWTO.html#toc12">Contents</A>
</BODY>
</HTML>
