<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
 <META NAME="GENERATOR" CONTENT="SGML-Tools 1.0.9">
 <TITLE> LPRng-HOWTO: Using the Printcap Database</TITLE>
 <LINK HREF="LPRng-HOWTO-9.html" REL=next>
 <LINK HREF="LPRng-HOWTO-7.html" REL=previous>
 <LINK HREF="LPRng-HOWTO.html#toc8" REL=contents>
</HEAD>
<BODY>
<A HREF="LPRng-HOWTO-9.html">Next</A>
<A HREF="LPRng-HOWTO-7.html">Previous</A>
<A HREF="LPRng-HOWTO.html#toc8">Contents</A>
<HR>
<H2><A NAME="printcapref"></A> <A NAME="s8">8. Using the Printcap Database</A></H2>

<P>As described in the
<A HREF="LPRng-HOWTO-2.html#overview">Print Spooling Overview</A>,
the heart of the LPRng system is information in the <CODE>/etc/printcap</CODE>
file.
The printcap information specifies:
<OL>
<LI>The print queues available to users.</LI>
<LI>How client programs communicate with the <CODE>lpc</CODE> print server.</LI>
<LI>The configuration,
location,
and other information for each print queue on the print server.</LI>
<LI>How the <CODE>lpd</CODE> server processes jobs in each print queue.</LI>
</OL>
<P>In order to explain a complex subject,
we will start with a set of simple printer configurations,
and explain the purpose and effect of each entry in the printcap.
<P>For details about individual printcap
options, see the <CODE>printcap(5)</CODE>
man page from the LPRng distribution,
or use the 
<A HREF="LPRng-HOWTO-21.html#index">Index To All The Configuration and Printcap Options</A> to find a specific
printcap option and its effects.
<H2><A NAME="rp"></A> <A NAME="rm"></A> <A NAME="lp"></A> <A NAME="ss8.1">8.1 Simple Client Printcap Entry</A>
</H2>

<P>Options used:
<UL>
<LI> <CODE>rm=</CODE><EM>remote host (machine)</EM></LI>
<LI> <CODE>rp=</CODE><EM>remote printer</EM></LI>
<LI> <CODE>lp=</CODE><EM>destination printer information</EM></LI>
<LI> <CODE>client</CODE>&nbsp;&nbsp;client only printcap FLAG</LI>
</UL>
<P>I'll use this simple example to explain the basics of the LPRng
printcap format
and introduce some of the LPRng network configuration options.
Here is a simple printcap file used to provide client programs
(<CODE>lpr, lprm,</CODE> etc)
with <I>remote printer</I> and <I>server</I> information.
<BLOCKQUOTE><CODE>
<PRE>
# printer lp1
lp1|printer1
  :rm=localhost
# printer lp2 with continuation
lp2:\
  :lp=pr@10.0.0.1:client
# printcap lp3, to printer pr, with overrides
lp3:rp=pr:rm=hpprinter.astart.com
  :force_localhost@
# Simplest possible printcap entry - defaults for everything
lp4
</PRE>
</CODE></BLOCKQUOTE>

<OL>
<LI>Lines starting with a <CODE>#</CODE> sign are comments, and all
leading and trailing <EM>whitespace</EM>,
i.e. - spaces, tabs, etc, are ignored.
Empty lines are ignored as well.</LI>
<LI>A printcap entry starts with the printcap entry <B>name</B>,
followed by one or more <EM>aliases</EM>,
followed by one or more options.
In the above example we have three printcap entries: <CODE>lp1</CODE> with an alias
<CODE>printer1</CODE>
and <CODE>lp2</CODE>, <CODE>lp3</CODE>, and <CODE>lp4</CODE> with no aliases.</LI>
<LI>Aliases start with the <CODE>|</CODE> character and options with the <CODE>:</CODE> character;
tabs and spaces before and after the <CODE>|</CODE> or <CODE>:</CODE> characters
and at the start and end of lines are ignored.
You can use backslash (tt/\/) at the end of a line to create a multi-line
value for an option.
The backslash will cause the next line to be appended to the
current line;
watch out for comments and ends of printcap entries if you use this facility.
As you can see from the example,
there is no <CODE>Name</CODE> printcap entry - this is part of the <CODE>cm</CODE>
option on the previous line.</LI>
<LI>Options take the form of a
keyword/value pair, i.e.-
<PRE>
:option=value
:option#value   (legacy, not advised for new systems)
:option
:option@
</PRE>
</LI>
<LI>Option names are case insensitive, but option values are not.
While <CODE>Ts</CODE> and <CODE>ts</CODE> are the same option name,
<CODE>ts=Testing</CODE> and <CODE>ts=testing</CODE> have their case preserved.
A string or integer value is specified by <CODE>option=value</CODE>
or <CODE>option#value</CODE>.</LI>
<LI>The use of the legacy <CODE>option#value</CODE>
form is <B>NOT</B> recommended as some preprocessors
and database systems will treat <B>#</B> as the start of a comment
and delete the remainder of the line.
This has caused great consternation for sysadmins who wonder why their
NIS distributed printcap entries have been mysteriously truncated.</LI>
<LI>If you want to set a string option to <I>empty</I> value,
use <CODE>option=</CODE>. The <CODE>option</CODE> will set it to <CODE>1</CODE>.
If an option value contains a colon, then use the C (or Perl or Tck/Tk)
string escape <CODE>\072</CODE> to represent the value.</LI>
<LI>Boolean options are set TRUE (1) if no value follows the keyword and FALSE (0) by
appending a <CODE>@</CODE>.
For example
<CODE>sh</CODE>
will set
<CODE>sh</CODE> to TRUE and
<CODE>sh@</CODE> to FALSE.</LI>
</OL>
<P>There may be multiple options on the same line, separated
by colons.
However, this does make the file less readable. The next tip was
supplied by James H. Young &lt;<CODE>jhy@gsu.edu</CODE>&gt;:
<P>
<BLOCKQUOTE>
My personal preference for readability is to always put each
option on its own line.  Putting each option on its own line is
worth the trouble even though it detracts from the usability
of certain grepping techniques when trying to maintain these
types of files.
</BLOCKQUOTE>
<P>Now let's examine the first printcap entry in detail.
It is reproduced here for convenience:
<BLOCKQUOTE><CODE>
<PRE>
# printer lp1
lp1|printer1
  :rm=localhost
</PRE>
</CODE></BLOCKQUOTE>

<OL>
<LI>We start with a comment, followed by the printcap entry name and and alias.
Aliases are useful when you want to refer to a single printer or print queue
by different names.
This can be useful in advanced printcap and print queue setups.
By default,
the remote printer name is the printcap entry name.</LI>
<LI>The <CODE>rm</CODE> (remote machine or host) option specifies the name or IP address
of the <CODE>lpd</CODE> host running <CODE>lpd</CODE>.
In this example the remote host is <CODE>localhost</CODE>
or the machine that the client is running on
and we assume that the <CODE>lpd</CODE> server is running on the localhost.
Thus,
we would communicate with printer
<CODE>lp1@localhost</CODE>.</LI>
</OL>
<P>Let's look at the next printcap entry:
<BLOCKQUOTE><CODE>
<PRE>
# printer lp2 with continuation
lp2:\
  :lp=pr@10.0.0.1:client
</PRE>
</CODE></BLOCKQUOTE>

<OL>
<LI>The <CODE>lp2</CODE> printcap entry illustrates the use (and abuse)
of the <CODE>\</CODE> continuation.
If you think about this,
we have really defined a printcap entry of the form:
<BLOCKQUOTE><CODE>
<PRE>
lp2: :lp=pr@10.0.0.1:client
</PRE>
</CODE></BLOCKQUOTE>

<P>Luckily, LPRng ignores empty options like <CODE>:&nbsp;:</CODE>.
While it is strongly recommended that <CODE>\</CODE>
be avoided it may be necessary for compatibility with other system utilities.
</LI>
<LI>The <CODE>lp=pr@10.0.0.1</CODE> option is an alternate way to
specify a remote queue and server.
If the <CODE>force_localhost</CODE> default is being used,
then the LPRng clients will ignore the <CODE>10.0.0.1</CODE> address
and still connect to <CODE>pr@localhost</CODE>.
There is further discussion about this in the next section.</LI>
<LI>The <CODE>client</CODE> option explicitly labels client only printcap information.
The <CODE>lpd</CODE> server will ignore any printcap with the <CODE>client</CODE> option.
When constructing complex printcaps,
this option is used to keep ensure that you have consistent printcap information.</LI>
</OL>

The following printcap entry shows how to override the
<CODE>force_localhost</CODE> default,
and force the LPRng clients to connect directly to a remote server:
<BLOCKQUOTE><CODE>
<PRE>
lp3:rp=pr:rm=hpprinter.astart.com
  :force_localhost@
</PRE>
</CODE></BLOCKQUOTE>

<OL>
<LI>The <CODE>rp=</CODE>  (remote printer)
remote print queue name to used when sending commands to the <CODE>lpd</CODE> print server.</LI>
<LI>The <CODE>force_localhost@</CODE> option is an example of a <I>flag</I> option.
The <CODE>@</CODE> sets the option value to 0 (false).
We set <CODE>force_localhost</CODE> to false,
which now allows the LPRng clients to connect directly to the
specified remote printer.
In this example,
the <CODE>hpprinter.astart.com</CODE> could be a HP LaserJet Printer with a
JetDirect interface,
which supports the RFC1179 protocol.</LI>
<LI>One disadvantages of sending a job directly to a printer using the above
method is that <CODE>lpr</CODE> program will not
terminate or exit until all of the files have been transferred to the printer,
and this may take a long time
as the printer processes the files as they are received.</LI>
</OL>
<P>Now let's look at the last printcap entry:
<BLOCKQUOTE><CODE>
<PRE>
# Simplest possible printcap entry - defaults for everything
lp4
</PRE>
</CODE></BLOCKQUOTE>
<P>The last example is the simplest possible printcap entry.
This will cause LPRng clients to use the default values for everything.
The printer will be <CODE>lp4</CODE>,
i.e. - the name of the printcap,
and the server will be <CODE>localhost</CODE> if <CODE>force_localhost</CODE> is set,
or the value of the <CODE>default_remote_host</CODE> configuration option
if it is not.
<H2><A NAME="secprintcap"></A> <A NAME="mx"></A> <A NAME="cm"></A> <A NAME="ss8.2">8.2 Simple Server Printcap Example</A>
</H2>

<P>Options used:
<UL>
<LI> <CODE>cm=</CODE><EM>comment for status</EM></LI>
<LI> <CODE>if=</CODE><EM>default job file filter </EM></LI>
<LI> <CODE>lf=</CODE><EM>log file </EM></LI>
<LI> <CODE>mx=</CODE><EM>maximum job size</EM></LI>
<LI> <CODE>lp=</CODE><EM>output device</EM></LI>
<LI> <CODE>sd=</CODE><EM>spool directory file </EM></LI>
<LI> <CODE>sh</CODE><EM>&nbsp;&nbsp;suppress headers (banners) </EM></LI>
<LI> <CODE>sf</CODE><EM>&nbsp;&nbsp;suppress form feeds between files</EM></LI>
</UL>
<P>The previous section discussed printcap entries for use by the client programs.
Now we will discuss printcap entries for use by the <CODE>lpd</CODE> server.
In simple configurations or when we have the <CODE>force_localhost</CODE>
option enabled
we can use the same printcap for both LPRng clients and the <CODE>lpd</CODE>
server.
<P>
<BLOCKQUOTE><CODE>
<PRE>
# Local ASCII printer
lp1|printer
  :server
  :cm=Dumb printer
  :lp=/dev/lp1
  :sd=/var/spool/lpd/lp1
  :lf=log:af=acct
  :if=/usr/local/sbin/lpf
  :mx=0:sh:sf
</PRE>
</CODE></BLOCKQUOTE>
<P>
<OL>
<LI>The printcap entry name is <CODE>lp1</CODE>.
This information will be displayed when requesting status information using
the <CODE>lpq</CODE> program.</LI>
<LI>The <CODE>printer</CODE> alias.
This allows a single spool queue to have multiple names.</LI>
<LI>The <CODE>server</CODE> corresponds to the <CODE>client</CODE> flag
and indicates this printcap entry is for the <CODE>lpd</CODE>
server only.</LI>
<LI>The <CODE>cm</CODE> field supplies a information field
for <CODE>lpq</CODE> (printer status) output.</LI>
<LI> The <CODE>lp</CODE> value
specifies the destination file, device or remote spool queue to which data is sent.
In this example it is the device <CODE>/dev/lp1</CODE>.
By default,
IO devices are opened for <EM>write-only</EM> operation.</LI>
<LI>The <CODE>sd</CODE> specifies the <I>spool directory</I> where print job files
are stored until they are printed.</LI>
<LI> The <CODE>lf</CODE> and <CODE>af</CODE> options specify the names
for the log and accounting files, respectively.
These have the default values <CODE>log</CODE> and <CODE>acct</CODE> respectively,
and if not absolute pathnames are relative to the spool queue directory.
A log file is highly recommended.
If these files don't exist, they will not be created,
and no logging or accounting will be done. You will
need to create them manually (e.g., by using <CODE>touch</CODE>)
or by using the
<CODE>
<A HREF="LPRng-HOWTO-9.html#checkpc">checkpc</A></CODE>
program.</LI>
<LI>The <CODE>if</CODE> option specifies a filter program to be used
for jobs with the <CODE>f</CODE> or default job format format.
Filters and print formats are discussed in section
<A HREF="LPRng-HOWTO-13.html#secfilter">Filters</A>.
The <CODE>lpf</CODE> filter translates <CODE>LF</CODE> (line feed)
to <CODE>CR/LF</CODE> (carriage return/line feed) sequences,
eliminating <EM>staircase</EM> output.</LI>
<LI><CODE>mx</CODE> indicates the maximum file size for a print job.
Specifying 0 means that there is no limit.</LI>
<LI>The <CODE>sh</CODE> <I>suppress headers</I> flag will suppress
printing banner pages.</LI>
<LI>The <CODE>sf</CODE> <I>suppress form feeds</I> flag will suppress
form feeds between the files of a multi-file print job.</LI>
</OL>
<H2><A NAME="oh"></A> <A NAME="tc"></A> <A NAME="client"></A> <A NAME="server"></A> <A NAME="printcapparse"></A> <A NAME="ss8.3">8.3 The Printcap Parsing Rules</A>
</H2>

<P>Options used:
<UL>
<LI> <CODE>client</CODE><EM>&nbsp;&nbsp; printcap entry valid only for client programs </EM></LI>
<LI> <CODE>oh</CODE><EM>&nbsp;&nbsp; printcap entry valid only on these hosts </EM></LI>
<LI> <CODE>server</CODE><EM>&nbsp;&nbsp; printcap entry valid only for lpd server </EM></LI>
<LI> <CODE>tc</CODE><EM>&nbsp;&nbsp; add named printcap entry contents </EM></LI>
</UL>
<P>
<P>In this section,
we will discuss the remaining tricky parts of the LPRng printcap
database:
combined client and server printcaps,
host specific printcap entries,
and the
<CODE>tc</CODE> <I>include</I> facility.
<P>The following is a complete description of how a printcap file is processed:
<OL>
<LI>When processing a printcap file,
the LPRng software reads and parses each entry individually.
Leading whitespace is removed.
Lines starting with <CODE>#</CODE> and blank lines are ignored.</LI>
<LI>Lines ending with <CODE>\</CODE> will have the <CODE>\</CODE> discarded,
and all lines of a printcap entry are joined by removing the line separators (<CODE>\n</CODE>)
and replacing them with a space.</LI>
<LI>The printcap entry is parsed,
and the printcap name, aliases, and options are determined.
Colons <CODE>:</CODE> act as option separators,
and leading and trailing whitespaces are removed.</LI>
<LI>Options are sorted and expect for the 
<CODE>tc=...</CODE> option only the last option setting is retained.</LI>
<LI>Client programs will discard a printcap entry with a <CODE>server</CODE> option
and
server programs will discard a printcap entry with a <CODE>client</CODE> options.</LI>
<LI>The <CODE>oh</CODE> (<B>o</B>n this <B>h</B>ost) option specifies a list of
IP addresses and mask pairs or glob strings which are used to determine
if this printcap entry is valid for this host
(see discussion below).</LI>
<LI>After the above processing,
if there is an existing termcap entry with the same name,
the two sets of options are combined,
with the last option setting retained except for the <CODE>tc</CODE> entries
which are combined.</LI>
<LI>When a printcap entry is actually used,
the printcap entries listed by the <CODE>tc</CODE> include option
are extracted and combined in order.
(This allows include entries to appear after the referring printcap entry.)
Then printcap options will be combined with the included ones.
This has the effect that the options specified in the printcap entry
will override the ones from the <CODE>tc</CODE> included entries.</LI>
<LI>Finally,
each string printcap option with a <I>%X</I> value
has <I>%X</I> replaced by the following values.
Unspecified values will not be modified.
<BLOCKQUOTE><CODE>
<PRE>
%P           printcap name
%h           short host name  (host)
%H           fully qualified host name  (host.dns.whatever)
%R           remote printer (rp value)
%M           remote host (rm value)
%D           date in YYYY-MM-DD format
</PRE>
</CODE></BLOCKQUOTE>
</LI>
<LI>When parsing multiple printcap files,
these are processed in order,
and all of their printcap entries are combined according to the
above procedures.
The <CODE>tc</CODE> resolution and <I>%X</I> expansion is done after all the files
have been processed.</LI>
</OL>
<P>The following examples show how to use the above rules
to your advantage.
You can combine both client and server printcap information in
a single file
as well as dividing a printcap entry into several parts.
Here is an example:
<BLOCKQUOTE><CODE>
<PRE>
# seen by both client and server
lp1:lp=lp@pr1:mx=100
lp1:sd=/usr/local/spool/lp1:mx=0
# seen only by client
lp2:lp=lp@pr2:client
# seen only by server
lp2:lp=/dev/lp:server
</PRE>
</CODE></BLOCKQUOTE>

<OL>
<LI>Printcap entries with the same name are combined.
The first printcap entry, <CODE>lp1</CODE>,
the information is seen by both client and server.
The next printcap entry,  with the same name <CODE>lp1</CODE>,
will be combined with the second one.
The order of options is important - the entries are scanned in order
and an option will have the last value set.
Thus,
after having read both the <CODE>lp1</CODE> printcap entries,
both client and server will have:
<BLOCKQUOTE><CODE>
<PRE>
lp1:lp=lp@pr1
  :mx=0
  :sd=/usr/local/spool/lp1P
</PRE>
</CODE></BLOCKQUOTE>
</LI>
<LI>The <CODE>lp2</CODE> has a client and server version.
This is recommended when complex printcaps on multiple hosts and servers
are used.
Thus, the LPRng clients will see:
<BLOCKQUOTE><CODE>
<PRE>
lp1
  :lp=lp@pr1
  :mx=0
  :sd=/usr/local/spool/lp1P
lp2
  :client
  :lp=lp@pr2
</PRE>
</CODE></BLOCKQUOTE>

and the server will see:
<BLOCKQUOTE><CODE>
<PRE>
lp1
  :lp=lp@pr1
  :mx=0
  :sd=/usr/local/spool/lp1P
lp2
  :lp=/dev/lp
  :server
</PRE>
</CODE></BLOCKQUOTE>
</LI>
</OL>
<P>If you have multiple printers of the same type whose configuration is almost
identical,
then you can define a set of <I>tc</I> only printcap entries containing common
information
and use the <CODE>tc</CODE> include facility.
<P>By convention,
all printer names start with an alphanumeric character and contain only
alphanumeric values, underscore (<CODE>_</CODE>) or hyphen (<CODE>-</CODE>).
A printcap entry starting with
period (<CODE>.</CODE>),
question mark (<CODE>?</CODE>),
or
exclamation mark (<CODE>!</CODE>),
is processed by LPRng
but can only be used with the <CODE>tc</CODE> include facility.
For example:
<BLOCKQUOTE><CODE>
<PRE>
.hp:
  :sd=/usr/local/spool/%P
  :mx=0:sf:sh
hp1:tc=.hp,.filter
  :lp=lp@10.0.0.1
hp2:tc=.hp,.filter
  :lp=lp@10.0.0.2
.filter
  :if=/usr/local/bin/ifhp
  :lpd_bounce
</PRE>
</CODE></BLOCKQUOTE>

<OL>
<LI>The <CODE>.hp</CODE> and <CODE>.filter</CODE> printcap entities will not be used as
real printcaps by LPRng,
but can be referenced by the <CODE>tc</CODE> printcap include facility.
After <CODE>tc</CODE> include processing is completed,
the printcap information would resemble:
<BLOCKQUOTE><CODE>
<PRE>
hp1
  :lp=lp@10.0.0.1
  :if=/usr/local/bin/ifhp
  :lpd_bounce
  :mx=0
  :sd=/usr/local/spool/%P
  :sf
  :sh
hp2
  :lp=lp@10.0.0.2
  :if=/usr/local/bin/ifhp
  :lpd_bounce
  :mx=0
  :sd=/usr/local/spool/%P
  :sf
  :sh
</PRE>
</CODE></BLOCKQUOTE>
</LI>
<LI>The <I>%X</I> processing will replace <CODE>%P</CODE> with the
printcap name,
so we would have:
<BLOCKQUOTE><CODE>
<PRE>
hp1
  :lp=lp@10.0.0.1
  :mx=0
  :sd=/usr/local/spool/hp1
  :sf
  :sh
hp2
  :lp=lp@10.0.0.2
  :mx=0
  :sd=/usr/local/spool/hp2
  :sf
  :sh
</PRE>
</CODE></BLOCKQUOTE>
</LI>
</OL>
<P>When administering a large number of printers over a large area,
it is sometimes desirable to have a <I>default</I> printer for
each host.
This default printer may be different for each host,
and can be selected by using the <CODE>oh</CODE> entry.
The <CODE>oh</CODE> value is a list of the following entries
<BLOCKQUOTE><CODE>
<PRE>
IP/n     - address + mask length    10.0.0.0/8
IP/IP    - address + mask           10.0.0.0/255.0.0.0
vvv      - glob for hostname        pc*.org.com    
</PRE>
</CODE></BLOCKQUOTE>
<P>The LPRng software will determine the hostnames and IP addresses assigned to the
host and then check to see if there is a match in the listed hostnames
or IP addresses.
If there is a match,  the printcap entry will be used.
If not,  then the entry will be discarded.
For example:
<BLOCKQUOTE><CODE>
<PRE>
lp:oh=*.admin.org.com,10.0.0.5,10.2.0.0/16:lp=pr1@server1
lp:oh=*.eng.org.com:lp=hp@server2
</PRE>
</CODE></BLOCKQUOTE>

<OL>
<LI>In the above example,
if our host name is
<CODE>booster.admin.org.com</CODE>,
then we would use <CODE>lp=pr1@server1</CODE>,
as the <CODE>*.admin.org.com</CODE> glob pattern would match our host name.</LI>
<LI>if our host name is
<CODE>booster.dev.org.com</CODE> and our IP address is 10.2.0.1,
then we would use <CODE>lp=pr1@server1</CODE>,
as the <CODE>10.2.0.0/16</CODE> ip address would be in the specified address range.</LI>
</OL>
<H2><A NAME="ss8.4">8.4 Displaying Printcap Information</A>
</H2>

<P>If you are generating complex printcap entries,
you might need to find out exactly what the LPRng servers or clients
will actually see.
The LPRng software has several diagnostic tools to help you.
The most simple to use is the
<CODE>lpc</CODE> program.
<P>The <CODE>lpc client all</CODE> and 
<CODE>lpc server all</CODE> commands will display the printcap information that the
LPRng clients and <CODE>lpc</CODE> server would see when executing on the host.
For example:
<BLOCKQUOTE><CODE>
<PRE>
#> lpc client all
lp1
  :lp=lp@pr1
  :mx=0
  :sd=/usr/local/spool/lp1P
lp2
  :client
  :lp=/dev/lp
</PRE>
</CODE></BLOCKQUOTE>
<H2><A NAME="ss8.5">8.5 Remote Printer Using RFC1179</A>
</H2>

<P>Options used:
<UL>
<LI> <CODE>lp=</CODE><EM>destination</EM></LI>
<LI> <CODE>rm=</CODE><EM>remote host (machine)</EM></LI>
<LI> <CODE>rp=</CODE><EM>remote printer (machine)</EM></LI>
</UL>
<P>You can have the <CODE>lpd</CODE> server forward jobs to another server
or print which supports the RFC1179 protocol by using the
following printcap:
<BLOCKQUOTE><CODE>
<PRE>
# Simplest
remote|Remote Printer
   :lp=raw@server
# historical
remote:
  rp=raw:rm=server
# Sometimes you have to connect to a non-standard port
special:lp=lp@server%2000
</PRE>
</CODE></BLOCKQUOTE>

<OL>
<LI>If the <CODE>lp</CODE> printer entry is present, it will override the
<CODE>rm</CODE> and <CODE>rp</CODE> printer entries.</LI>
<LI>The <CODE>lp=pr@host</CODE> format specifies that the output device is actually
a remote spool queue,
and jobs should be transferred using RFC1179 protocol.</LI>
<LI>By default,
LPRng will attempt to
<B>sanitize</B> all jobs that it originates or forwards.
This sanitization will result in an RFC1179 compliant <CODE>control file</CODE>,
and will not modify any of the job information.</LI>
</OL>
<H2><A NAME="ss8.6">8.6 Remote Printer Using Socket API</A>
</H2>

<P>If the spool queue destination is a remote printer supporting the
Socket API,
then you can have LPRng open a connection directly to the printer.
These include the older Apple printers with TCP/IP support and the
HP JetDirect supported printers.
<BLOCKQUOTE><CODE>
<PRE>
# Simplest
remote
   :lp=10.24.2.3%9100
   :sh:sf
</PRE>
</CODE></BLOCKQUOTE>

<OL>
<LI>The <CODE>lp=server%port</CODE> or <CODE>lp=IPaddr%port</CODE> format
specifies that <CODE>lpd</CODE> should open a TCP/IP connection to the remote
host and simply transfer verbatum the files to be printed.</LI>
<LI>The <CODE>sh</CODE> and <CODE>sf</CODE> will prevent <CODE>lpd</CODE> from trying to generate
banner pages or put form feeds between jobs.</LI>
</OL>
<P>While this is the simplest printcap,
it is also the most dangerous as there is nothing to prevent
a malformed job from being sent to the printer.
The next printcap example is much more robust:
<BLOCKQUOTE><CODE>
<PRE>
# Simplest
remote
   :lp=10.24.2.3%9100
   :of=/usr/local/lib/ifhp
   :if=/usr/local/lib/ifhp
   :sh:sf
</PRE>
</CODE></BLOCKQUOTE>

<OL>
<LI>This version will use the <CODE>ifhp</CODE> filter to precondition the printer
and to process jobs.
See 
<A HREF="LPRng-HOWTO-13.html#ifhp">IFHP Filter</A> for details.
The <CODE>ifhp</CODE> filter will perform the appropriate printer resets,
translate job information,
and ensure correct printer operation in the presence of errors.
It will also produce voluminous error messages and status information.</LI>
</OL>
<H2><A NAME="ss8.7">8.7 Parallel Printer</A>
</H2>

<P>The parallel printer printcap is very simple.
<BLOCKQUOTE><CODE>
<PRE>
# parallel printer
lp:
   :lp=/dev/lpr
   :sh:sf
</PRE>
</CODE></BLOCKQUOTE>

<OL>
<LI>The <CODE>lp=/dev/lpr</CODE>
specifies that <CODE>lpd</CODE> should open the device for APPEND and simply transfer
job files to it.</LI>
<LI>The <CODE>sh</CODE> and <CODE>sf</CODE> will prevent <CODE>lpd</CODE> from trying to generate
banner pages or put form feeds between jobs.</LI>
</OL>
<P>If you discover that UNIX print jobs result in a <I>staircase</I>
appearance,
then you need to force your printer to do <CODE>LF</CODE> (linefeed) to <CODE>CR/LF</CODE>
(carriage return/line feed) translation,
or do the translation yourself.
<BLOCKQUOTE><CODE>
<PRE>
# Simple parallel printer
lp:
   :lp=/dev/lpr
   :if=/usr/local/bin/lpf
   :sh:sf
</PRE>
</CODE></BLOCKQUOTE>
<P>By using the <CODE>if=...lpf</CODE> filter,
the job will be passed through the <CODE>lpf</CODE> filter,
which will do the <CODE>LF</CODE> to <CODE>CR/LF</CODE> translation.
<P>If you have a more complex printer that handles PostScript, PCL, and PJL,
then you will need to use the more powerful
<CODE>ifhp</CODE> filter:
<BLOCKQUOTE><CODE>
<PRE>
# Simple parallel printer
lp:
   :lp=/dev/lpr
   :ifhp=model=hp4,status@
   :of=/usr/local/bin/ifhp
   :if=/usr/local/bin/ifhp
   :sh:sf
</PRE>
</CODE></BLOCKQUOTE>
<P>See 
<A HREF="LPRng-HOWTO-13.html#ifhp">IFHP Filter</A> for details.
This entry will specify that the printer is an HP4,
and that no status information is available.
This is usually the case with a parallel port.
<H2><A NAME="stty"></A> <A NAME="br"></A> <A NAME="ss8.8">8.8 A serial printer queue</A>
</H2>

<P>Options used:
<UL>
<LI> <CODE>rw</CODE><EM>&nbsp;&nbsp;device opened RW flag</EM></LI>
<LI> <CODE>br#</CODE><EM>serial port bit rate</EM></LI>
<LI> <CODE>stty=</CODE><EM>stty options for serial port configuration</EM></LI>
</UL>
<P>The following is a typical printcap for a serial printer:
<BLOCKQUOTE><CODE>
<PRE>
# Local Serial ASCII printer
lp2
  :lp=/dev/ttya
  :rw
  :cm=Serial printer
  :sd=/var/spool/lpd/lp2
  :stty=9600 -echo -crmod -raw -oddp -evenp pass8 cbreak ixon
  :if=/usr/local/sbin/lpf
  :mx=0:sh
</PRE>
</CODE></BLOCKQUOTE>
<P>Let's examine the new options:
<OL>
<LI>A serial port is usually <EM>bidirectional</EM>,
and printers will report errors back to the host computer.
The <CODE>rw</CODE> flag will cause the printer port to be opened 
<CODE>read-write</CODE>,
and the <CODE>lpd</CODE> server will report status information.</LI>
<LI>The <CODE>sy</CODE> option specifies the <CODE>stty(1)</CODE>
flags and line speed needed to configure the serial line
(See
<A HREF="LPRng-HOWTO-3.html#secserial">Serial Printers</A>
for details).</LI>
<LI>The legacy <CODE>br</CODE> (bit rate) option
can be used to specify the line speed as well.</LI>
</OL>
<H2><A NAME="secoh"></A> <A NAME="ss8.9">8.9 Single Printcap File for Large Installation</A>
</H2>

<P>One of the major problems faced by administrators of large sites is how
to distribute printcap information.
They would like to have a single printcap file either distributed by
a file server (NFS) or by some other method such as <CODE>rdist</CODE>.
By using the
<CODE>server</CODE>
and
<CODE>oh</CODE>
tags,
information for the specific sites can be separated out.
For example:
<BLOCKQUOTE><CODE>
<PRE>
#/etc/printcap file
pr1:lp=pr1@serverhost1:oh=*.eng.site.com,130.191.12.0/24
pr2:lp=pr1@serverhost1:oh=*.eng.site.com,130.191.12.0/24
pr1:lp=pr2@serverhost2:oh=*.admin.site.com
pr2:lp=pr2@serverhost2:oh=*.admin.site.com
pr1:server:oh=serverhost1.eng.com:lp=/dev/lp:tc=.common
pr2:server:oh=serverhost2.admin.com:lp=/dev/lp:tc=.common
.common:sd=/usr/local/lpd/%P
</PRE>
</CODE></BLOCKQUOTE>
<P>The above example has some interesting effects.
The <CODE>pattern</CODE> is used as a <EM>glob</EM> pattern
and is applied to the fully qualified domain name (FQDN) of the
host reading the printcap file.
For example,
<CODE>*.eng.site.com</CODE> would match host
<CODE>h1.eng.site.com</CODE>
but would not match
<CODE>h1.admin.site.com</CODE>.
Thus, the effects of the first couple of entries would be to
specify that the
<CODE>pr1</CODE> and <CODE>pr2</CODE> printers on the
<CODE>eng</CODE> hosts would be <CODE>pr1@serverhost1</CODE>,
and on the
<CODE>admin</CODE> hosts would be <CODE>pr2@serverhost2</CODE>,
<P>Also,
the lpd daemons on
<CODE>serverhost1</CODE>
and
<CODE>serverhost2</CODE>
would extract the additional
information for
<CODE>pr1</CODE>
and
<CODE>pr2</CODE> respectively,
overriding the common <CODE>lp</CODE> entries.
<H2><A NAME="bouncequeues"></A> <A NAME="bqformat"></A> <A NAME="lpdbounce"></A> <A NAME="bq"></A> <A NAME="ss8.10">8.10 Bounce queues</A>
</H2>

<P>Options used:
<UL>
<LI> <CODE>lpd_bounce</CODE>&nbsp;&nbsp;<EM>lpd filters and then forwards</EM></LI>
<LI> <CODE>bq=</CODE><EM>destination for filtered job</EM></LI>
<LI> <CODE>bq_format=</CODE><EM>format of filtered job</EM></LI>
</UL>
<P>When the destination of a spool queue is another spool queue
the job is simply forwarded without any modifications.
However,
sometimes it is essential that the job be modified before
forwarding,
as when the remote spool queue is actually a printer,
and
jobs need to be converted to the format acceptable by
the remote printer or banner pages added.
<P>The <CODE>lpd_bounce</CODE> flag marks a spool queue as a bounce queue.
<CODE>Lpd</CODE> will perform all of the usually job processing steps,
such as banner generation,
filtering files,
etc,
but
saves the output to a file.
This file is then sent to the destination print queue for further
processing.
<P>
<BLOCKQUOTE><CODE>
<PRE>
# Simple example of a bounce queue
bounce:lp=bounce@bouncehost
bounce:server
    :lp=lp@remote
    :lpd_bounce
    # LEGACY
    #bq=lp@remote
    :sd=/usr/spool/lpd/%P
    :if=/usr/local/bin/lpf
    :vf=/usr/local/bin/lpf
    :bq_format=l
    # uncomment ab if you want banner
    #ab
</PRE>
</CODE></BLOCKQUOTE>
<P>Some comments:
<P>
<OL>
<LI>The
<CODE>lpd_bounce</CODE>
option marks the job as a bounce queue,
and the <CODE>lpd</CODE> server will process the job through the appropriate
filter programs.</LI>
<LI>The legacy <CODE>bq=host</CODE>
has the same effect as
<CODE>lpd_bounce</CODE>.
This option is retained for compatibility with previous versions of LPRng.
It is recommended that this option not be used.</LI>
<LI>The printcap has filter specifications for different job formats.
These are the programs that will be used by LPRng to process the job.</LI>
<LI>The
<CODE>bq_format</CODE>
specifies the job format for the output file sent to the remote spool queue.
If not specified, it defaults to
<CODE>l</CODE> (literal or binary).</LI>
<LI>The <CODE>ab</CODE>
(always print a banner) flag will force a banner to be
added to the job.
The banner generation is done as discussed in
<A HREF="LPRng-HOWTO-12.html#bannerprinting">Banner Printing</A>.</LI>
</OL>
<H2><A NAME="translateformat"></A> <A NAME="ss8.11">8.11 Changing Job Formats</A>
</H2>

<P>Options used:
<UL>
<LI> <CODE>translate_format=</CODE><EM>format of filtered job</EM></LI>
</UL>
<P>A rarely encountered problem is when a job is printed with
one format but for compatibility needs to be processed with another.
The simple
<CODE>translate_format=vlxf</CODE>
option will rename format
<CODE>x</CODE>
files to
<CODE>f</CODE> format.
<P>This can be used to resolve problems with PC based software,
which spools jobs using the <CODE>v</CODE> format.
Unfortunately,
many RCF1179 print spoolers do not understand the
<CODE>v</CODE> format and mishandle the job.
A simple forwarding queue with the following entries will rename
<CODE>v</CODE> format to <CODE>l</CODE> (binary) format.
<BLOCKQUOTE><CODE>
<PRE>
lp
  :sd=/usr/spool/lpd/%P
  :translate_format=vl
  :lp=lp@printerserver
</PRE>
</CODE></BLOCKQUOTE>
<H2><A NAME="lprbounce"></A> <A NAME="ss8.12">8.12 LPR Filters Files</A>
</H2>

<P>Options used:
<UL>
<LI> <CODE>lpr_bounce</CODE><EM>&nbsp;&nbsp;lpr does filtering</EM></LI>
</UL>
<P>Some users would like the advantages of
the filtering and processing capabilities of a lpd daemon
without running a lpd daemon on their system.
By having the <CODE>lpr</CODE> program
process the job by passing it through the various filters
and then send the output of the filters as the print job you can
get the desired effect.
<BLOCKQUOTE><CODE>
<PRE>
# Simple example of an lpr_bounce entry
bounce
  :lpr_bounce
  :lp=lp@remote
  :if=/usr/local/bin/lpf
</PRE>
</CODE></BLOCKQUOTE>
<P>The
<CODE>lpr_bounce</CODE>
flag, if present in the printcap entry,
will force <CODE> lpr </CODE> to process the job using the
specified filters and send the outputs of the filters to the remote printer
for further processing.
<H2><A NAME="routing"></A> <A NAME="router"></A> <A NAME="destinations"></A> <A NAME="ss8.13">8.13 Dynamic Routing</A>
</H2>

<P>Options used:
<UL>
<LI> <CODE>destinations=</CODE><EM>destinations for jobs</EM></LI>
<LI> <CODE>router=</CODE><EM>router program</EM></LI>
</UL>
<P>LPRng has the ability to route a job to one or
more destinations in a dynamic manner.
This is not the same as
<I>load balancing</I>,
as the destinations are hard coded and not able to be changed.
This is accomplished by having
a <CODE>router</CODE> filter generate a set of destinations.
Here is a sample printcap entry:
<BLOCKQUOTE><CODE>
<PRE>
t2|Test Printer 2
    :sd=/var/spool/LPD/t2
    :lf=log
    :destinations=t1@server1,t1@server2,t1@localhost
    :router=/usr/local/LPD/router
</PRE>
</CODE></BLOCKQUOTE>
<P>When a job arrives at the <CODE>lpd</CODE> server,
the 'router' filter
is invoked with the standard filter options which include
the user, host, and other information obtained from the control file.
STDIN is connected to a temporary copy of the control file,
and the CONTROL environment variable is set to the value of the
actual control file itself.
<P>The routing filter exit status is used as follows:
<UL>
<LI>0  (JSUCC) - normal processing</LI>
<LI>37 (JHOLD) - job is held</LI>
<LI>any other value - job is deleted from queue</LI>
</UL>
<P>The router filter writes to STDOUT a file specifying the destinations
for the job.
The destinations entries in this file file have the following format.
Entry order is not important,
but each destination must end with the 'end' tag.
<BLOCKQUOTE><CODE>
<PRE>
dest (destination queue)
copies (number of copies to be made)
priority (priority letter)
X(controlfile modifications)
end
</PRE>
</CODE></BLOCKQUOTE>
<P>Example of router output:
<BLOCKQUOTE><CODE>
<PRE>
dest t1@localhost
copies 2
CA
priority B
end
dest t2@localhost
CZ
priority Z
end
</PRE>
</CODE></BLOCKQUOTE>
<P>In this example,
two copies of the job will be sent to the t1 and t2 spool queue servers.
The Class (C letter value) and job priority information will be rewritten
with the indicated values.
<P>If routing information
is specified by the router filter the job will be sent to the default
destination.
<P>LPQ will display job information in a slightly different format
for multiple destination jobs.  For example:
<PRE>
Printer: t2@astart2 'Test Printer 2' (routed/bounce queue to 't1@astart2.astart.com')
  Queue: 1 printable jobs in queue
 Rank  Owner/ID        Class Job Files                           Size Time
active  papowell@astart2+707 A 707  /tmp/hi                         3 10:04:49
 - actv papowell@astart2+707.1 A 707 ->t1@localhost &lt;cpy 1/2>       3 10:04:49
 -      papowell@astart2+707.2 A 707 ->t2@localhost                 3 10:04:49
</PRE>
<P>The routing information is displayed below the main job information.
Each destination will have its transfer status displayed as it is
transferred.  By convention,  the job identifier of the routed jobs
will have a suffix of the form .N added;  copies will have CN added
as well.  For example, papowell@astart2+707.1C2 will be the job
sent to the first destination, copy two.
<P>Routed jobs can be held, removed, etc., just as normal jobs.  In addition,
the individual destination jobs can be manipulated as well.  The LPC
functionality has been extended to recognize destination jobids as well
as the main job id for control and/or selection operations.
<P>The optional
<CODE>destinations</CODE> entry specifies the possible set of
destinations that the job can be sent to,
and is for informational purposes only.
In order for LPQ/LPRM to find the job once it has passed through LPD,
LPQ/LPRM uses the list of printers in the
<CODE>destinations</CODE>,
and loop over all the names in the list looking for the "job" that you are interested in.
If there is no
<CODE>destinations</CODE>
information, the
<CODE>bq</CODE> information will be used.
<P>Lars Anderson &lt;<CODE>lsa@business.auc.dk</CODE>&gt; supplied this example
(slightly edited):
<P>This script will attempt to distribute print jobs evenly on
2 printers hpl5a and hpl5b when sending to hpl5bounce.
<P>
<BLOCKQUOTE><CODE>
<PRE>
hpl5bounce|for PLP/LPRng software - network based HP JetDirect card:
        :lpd_bounce
        #default
        :rp=hpl5b
        :destinations=hp5a,hp5b
        :router=/usr/local/admscripts/bouncer.pl
hpl5a|for PLP/LPRng software - network based HP JetDirect card:
        :lp=hpl5a%9100
        :tc=.hplcommon
hpl5b|for PLP/LPRng software - network based HP JetDirect card:
        :lp=hpl5b%9100
        :tc=.hplcommon
# Common settings
.hplcommon:
        :sd=/var/spool/lpd/%P
        :rw:sh:ps=status
        :fx=flp
        :if=/usr/local/lib/filters/ifhp -Tbanner=on
        :of=/usr/local/lib/filters/ofhp -Tbanner=on
</PRE>
</CODE></BLOCKQUOTE>
<P>The perl script <CODE>bouncer.pl</CODE> looks like this:
<P>
<BLOCKQUOTE><CODE>
<PRE>
#!/usr/bin/perl
#
# Script for printjob load sharing
#   This is static, not dynamic balancing
#
# Printqueues to check
$printer1=&quot;hpl5a\@localhost&quot;;
$printer2=&quot;hpl5b\@localhost&quot;;
# obtain number of jobs in each printqueue
$lpq1=`/usr/local/bin/lpq -s -P$printer1`;
$lpq2=`/usr/local/bin/lpq -s -P$printer2`;
$lpq1=~ (/(\d+) jobs?/); $numjobs1=$1;
$lpq2=~ (/(\d+) jobs?/); $numjobs2=$1;
if ($numjobs1 == 0) {
    print &quot;dest $printer1\nCA\nend\n&quot;;
    exit;
}
if ($numjobs1 &gt; $numjobs2) {
    print &quot;dest $printer2\nCA\nend\n&quot;;
    exit;
}
print &quot;dest $printer1\nCA\nend\n&quot;; 
</PRE>
</CODE></BLOCKQUOTE>
<H2><A NAME="ss8.14">8.14 Printer Load Balancing</A>
</H2>

<P>In a large site, you could have several equivalent printers, which
will be used by many people. The reason for this is, of course, to
increase the printer output by enabling several jobs to be printed at
once.
<P>LPRng supplies mechanisms to define a `virtual' printer for such a set
of real printers. If properly set up, print jobs will be distributed
evenly over all printers.
<P>
<H3><A NAME="sv"></A> <A NAME="ss"></A> Multi-server print queue</H3>

<P>Options used:
<UL>
<LI> <CODE>ss=</CODE><EM>queue served by printer </EM></LI>
<LI> <CODE>sv=</CODE><EM>printers where jobs are sent (servers)</EM></LI>
</UL>
<P>A multi-server print queue is one that feeds jobs to other queues.
The main queue
<CODE>sv=q1,q2,...</CODE> printcap entry specifies the names of the printers
that will be sent jobs.
These printers must have their spool queues on this LPD server.
<P>Servers that are fed jobs have a
<CODE>ss=</CODE><EM>mainqueue</EM>
printcap entry.
This informs the <CODE>lpd</CODE> server that the queue operates under the
control of the <EM>mainqueue</EM> print queue,
and is fed jobs from it.
<P>During normal operation,
when the <CODE>lpd</CODE> server has a job to print in the <EM>mainqueue</EM>,
it will check to see if there is an idle <EM>service</EM>  queue.
If there is,
it will transfer the job to the service queue spooling directory
and start the service queue printing activities.
<P>Users can send jobs directly to the individual printers serving a queue.
<P>The next example (and the comments underneath) was supplied by John Perkins
&lt;<CODE>john@cs.wisc.edu</CODE>&gt; (slightly edited).
<P>Here's how I've set up a bounce queue that feeds 6 LaserWriters:
<P>
<BLOCKQUOTE><CODE>
<PRE>
laser|pi|Room 1359 LaserWriters
    :lp=laser@server.com
laser|pi|Room 1359 LaserWriters
    :server
    :lf=/usr/adm/laser-log
    :sv=laser1,laser2,laser3,laser4,laser5,laser6
    :sd=/usr/spool/laser
.commonlaser
    :sd=/usr/spool/%P
    :rw:mx=0:sh
    :lf=/usr/adm/laser1-log
    :if=/s/lprng/lib/filters/cappsif
    :of=/s/lprng/depend/cap/bin/papof
    :ss=laser
    :fx=fdginpt
laser1|pi1|Room 1359 LaserWriter #1
    :lp=laser1@server.com
laser1|pi1|Room 1359 LaserWriter #1
    :server
    :lp=/dev/laser1
    :tc=.commonlaser
laser2|pi2|Room 1359 LaserWriter #1
    :lp=laser2@server.com
laser2|pi2|Room 1359 LaserWriter #2
    :server
    :lp=/dev/laser2
    :tc=.commonlaser
</PRE>
</CODE></BLOCKQUOTE>
<P>and so on for the other 4 <CODE>laser</CODE><EM>N</EM> queues.
<P>This will forward a job from <CODE>laser</CODE> to <CODE>laser</CODE><EM>N</EM>, once
one of those queues is available. It will hold jobs in the
``<CODE>laser</CODE>'' queue until one of the other queues is empty.
<P>Even though the queues are not meant for
direct use,
people can print directly to individual queues.
This allows a specific load sharing printer to be used.
If you wanted to
<EM>hide</EM> the load sharing printers,
i.e. - not allow direct spooling to them,
then you would simply remove the non-server entries from the printcap.
<H3><A NAME="checkidle"></A> Checking Busy Status of Server Queues</H3>

<P>Options used:
<UL>
<LI> <CODE>check_idle=</CODE><EM>check for idle printer program </EM></LI>
</UL>
<P>The previous section outlined how LPRng uses the <CODE>sv</CODE> and <CODE>ss</CODE>
flags to indicate that the server spool queue has multiple destination queues.
However,
there is a problem when the actual printer being served by the destination queue
is a remote device,
and can be busy or offline.
<P>The <CODE>check_idle</CODE> option specifies a program that is invoked by the
<CODE>lpd</CODE>
server to determine if the spool queue device is available.
<P>The program is invoked with the standard filter options,
STDIN and STDOUT connected to <CODE>/dev/null</CODE>,
and STDERR to the status file.
<P>The program should make a connection to the remote device or system
and should determine that the remote device is available for use,
and then exit with the following status.
<BLOCKQUOTE><CODE>
<PRE>
Key      Value   Meaning
JSUCC    0       Successful - printer is idle
JABORT   non-zero Printer is not accepting jobs
</PRE>
</CODE></BLOCKQUOTE>
<P>If the printer is accepting jobs but is temporarily busy,
the program should poll the printer until it becomes free,
only exiting when it is available for use.
If the printer is not accepting jobs, the program should exit with a non-zero
exit code. 
<P>The following is a sample printcap entry, showing how the <CODE>check_idle</CODE>
facility can be used.
<BLOCKQUOTE><CODE>
<PRE>
pr:
  :lp=laserjet%9100
  :check_idle=/usr/local/filters/remote_check lp@laserjet
  :if=/usr/local/filters/ifhp
</PRE>
</CODE></BLOCKQUOTE>
<P>The following perl program shows how to generate a query to the
remote printer by simulating an <CODE>lpq</CODE> query and checking for
returned status.
<BLOCKQUOTE><CODE>
<PRE>
#!/usr/local/bin/perl
# Usage:
#  remote_check printer@host[%port] [-options]
#   -Tflag[,flags]*
#  flag
#    debug  - turns debugging on
#    long   - use long status format
#
# query the remote printer whose name is passed on the command line
# 
# Note that -Txxx options are passed AFTER the printer
use English;
use IO::Socket;

my $JSUCC = 0;
my $JABORT = 33;
my $JNOSPOOL = 38;
my $JNOPRINT = 39;

my $debug = 0;
my $optind;

# pull out the options
my($key,$value,$opt,$long,$opt_c);

$printer = $ARGV[0];

for( $i = 1; $i &lt; @ARGV; ++$i ){
    $opt = $ARGV[$i];
    print STDERR "XX opt= $opt\n" if $debug;
    if( $opt eq '-c' ){
        $opt_c = 1;
    } elsif( ($key, $value) = ($opt =~ /^-(.)(.*)/) ){
        if( $value eq "" ){
            $value = $ARGV[++$i];
        }
        ${"opt_$key"} = $value;
        print STDERR "XX opt_$key = " . ${"opt_$key"} . "\n" if $debug;
    } else {
        $optind = $i;
        last;
    }
    print STDERR "XX opt_P = $opt_P\n" if $debug;
}

$long = 0;  # short

if( defined($opt_T) ){
    print STDERR "XX CHECK_REMOTE opt_T=$opt_T\n" if $debug;
    if( $opt_T =~ /debug/ ){
        $debug = 1;
    }
    if( $opt_T =~ /short/ ){
        $long = 1;
    }
    if( $opt_T =~ /long/ ){
        $long = 0;
    }
}

print STDERR "XX CHECK_REMOTE " . join(" ",@ARGV) . "\n" if $debug;

if( !defined($printer) or $printer =~ /^-/ ){
    print STDERR "$0: no printer value\n";
    exit( $JABORT );
}

while( checkstatus( $printer, $long ) ){
    print STDERR "XX CHECK_REMOTE sleeping\n" if $debug;
    sleep(10);
}

exit $JSUCC;

sub checkstatus {
    my ($printer,$long) = @_;
    my ($remote,$port);
    my ($count, $socket, $line);

    if( $long ){
        $long = 4;
    } else {
        $long = 3;
    }
    if( $printer =~ /@/ ){
        ($printer,$remote) = $printer =~ m/(.*)@(.*)/;
    }
    $remote="localhost" unless $remote;

    if( $remote =~ /%/ ){
        ($remote,$port) = $remote =~ m/(.*)%(.*)/;
    }
    $port = 515 unless $port;
    print STDERR "XX CHECK_REMOTE remote='$remote',"
        . " port='$port', pr='$printer', op='$long'\n" if $debug;

    $socket = getconnection( $remote, $port );

    $count = -1;
    # send the command
    printf $socket "%c%s\n", $long, $printer;

    while ( defined( $line = &lt;$socket>) &amp;&amp; $count &lt; 0 ){
        chomp $line;
        print STDERR "XX CHECKREMOTE '$line'\n" if $debug;
        if( $line =~ /printing disa/ ){
            print STDERR "XX CHECKREMOTE printing disable\n" if $debug;
            exit $JNOPRINT;
        } elsif( $line =~ /spooling disa/ ){
            print STDERR "XX CHECKREMOTE printing disable\n" if $debug;
            exit $JNOSPOOL;
        } elsif( $line =~ /([0-9]*)\s+job.?$/ ){
            $count = $1;
            print STDERR "XX CHECKREMOTE $count jobs\n" if $debug;
        }
    }
    close $socket;
    if( $count &lt; 0 ){
        print STDERR "CHECKREMOTE cannot decode status\n";
        exit $JABORT;
    }
    return $count;
}

sub getconnection {
    my ($remote,$port) = @_;
    my ($socket);
    print STDERR "XX CHECK_REMOTE remote='$remote', port=$port\n" if $debug;
    $socket = IO::Socket::INET->new(
        Proto => "tcp",
        PeerAddr => $remote,
        PeerPort => $port,
        );
    if( !$socket ){
        print STDERR "CHECK_REMOTE IO::Socket::INET failed - $!\n";
        exit $JABORT;
    }
    $socket->autoflush(1);
    $socket;
}
</PRE>
</CODE></BLOCKQUOTE>
<P>The example of the previous section can be modified now
so that it uses the <CODE>check_idle</CODE> facility.
The master queue will send jobs only to the server queue queues
which report idle status.
<BLOCKQUOTE><CODE>
<PRE>
laser1|pi1|Room 1359 LaserWriter #1
    :server:check_idle=/usr/local/lib/filters/remote_check pr@laser1
    :lp=laser1%9100
    :tc=@commonlaser
laser2|pi2|Room 1359 LaserWriter #2
    :server:check_idle=/usr/local/lib/filters/remote_check pr@laser1
    :lp=laser2%9100
    :tc=@commonlaser
</PRE>
</CODE></BLOCKQUOTE>
<H2><A NAME="details"></A> <A NAME="printcappath"></A> <A NAME="lpdprintcappath"></A> <A NAME="ss8.15">8.15 Locations of Printcap Files</A>
</H2>

<P>Options used:
<UL>
<LI> <CODE>printcap_path=</CODE><EM>printcap file locations</EM></LI>
<LI> <CODE>lpd_printcap_path=</CODE><EM>additional server printcap file locations</EM></LI>
</UL>
<P>The
<CODE>printcap_path </CODE>
and
<CODE> lpd_printcap_path </CODE>
configuration options (see
<A HREF="LPRng-HOWTO-11.html#lpdconf">lpd.conf(5)</A>) specify a set of paths for the
printcap information.
Client programs use only <CODE>printcap_path</CODE> and the <CODE>lpd</CODE>
server uses both
<CODE>printcap_path</CODE> and <CODE>lpd_printcap_path</CODE>.
The path names can be separated with whitespace,
commas, semicolons, or colons.
The default values are:
<BLOCKQUOTE><CODE>
<PRE>
printcap_path      /etc/printcap /usr/etc/printcap
lpd_printcap_path  /etc/lpd_printcap /usr/etc/lpd_printcap
</PRE>
</CODE></BLOCKQUOTE>
<H3>Separate Server and Client Printcap Files</H3>

<P>Since only the LPD server uses the
printcap file specified by the
<CODE>lpd_printcap_path</CODE>,
you can place server specific information there.
This allows you to have a common printcap file for clients and an
additional one for the lpd servers.
<H3>ALL Printcap Entry</H3>

<P>The <CODE>all</CODE> printcap name and <CODE>all</CODE> option
is reserved to provide a list of printers
available for use by the spooling software.
This is a desperation,
last ditch,
back to the wall option for
administrators
with systems that do not have ways to provide a list of printcap entries.
The 'all' printcap entry has the form:
<BLOCKQUOTE><CODE>
<PRE>
all:all=pr1,pr2,...
</PRE>
</CODE></BLOCKQUOTE>
<P>The value of the <CODE>all</CODE> option should be a list of printcap names
whose values will then be extracted.
<H2><A NAME="ss8.16">8.16 Management Strategies for Large Installations</A>
</H2>

<P>One very effective way to organize print spooling is to have a small
number of print servers running a
<CODE>lpd</CODE> daemon,
and to have all the other systems send their jobs directly to them.
By using the above methods of specifying the printer and server host
you eliminate the need for more complex management strategies.
<P>However,
you still need to inform users of the names and existence of these printers,
and how to contact them.
One method is to use a common
<CODE>/etc/printcap</CODE>
file which is periodically updated and transfered to all sites.
Another method is to distribute the information using the
NIS or some other database.
LPRng has provided a very flexible method of obtaining and distributing
database information:  see
<A HREF="#secnis">Using Programs To Get Printcap Information</A>
for details.
<H2><A NAME="secnis"></A> <A NAME="ss8.17">8.17 Using Programs To Get Printcap Information</A>
</H2>

<P>In the
<CODE>lpd.conf</CODE>
file you can specify:
<BLOCKQUOTE><CODE>
<PRE>
printcap_path=|program
</PRE>
</CODE></BLOCKQUOTE>

This will cause the LPRng software to execute the specified program,
which should then provide the printcap information.
The program is invoked with the standard filter options,
and has the name of the printcap entry provided on
<CODE>STDIN</CODE>.
The filter
should supply the printcap information on
<CODE>stdout</CODE>
and exit with a 0
(success) error code.  By convention,  the printcap name 'all'
requests a printcap entry that lists all printers.
<P>This technique has been used to interface to the Sun Microsystem NIS
and NIS+ databases with great success.
By having the invoked program a simple shell script or front end to the
<CODE>nismatch</CODE> or <CODE>ypmatch</CODE> programs,
the complexity of incorporating vendor specific code is avoided.
<H3>How to use NIS and LPRng</H3>

<P>This note is based on material sent to the
<CODE>lprng@lprng.org</CODE>
mailing list by
Paul Haldane
<CODE>&lt;paul@ucs.ed.ac.uk></CODE>.
<P>
<BLOCKQUOTE><CODE>
<PRE>
 # From: Paul Haldane &lt;paul@ucs.ed.ac.uk>
 # To: lprng@lprng.org
 # Subject: Re: Problem using plp with NIS
 # 
</PRE>
</CODE></BLOCKQUOTE>
<P>We generally don't use NIS for printcap files (we've
moved to hesiod) but I can show you what we've done in the past.
<P>The input to NIS is a normal printcap file:
<BLOCKQUOTE><CODE>
<PRE>
# Classical printcap entry
lp23a|lp23|lp|main printhost printer - KB, EUCS front Door:\
        :lp=lp23a@printhost:\
        :sd=/usr/spool/lpr/lp23a:
 
#lprng printcap entry
lplabel|lpl|TEST - Labels printer:
        :lp=:rm=printhost:rp=lplabel:
        :sd=/usr/spool/lpr/lplabel:
        :rg=lpadm:mx=1:
</PRE>
</CODE></BLOCKQUOTE>
<P>To build the NIS printcap.byname map we add the following to
the NIS makefile (along the other bits and pieces that the makefile
needs to know about a new map).
<BLOCKQUOTE><CODE>
<PRE>
PRINTCAP=$(DIR)/printcap
#PRINTCAP=/etc/printcap
# warning : [  ] is actually [&lt;space>&lt;tab>] in the script
printcap.time: $(PRINTCAP) Makefile
  if [ -f $(PRINTCAP) ]; then \
    sed &lt; $(PRINTCAP) \
      -e 's/[   ][  ]*$$//' -e '/\\$$/s/\\$$/ /' \
    | awk '$$1 ~ /^#/{next;} $$1 ~ /^[:|]/ {printf "%s", $$0; next;} \
        {printf "\n%s", $$0 }' \
    | sed -e 's/[   ]*:[  ]*:/:/g' -e 's/[  ]*|[  ]*/|/g' \
      -e '/^[   ]*$$/d' > .printcap.$$$$; \
    cat .printcap.$$$$; \
    if [ $$? = 0 -a -s .printcap.$$$$ ]; then \
      awk &lt;.printcap.$$$$ '{ FS=":"; OFS="\t"; } { \
          n = split($$1, names, "|"); \
          for (i=1; i&lt;=n; i++) \
              if (length(names[i]) > 0 \
              &amp;&amp; names[i] !~ /[ \t]/) \
                  print names[i], $$0; \
      }' | $(MAKEDBM) - $(YPDBDIR)/$(DOM)/printcap.byname; \
      awk &lt;.printcap.$$$$ '{ FS=":"; OFS="\t"; } { \
          n = split($$1, names, "|"); \
          if (n &amp;&amp; length(names[1]) > 0 &amp;&amp; names[1] !~ /[ \t]/) \
              print names[1], $$0; \
      }' | $(MAKEDBM) - $(YPDBDIR)/$(DOM)/printcap.bykey; \
      rm -f .printcap.$$$$; \
      touch printcap.time; echo "updated printcap"; \
    fi \
  fi
  @if [ ! $(NOPUSH) -a -f $(PRINTCAP) ]; then \
      $(YPPUSH) printcap.byname; \
      $(YPPUSH) printcap.bykey; \
      touch printcap.time; echo "pushed printcap"; \
  fi
</PRE>
</CODE></BLOCKQUOTE>
<P>To specify that you want YP database rather than file access,
use the following entry in your <CODE>/etc/lpd.conf</CODE> file:
<BLOCKQUOTE><CODE>
<PRE>
printcap_path |/usr/local/lib/pcfilter
</PRE>
</CODE></BLOCKQUOTE>
<P>Put the following shell script in /usr/local/lib/pcfilter
<BLOCKQUOTE><CODE>
<PRE>
#!/bin/sh
#/usr/local/lib/pcfilter
read key
ypmatch "$key" printcap.byname
</PRE>
</CODE></BLOCKQUOTE>
<P>
<H3>How to use NIS and LPRng - Sven Rudolph</H3>

<P>
<BLOCKQUOTE><CODE>
<PRE>
 Date: Wed, 11 Sep 1996 00:11:02 +0200
 From: Sven Rudolph &lt;sr1@os.inf.tu-dresden.de>
 To: lprng@lprng.org
 Subject: Using :oh=server: with NIS
</PRE>
</CODE></BLOCKQUOTE>
<P>When I use a cluster-wide printcap,
two entries for each printer will appear, e. g.:
<BLOCKQUOTE><CODE>
<PRE>
---------- start of /etc/printcap snippet
lp1
 :lp=lp1@server
lp2
 :lp=lp2@server
lp1
 :server:oh=servername
 :sd=/var/spool/lpd/lp1
 :lp=/dev/lp1
 :sh:mx=0
---------- end of /etc/printcap snippet
</PRE>
</CODE></BLOCKQUOTE>
<P>When I create a NIS map out of this,
the printer name is used as a key
and must be unique. So NIS' makedbm decides to drop all but the last
entry for each printer. This makes the printer on the clients
unavailable.
I solved this by a hack where the second entry is called lp1.server
and the NIS client script has to request the right entry.
<OL>
<LI>Assumptions
<P>Perl is available at the YP server in /usr/bin/perl .
A Bourne Shell is available at all clients in /bin/sh
The printcap that is to be exported is in /etc/printcap .
The printcap is written in the new format.
<P>In the examples the printer is called lp1 .
</LI>
<LI>Add the following to your YP Makefile (/var/yp/Makefile) on the YP
server :
<BLOCKQUOTE><CODE>
<PRE>
---------- start of /var/yp/Makefile snippet
PRINTCAP  = /etc/printcap
printcap: $(PRINTCAP)
    @echo "Updating $@..."
    $(CAT) $(PRINTCAP) | \
        /usr/lib/yp/normalize_printcap | $(DBLOAD) -i $(PRINTCAP) \
        -o $(YPMAPDIR)/$@ - $@
    @if [ ! $(NOPUSH) ]; then $(YPPUSH) -d $(DOMAIN) $@; fi
    @if [ ! $(NOPUSH) ]; then echo "Pushed $@ map." ; fi
---------- end of /var/yp/Makefile snippet
</PRE>
</CODE></BLOCKQUOTE>

<P>(These lines are for Debian GNU/Linux, other systems might require
other modifications)
</LI>
<LI>Install the programs <CODE>match_printcap</CODE>
and <CODE>normalize_printcap</CODE> to <CODE>/usr/lib/yp</CODE>.
normalize_printcap
is only required on the YP server.
The <CODE>normalize_printcap</CODE> processes only the LPRng printcap format.
<BLOCKQUOTE><CODE>
<PRE>
---------- start of /usr/lib/yp/normalize_printcap
#! /usr/bin/perl
$debug = 0;
$line = "";
$new = "";
while (&lt;>) {
    chomp;
    next if ( /^\s*\#.*/ );
    s/^\s*$//;
    next if ( $_ eq '' );
    print "new: " . $_ . "\n" if $debug;;
    if (/^\s/) { # continuation line
        $line = $line.$_;
        print "continued: $line\n" if $debug;
        next;
    } else {
        $line =~ s/\s+\:/:/g;
        $line =~ s/\:\s+/:/g;
        $line =~ s/\:\s*\:/:/g;
        print "line: $line\n" if $debug;
        push(@lines, $line) if $line;
        $line = $_;
    }
}
$line =~ s/\s+\:/:/g;
$line =~ s/\:\s+/:/g;
$line =~ s/\:\s*\:/:/g;
push(@lines,$line) if $line;
@lines = sort(@lines);
foreach $line (@lines) {
    ($printers) = split(/\:/,$line);
    @printers = split(/\|/,$printers);
    foreach $printer (@printers) {
      $num{$printer}++;
      push(@allprinters,$printer);
      print "allprinters: @allprinters\n" if $debug;
      print $printer."_".$num{$printer}."\t$line\n";
    }
}
@pr = keys %num;
print "printers @pr\n" if $debug;
if ($#allprinters >=0) {
    print "all_1\tall:all=".join(",",@pr)."\n";
}
---------- end of /usr/lib/yp/normalize_printcap
</PRE>
</CODE></BLOCKQUOTE>

<P>The result of processing the sample printcap file is:
<BLOCKQUOTE><CODE>
<PRE>
lp1_1 lp1:lp=lp1@server
lp1_2 lp1:server:oh=servername:sd=/var/spool/lpd/lp1:lp=/dev/lp1:sh:mx=0
lp2_1 lp2:lp=lp2@server
all_1 all:all=lp1,lp2
</PRE>
</CODE></BLOCKQUOTE>
<P>Observe that each of the real printer entries has a key consisting of the
printer name with a numerical suffix.
This leads to the following method of extracting the printcap information
using <CODE>ypmatch</CODE>:
<BLOCKQUOTE><CODE>
<PRE>
---------- start of /usr/lib/yp/match_printcap
#!/bin/sh
read p
n=1
while ypmatch "${p}_${n}" printcap 2>/dev/null; do
    n=`expr $n + 1`
done
---------- end of /usr/lib/yp/match_printcap
</PRE>
</CODE></BLOCKQUOTE>
</LI>
<LI>Now test the YP arrangement:
<BLOCKQUOTE><CODE>
<PRE>
$ cd /var/yp; make # this should create the printcap map
$ ypcat printcap # should provide the whole normalized printcap
$ echo lp1 |/usr/lib/yp/match_printcap # yields lp1 printcap
</PRE>
</CODE></BLOCKQUOTE>
</LI>
<LI>Add the printcap_path entry to <CODE>/etc/lpd.conf</CODE>:
<BLOCKQUOTE><CODE>
<PRE>
printcap_path=|/usr/lib/yp/match_printcap
</PRE>
</CODE></BLOCKQUOTE>
</LI>
<LI>Test the use of the printcap path entry:
<BLOCKQUOTE><CODE>
<PRE>
$ lpq -Plp1 # shows the status of lp1
</PRE>
</CODE></BLOCKQUOTE>
</LI>
<LI>Restart the lpd server and check to see that it accesses
the right printcap information.
Use the same <CODE>lpq</CODE> command,
and then try <CODE>lpc printcap lp1</CODE>.</LI>
</OL>
<HR>
<A HREF="LPRng-HOWTO-9.html">Next</A>
<A HREF="LPRng-HOWTO-7.html">Previous</A>
<A HREF="LPRng-HOWTO.html#toc8">Contents</A>
</BODY>
</HTML>
