<!-- LPRng-HOWTO SGML format -->
<!doctype linuxdoc system>
<article>
<!-- must be matched by / article at end -->
<title> LPRng-HOWTO
<author> Patrick Powell <tt><htmlurl url="mailto:papowell@astart.com"
    name="papowell@astart.com"></tt>
<!--VERSION-->
<date> 27 Oct 1999 (For LPRng-3.6.12)
<abstract>
The LPRng software is an enhanced, extended, and portable implementation
of the Berkeley LPR print spooler functionality. While providing the same
interface and meeting RFC1179 requirements, the implementation is completely
independent and provides support for the following features: lightweight (no databases
needed) lpr, lpc, and lprm programs; dynamic redirection of print queues;
automatic job holding; highly verbose diagnostics; multiple printers serving
a single queue; client programs do not need to run SETUID root; greatly enhanced
security checks; load balancing across multiple printers;
and a greatly improved permission and authorization mechanism.

The source software compiles and runs on a wide variety of UNIX systems,
and is compatible with other print spoolers and network printers that use
the LPR interface and meet RFC1179 requirements. 

The package comes with filters for PostScript and HP printers, as well
as the usual 'dumb' printers, and the PostScript and HP filters support
page counting and produce accounting information accounting. In addition
there are a wide variety of filters for page formatting
and to produce banner pages. 

For users that require compatibility with the SVR4 lp and lpstat programs,
the LPRng package provides emulation of these programs.
In addition, a publicly available PCNFSD server
is distributed with LPRng and interfaces with the PC/DOS/Windows based
NFS style print spoolers.
In addition,
LPRng can be easily integrated with the Samba SMB support package.

For users that require secure and/or authenticated printing support,
LPRng supports Kerberos 5,
MIT Kerberos 4 extensions to LPR,
and PGP authentication methods.
Additional authentication support is extremely simple to add. 
</abstract>
<toc>
<sect>Introduction
<p>
Printing is one of the essential services provided by computer systems.
Users want reliable and easy to use methods of printing
that require a minimum amount of effort to used and understand.
On single user systems with a directly attached printer they
perceive that the printing process is simply a matter of
<it/storing/
or
<it/spooling/
a file,
and then transferring it to the printer in a timely manner.
In the classical
<it/multi-user/ systems,
each user expects to share a common printer with one or more users;
the print
<it/spooling/
system provides arbitration and sharing of the printer among the various users.
In a <it/network/
based multi-user system,
there may be one or more printers shared by multiple users on many different
systems.
The print <it/spoolers/ will need to cooperate to provide print services to
the users in a simple an predictable manner.
<p>
The LPRng print spooler software was developed to a flexible and scalable
approach to each of these printing problems.
It has been used since 1988 in extremely demanding
academic printing environments such as University of Minnesota, MIT,
and Rutgers,
commercial companies such as Dow Jones and Abbot Pharmaceuticals,
as well as being distributed with Linux, FreeBSD, and other systems.
Each of these environments has a unique set of problems,
demanding various configuration and administrative capabilities.
For example,
the simple single user system with a single or limited number of printers
requires easy configuration and simple diagnostic procedures,
while the network based printing system requires highly robust
error logging,
authentication,
and failover support.
<p>
This document
is structured to first provide an overview of the LPRng printing system,
and then a
<em/quickstart/ guide for single user systems with a simple printer.
This includes printer hardware and Operating System  specific setup descriptions.
Next,
more complex configurations are described,
and their management and configuration are outlined.
Next,
an extremely detailed description of the LPRng print spooling components
and their functionality is provided.
Finally,
an index to the various features and functions of LPRng is provided.
<sect1>What is LPRng?
<label id="secfeatures">
<p>
LPRng is a print spooling system. It was designed to mimic the
Berkeley (University of California - Berkeley) Line Printers (LPR)
package, first found on Berkeley derivatives of the Unix operating
system.
LPRng will print a document with little or no knowledge of the content
or special processing required to print the document on a stand-alone machine
or in a distributed printing environment.
New (as compared to Berkeley LPR) features
include: lightweight <tt>lpr</tt>, <tt>lpc</tt> and <tt>lprm</tt>
programs, dynamic redirection of print queues, automatic job holding,
highly verbose diagnostics, load balancing queues; enhanced
security (SUID not required in most environments),
and easy configuration.
<p>
LPRng started life at the University of Waterloo in 1986
as PLP (Public Line Printer), a replacement for the original BSD LPD code.
This was a one-shot effort by the author,
Patrick Powell,
to develop code that could be freely redistributed
without the restrictions of the BSD/AT&amp;T license
and would allow non-license sites to fix and patch problems that they were
having with print spooling.
From 1988 to 1992,
various individuals and groups added features, hacked, slashed, and modified the
PLP code, coordinated largely by Justin Mason (<tt>&lt;jmason@iona.ie&gt</tt>),
who started the LPRng mailing list (see <ref id="maillist" name="More Information">).
<p>
In 1992 while at San Diego State University
Prof. Powell redesigned and reimplemented the PLP code
and named the result LPRng.
The goals of the LPRng project were to build a server system that was as
close to user abuse proof as possible,
that would provide services limited only by the inherent capacities of the
support system,
RFC1179 compliant,
and with extensive debugging capabilities to allow
quick and easy diagnostics of problems.
Over the period from 1994-1999,
LPRng users have suggested extensions,
provided patches,
and added facilities.
<p>
In early 1999
the code base for LPRng was reorganized in order to provide a common
method for running on non-UNIX platforms such as Microsoft Windows NT,
Apple Rhapsody, and embedded systems.
<p>
As a side effect of this work,
many security problems that could develop were identified and steps
taken to ensure that they were not present in LPRng.
For example,
LPRng clients such as lpr, lprm, lpc, and lpq run as
ordinary users programs,
and even the lpd server can run as a user once a network port has
been opened.
Bounds checking is performed on all input and formatting (for example,
snprintf() rather
than sprintf() is used),
as well as other preventive measures where appropriate.
<p>
<sect1>More Information
<label id="maillist">
<p>
The main LPRng documentation is the LPRng-HOWTO,
which is available in text, HTML, info, and PostScript format.
Information
about LPRng and the latest release
can be found on the LPRng web page:
<p>
<htmlurl url="http://www.astart.com/LPRng.html" name="http://www.astart.com/LPRng.html">
<p>
There is also a mailing list at <tt>lprng@iona.com</tt>. To subscribe,
send an email to <tt>lprng-request@iona.com</tt>. The body should contain
only the word `subscribe'. To get off the list later on, repeat the
same procedure, but use the word `unsubscribe'.
<p>
Several presentations of LPRng and print spooling software have been made
at the Large Scale Installation Administrator (LISA) conferences and
are in the LPRng distribution and available on web sites.
<htmlurl url="ftp://ftp.astart.com/pub/LPRng/LPRngLISA95.ps" name="LPRng - An Enhanced Printer Spooler System">
was presented at the LISA95 conference,
and is in the LPRng distribution as LPRng_DOC/LPRng-LISA95.ps.
The slides for the
<htmlurl url="ftp://ftp.astart.com/pub/LPRng/LISA97.tgz" name="LISA97">
and
<htmlurl url="ftp://ftp.astart.com/pub/LPRng/LISA98.ppt" name="LISA98">
tutorials on <it/Network Printing and Print Spooling/.
<p>
<sect1>Frequently Asked Questions
<p>
There is a list of Frequently Asked Questions that appear regularly
on the LPRng mailing list.
For your convenience, see
<ref id="FAQ" name="The Most Frequently Asked Questions">.
<sect1>Copyright
<p>
Material included in this document from the LPRng distribution
Copyright Patrick Powell 1988-1999, where applicable.
<p>
The rights to distribute this document complete or in part are hereby
granted for non-commercial purposes. Partial reproductions must
acknowledge the source.
<p>
Permission to distribute this file together with LPRng and `derived
works' (as defined in the LPRng license) is explicitly granted. This
is allowed independent of the license under which the software is
distributed.
<p>
Citing the document is allowed as long as the source is acknowledged.
<sect1>Disclaimer
<p>
<bf>THE MATERIAL IN THIS SOFTWARE PACKAGE IS PROVIDED WITHOUT FEE AND AS-IS WITH NO
WARRANTY REGARDING FITNESS OF USE FOR ANY PURPOSE. THE AUTHOR AND ALL
CONTRIBUTORS ARE NOT LIABLE FOR ANY DAMAGES, DIRECT OR INDIRECT,
RESULTING FROM THE USE OF INFORMATION PROVIDED IN THIS DOCUMENT.</bf>
<sect1>Commercial Support
<p>
<htmlurl url="http://www.astart.com" name="AStArt Technologies">
provides commercial support and enhancements for
the LPRng and other network software.
AStArt provides network and system consulting services for UNIX and NT
systems, as well as real time and network software.
<sect1>Web Site
<p>
Web Page:
<p>
<htmlurl url="http://www.astart.com/lprng.html" name="http://www.astart.com/lprng.html">
<sect1>FTP Sites
<label id="secftp">
<p>
The software may be obtained from <newline>
<htmlurl url="ftp://ftp.astart.com/pub/LPRng" name="ftp://ftp.astart.com/pub/LPRng">(Main site)
<newline>
<p>
Mirrors:<newline>
<htmlurl url="ftp://ftp.sage-au.org.au/pub/printing/spooler/lprng" name="ftp://ftp.sage-au.org.au/pub/printing/spooler/lprng"> (AU)<newline>
<htmlurl
url=
"ftp://sunsite.ualberta.ca/pub/Mirror/LPRng/"
name=
"ftp://sunsite.ualberta.ca/pub/Mirror/LPRng/"
> (CA)<newline>
<htmlurl url="ftp://ftp.informatik.uni-hamburg.de/pub/os/unix/utils/LPRng" name="ftp://ftp.informatik.uni-hamburg.de/pub/os/unix/utils/LPRng"> (DE)<newline>
<htmlurl url="ftp://ftp.uni-paderborn.de/pub/unix/printer/plp/LPRng" name="ftp://ftp.uni-paderborn.de/pub/unix/printer/plp/LPRng"> (DE)<newline>
<htmlurl url="ftp://ftp.iona.ie/pub/plp/LPRng" name="ftp://ftp.iona.ie/pub/plp/LPRng"> (IE)<newline>
<htmlurl url="ftp://ftp.chembio.ntnu.no/pub/mirrors/LPRng" name="ftp://ftp.chembio.ntnu.no/pub/mirrors/LPRng"> (NO)<newline>
<htmlurl url="ftp://ftp.mono.org/pub/LPRng" name="ftp://ftp.mono.org/pub/LPRng"> (UK)<newline>
<htmlurl url="ftp://ftp.cs.columbia.edu/pub/archives/pkg/LPRng" name="ftp://ftp.cs.columbia.edu/pub/archives/pkg/LPRng"> (US)<newline>
<htmlurl url="ftp://ftp.cs.umn.edu/pub/LPRng" name="ftp://ftp.cs.umn.edu/pub/LPRng"> (US)<newline>
<htmlurl url="ftp://ftp.iona.com/pub/plp/LPRng" name="ftp://ftp.iona.com/pub/plp/LPRng"> (US)<newline>
<htmlurl url="ftp://uiarchive.uiuc.edu/pub/packages/LPRng" name="ftp://uiarchive.uiuc.edu/pub/packages/LPRng"> (US)<newline>
<htmlurl url="ftp://uabgate.uab.ericsson.se/pub/unix/LPRng" name="ftp://uabgate.uab.ericsson.se/pub/unix/LPRng">(SE)<newline>
<sect1>Mailing List
<p>
To join the LPRng mailing list, please send mail to
<htmlurl url="mailto: lprng-request@lprng.org" name="lprng-request@lprng.org">
with the word 'subscribe' in the BODY.
<p>The LPRng mailing list is archived on
<newline>
<htmlurl
url="http://www.findmail.com/list/lprng"
name="http://www.findmail.com/list/lprng"
>
<sect1>PGP Public Key
<label id="faqref">
<p>
The LPRng distributions have an MD5 checksum calculated,
which is then signed with a PGP public key.
Here is the key for validating the checksums:
<tscreen>
<verb>
Type Bits/KeyID    Date       User ID
pub  1024/00D95C9D 1997/01/31 Patrick A. Powell <papowell@astart.com>

-----BEGIN PGP PUBLIC KEY BLOCK-----
Version: 2.6.3i

mQCNAzLygTQAAAEEANBW5fPYjN3wSAnP9xWOUc3CvsMUxjip0cN2sY5qrdoJyIhn
qbAspBopR+tGQfyp5T7C21yfWRRnfXmoJ3FVtgToAsJUYmzoSFY08eDx+rmSqCLe
rdJjX8aG8jVXpGipEo9U4QsUK+OKzx3/y/OaK4cizoWqKvy1l4lEzDsA2VydAAUT
tCdQYXRyaWNrIEEuIFBvd2VsbCA8cGFwb3dlbGxAYXN0YXJ0LmNvbT6JAJUDBRA0
XonoiUTMOwDZXJ0BAQ2cBAC7zU9Fn3sC3x0USJ+3vjhg/qA+Gjb5Fi1dJd4solc4
vJvtf0UL/1/rGipbR+A0XHpHzJUMP9ZfJzKZjaK/d0ZBNlS3i+JnypypeQiAqo9t
FV0OyUCwDfWybgAORuAa2V6UJnAhvj/7TpxMmCApolaIb4yFyKunHa8aBxN+17Ro
rrQlUGF0cmljayBBLiBQb3dlbGwgPHBhcG93ZWxsQHNkc3UuZWR1PokAlQMFEDLy
gTSJRMw7ANlcnQEBYBYD/0zTeoiDNnI+NjaIei6+6z6oakqO70qFVx0FG3aP3kRH
WlDhdtFaAuaMRh+RItHfFfcHhw5K7jiJdgKiTgGfj5Vt3OdHYkeeh/sddqgf9YnS
tpj0u5NfrotPTUw39n6YTgS5/aW0PQfO9dx7jVUcGeod1TGXTe9mIhDMwDJI4J14
=3Zbp
-----END PGP PUBLIC KEY BLOCK-----
</verb>
</tscreen>
<sect>Print Spooling Overview
<label id="overview">
<p>
A print spooler is a program that accepts
<it/print jobs/
(which are usually one or more files)
from a program or network interface,
stores them in a
<it/spool queue/,
and then sends them to a printer or another
print spooler.
Usually there are facilities to submit jobs,
check on the current job status,
remove jobs from spool queues,
and perform administrative functions such as starting or
stopping printing.
<p>
A print spooler is a client/server application.
The client programs are used to submit jobs to the print spooler
program which performs the actual printing operations.
In order to carry out these operations,
the server may need to use other programs to convert print job files
into a format acceptable to a printer,
or perform various accounting or administrative functions.
<sect1>Overview
<p>
<!--PICTURE1-->
<tscreen>
<verb>
+---------+    +-----+    +-----+     +--------+    +---------+
| program | -> | lpr | -> | lpd |  -> | filter | -> | printer |
+---------+    +-----+  * +-----+     +--------+    +---------+
                  *    *     |   
               printcap      V
                          +-----+     +--------+    +---------+
                          | lpd |  -> | filter | -> | printer |
                          +-----+     +--------+    +---------+

                           Figure 1
</verb>
</tscreen>
<!--PICTURE1-->
<p>
Figure 1 shows the flow of data between the individual components of the
LPRng print spooling system.
A program (or user) will use the <tt/lpr/ program to send a file
to the <tt/lpd/ server over a TCP/IP connection.
The <tt/lpd/server will store the file temporarily in a
spool queue directory.
The information needed by the <tt/lpr/ and <tt/lpd/ programs to carry
out this activity is stored in the
<tt/printcap/  (usually called the <tt>/etc/printcap</tt>) database file.
<p>
The <tt/lpd/ server sorts the queue entries and determines the print order.
It will select a job to be printed,
open a connection to the printer,
and then use a <it/filter/ program to convert the file contents into a
format suitable for the printer.
If the file does not need conversion,
then the <tt/lpd/ server will send the file directly to the printer.
<p>
The <tt/lpd/ server can also <tt/forward/ jobs to another print server
over a network connection,
optionally sending them through a filter as well.
The destination server can in turn forward the job or send it to a printer.
<p>
The protocol or commands used to do this job forward and transfer are
specified by
<ref id="rfc1179ref" name="RFC1179">.
This protocol specifies how the <tt/lpr/ client program sends a job
to the <tt/lpd/ server,
as well as how the <tt/lpd/ server forwards jobs to another server.
In addition to job submission,
RFC1179 specifies commands to obtain queue status,
to remove jobs from the queue,
and to start and stop print queues.
<sect1>Sample Printcap Entry
<p>
As described in the
<ref id="overview" name="Print Spooling Overview">,
the information in the <tt/printcap/ database is used control printing
operations.
While there is no RFC specifying its format or content,
there is a strong <it/de facto/ standard for its format.
For a complete description of the <tt/printcap/ database see
<ref name="Using the Printcap Database" id="printcapref">.
For a list of all of the <tt/printcap/ and configuration options see
<ref id="index" name="Index To All The Configuration and Printcap Options">.
<p>
Here is a sample printcap:
<tscreen>
<verb>
lp:lp=psqueue@printserver.astart.com
</verb>
</tscreen>
<p>
This printcap information tells the <it/client/ programs
that when a client wants to print a job on the
<tt/lp/ printer,
that these jobs should be sent to the
<tt/psqueue/ on host <tt/printerserver.astart.com/.
On the printserver,
the following printcap entry is used by the <tt/lpd/
server to do the printing.
<tscreen>
<verb>
psqueue:server
  :lp=/dev/lp0
  :sd=/var/spool/lpd/psqueue
  :if=/usr/local/bin/ifhp
</verb>
</tscreen>
<p>
The <tt/sd/ (spool queue directory) entry specifies the directory where
print jobs will be placed.
The <tt/lp/ line specifies an actual output device,
so the <tt/lpd/ server will open this device for printing.
The <tt/if/ (input file filter) entry specifies the program to be used
to translate the input file into a format compatible with the actual
printer.
Many of the times there is not need for conversion,
and this entry is left out.
<sect1>Print Server Configuration
<p>
The previous sections have given a very high level view of printing
operations.
In order to do printing the following programs and information must
be established:
<enum>
<item>
The printer itself,
and the interface to the printer.
<item>
Client programs for use by users or other programs to send jobs
to the print server and perform administrative functions.
<item>
A server program that runs on a host that accepts jobs for printing.
<item>
Printcap information to control the printing operations.
<item>
Filters that convert print jobs into formats compatible with printers.
<item>
System facilities such as spool queues or storage areas for jobs.
</enum>
<p>
The following sections will cover each of these topics in turn.
The initial sections assume that most users are setting up printers
on small systems and require an extremely simple print capability.
Later sections explore the various configurations that can be used
to support large networks of print spoolers as would be found in
large academic institutions or businesses.
<sect>Attaching Your Printer
<label id="installref">
<p>
When installing a printer,
the first step should be to make sure that the printer is actually
working independently of the software.
The following section outlines some simple diagnostics that you
can use to check printer connectivity.
<sect1>Network Printers
<label id="networkprinter">
<p>
The most flexible and highest throughput printer interface is
via a network (TCP/IP) connection.
Most high performance printers have a built in network interface,
or you can attach them to a
<em/printer server/
box which provides a network interface.
Network print boxes can be obtained from
Hewlett Packard
(<htmlurl url="http://www.hp.com" name="http://www.hp.com">),
Lantronix's
(<htmlurl url="http://www.lantronix.com" name="http://www.lantronix.com">),
and Rose Electronics
(<htmlurl url="http://www.rosel.com" name="http://www.rosel.com">).
<p>
The network interface usually supports multiple network printing protocols.
The most common are the LPD (RFC1179), Socket API, APPsocket, SMB,
and Novell Netware interfaces. 
LPRng directly supports the LPD (RFC1179) and Socket API interfaces,
and you can use the 
<tt/smbclient/ program from the
<ref id="smb" name="Samba Software Package"> for the SMB interface.
There are no plans to support the Novell Netware interface,
given the wide range of alternatives.
<sect2>Socket API
<p>
The most powerful network connection is via the the
Socket API.
The most common Socket API,
and a <it/de facto/ standard,
is the one used by Hewlett Packard on their JetDirect cards,
which allows a TCP/IP connection to port 9100.
This is a TCP/IP port on the printer that provides
a direct connection to the print engine,
similar to a serial or parallel port.
This connection is usually full duplex and provides error messages
and status information during printing.
<p>
The Socket API is extremely simple.
<enum>
<item>
The user establishes a connection to port 9100.
This connection may be refused if the printer is busy
printing a job.
<item>
Once the connection has been established,
the print job is sent over the connection.
During this transfer,
error messages may be returned over the data link.
<item>
After sending all the data,
the sender should do a
<it/half-close/ of the connection.
This tells the printer that no more data will be sent.
<item>
After finishing printing the job,
the printer will close the connection.
</enum>
<p>
You can use the
<htmlurl url="http://www.l0pht.com/~weld/netcat/" name="netcat">
utility by Hobbit <tt>&lt;Hobbit@avian.org&gt;</tt>
to test that this interface is available and working.
If <it/ellipse.ps/ is a test file, then:
The simplest and easiest way to print a file to a network printer appears
<tscreen>
<verb>
  nc printer.ip.addr 9100 &lt file
Example:
  nc 10.0.0.25 9100 &lt ellipse.ps
</verb>
</tscreen>
<sect2>LPD (RFC 1179) Protocol
<p>
The second most common network print protocol is the
RFC1179 TCP/IP protocol.
This is described in detail in later sections of this document,
but basically consists of a
simple set of command and responses.
<enum>
<item>
A connection is made to TCP/IP port 515 on the printer.
As for the Socket API,
this connection may fail if the printer is busy printing
another job or has another network connection open.
<item>
Once the connection has been established,
a print request command is sent to the printer,
and if printing is allowed,
and acknowledgment will be received.
<item>
The files comprising the print job are sent to the printer.
<item>
The connection to the printer is closed.
</enum>
<p>
During the job transfer no error information is returned,
or other status information.
This must be obtained by reconnecting to the printer and sending
a print status request.
This is a major weakness of the RFC1179 protocol.
<p>
When the LPRng software package has been installed,
it is easy to check printing by using a command of the form:
<tscreen>
<verb>
  lpr -Plp@ipaddr -Dnetwork file
Example:
  lpr -Plp@10.0.0.25 -Dnetwork ellipse.ps
</verb>
</tscreen>
<p>
The <tt/-Plp@ipaddr/ option will cause the <tt/lpr/ program to make a direct
connection to port 515  and send the print file using the RFC1179
protocol.
The <tt/-Dnetwork/ debugging option will cause detailed network status to be
displayed during this process.
<p>
In addition to the <tt/lpr/ program,
the Perl <tt/cheap_lpr/ program can be used.
This and other test programs are in the LPRng Distribution <tt/UTILS/ directory.
<sect2>APPsocket
<label id="appsocket">
<p>
The APPsocket interface is supported by Tektronix and some other printer
vendors.
It is similar to the Socket API,
with a couple of minor differences.
<enum>
<item>
The printer has two ports for network connections:
TCP port 9100 for TCP/IP stream connections and UDP port 9101 for UDP
packet connections.
<item>
When a 0 length UDP packet or a UDP packet containing only <tt>CR/LF</tt>
is sent to UDP port 9101, the printer will return a packet to the sender
containing print status information.
This information indicates the printers current status (busy, idle, printing)
and any error conditions.
<item>
To send a job to the printer,
a connection to port 9100 is made.
This connection will be refused while the printer is busy or has a connection
to another host.
<item>
When the TCP connection is established,
the job can be sent over the TCP stream.
When all of the job has been transferred,
the connection should be <it/shutdown/ for sending data by the sender,
but remain open to received error messages or other information.
<item>
An end or job indication in the data stream will also act to terminate
the connection.
This means that if the PostScript CTRL-D (end of job) character is sent in
a job,  then the connection will be terminated.
<item>
Once all the data has been received and the job has finished printing,
the connection will be terminated by the printer.
</enum>
<p>
The LPRng IFHP filter program has support for the APPsocket interface.
Also,
there are Perl or other programs which can communicate with the printer.
See
<ref id="P450" name="Tektronix P450 and Family"> for details.
<sect1>Network Print Server Boxes
<label id="secnetwork">
<p>
A ``network print server'' is usually a box
(external model) or card in a printer (internal model)
which has a network connection to a TCP network and
software to implement a LPD print server.
If it is an external model,
The parallel or serial port of
the printer is connected to the box,
and the print server may support multiple printers.
If it is an internal model,
the server is usually nothing more than a Network Interface Controller
and a ROM containing software that the microprocessor in the printer
uses.
<p>
The print server may support multiple printing protocols,
such as
<ref id="rfc1179" name="RFC1179">
(TCP/IP printing using the LPD print protocol),
Novell Printer Protocols,
SMB print protocols,
and AppleTalk protocols.
One of the observed problems with Network Print servers is that while they
can usually support one protocol and one user at a time quite well,
when you try to use multiple protocols and/or multiple users try to transfer
print jobs to the printer,  the printer may behave in a very odd manner.
Usually this results in a printer failing to finish a job currently being
printed,
and unable to accept new jobs.
<p>
Several of the newer models of print servers have
Simple Network Management Protocol (SNMP) agents built into them,
and can provide detailed information about their internal functions.
By using a SNMP manager such as SunNetmanage or HP-Openview,
you can monitor your network printers activities.
<p>
I recommend that you use only a single protocol to send jobs to the printer.
If you can,  I also recommend that you use a print spooler and have only
a single host system send a job to the printer.
<p>
My best advice on connecting to network printers is not to use the
the built-in LPD server,
but to use the direct TCP/IP connection to the print engine.
Usually this is done to particular TCP/IP port on the printer.
For the HP JetDirect and other HP products, this is usually
TCP port 9100.
<p>
Once you have the direct connection,
you can now use various filters to preprocess the print job,
insert PJL and PCL commands,
or convert text to PostScript or PCL for better print quality.
<p>
<sect1>Parallel Printers
<p>
In most UNIX systems the printer port has the name
<tt>/dev/lpt</tt>,
<tt>/dev/prn</tt>,
or something similar.
On most systems the
<tt>dmesg</tt> utility will print a list of IO devices found
during system configuration.
Use the following commands to get the information and scan
for the device.
You should also make sure that the printer device is
available.
<tscreen>
<verb>
dmesg >/tmp/a
grep lp /tmp/a
ls /dev/lp*
</verb>
</tscreen>
<p>
<p>
Gordon Haverland
<tt>&lt;haverlan@agric.gov.ab.ca</tt>&gt; supplied this little script,
that will assist with this:
<tscreen>
<verb>
#!/bin/sh
#set -v -x              # uncomment for debugging
PATH=/bin:/usr/bin
printer=
for $printer in /dev/lp* ;
do
    echo PRINTER TEST to $printer 1&gt;&2
    for i in 1 2 3 4 5 6 7 8 9;
    do
        echo PRINTER $printer $i &gt; $printer;
    done
    echo -e \\r\\f &gt; $printer
done
exit 0;
</verb>
</tscreen>
<p>
If your printer is connected to the device name you provided,
then you should get a page of something out.  If the output
suffers from the ``staircase'' effect, you will see the numbers
``marching'' across the page, otherwise the numbers will all be in
a single column.
<sect1>Serial Printers
<label id="secserial">
<p>
If your printer is attached by a serial line,
then you may need to set the serial line characteristics before sending
the job to the printer.
Here are a set of guidelines to following when attaching a serial port printer
to a serial line.
<p>
1. Check to make sure that the line is not enabled for login.
Logins are usually managed by the
<tt>getty</tt> (BSD)
or
<tt>ttymon</tt> (Solaris, SystemV).
Check your system documentation and make sure that these daemons are not
managing the serial line.
<p>
2. Check the permissions and ownership of the serial line.
For the most easy testing,
set the permissions to 0666 (everybody can open for reading and writing).
After you have made sure that you can send jobs to the printer,
you might want to change the ownership of the serial line to the LPD server
and change the permissions to 0600.
<p>
3. Make sure that you can print a test file on the printer via the
serial port.
This may require setting the line characteristics and then sending
a file to the printer.
You should try to use 8 bit, no parity, with hardware flow control
and no special character interpretation,
and definitely no LF to CR/LF translation.
The problem is that different versions of UNIX systems have different
sets of stty(1) commands to do this.
The following simple test script can help in this.
<tscreen>
<verb>
#!/bin/sh
# 9600, no echo, no CR
FLAGS= 9600 -raw -parenb cs8 crtscts
DEV= /dev/tty01
(stty $FLAGS; stty 1>&2; cat $1 ) <$DEV >$DEV
</verb>
</tscreen>
<p>
This shows using stty to set the flags,
then to print the current settings, and then using
cat a file to the output.
If you attach a dumb terminal to the serial port,
you can even use this script to ensure that input from the device
is echoed to the output with the correct speed, parity,
etc.
<p>
Experience has shown that serially connected printers are the least
reliable and lowest speed.
Where possible,
it is strongly recommended that they be attached to a <it/network print box/
which will provide a
Socket API interface and handle the low level network to serial port protocol 
conversions.
<sect>Installing the Software
<label id="installingprograms">
<label id="installation">
<p>
The basic components of the LPRng system are the executables
and the database files.
This section deals with generating and installing the executable
files.
<sect1>Source Code and Support Programs
<p>
<enum>
<item>
Obtain the latest version of the LPRng source code from a
<ref id="secftp" name="LPRng FTP Site">.
<item>
Obtain the GNU Zip (compression) program from one of the many
<htmlurl url="http://prep.ai.mit.edu" name="GNU Software Mirror Sites">
and install it.
See the directions in the GNU Zip distribution for details.
<item>
Obtain the GNU Make program from one of the many
<htmlurl url="http://prep.ai.mit.edu" name="GNU Software Mirror Sites">.
and install it.
See the directions in the GNU Zip distribution for details.
This program will be referred to as
<tt/gmake/ in the installation instructions.
<item>
Obtain an ANSI C compiler.
The GCC compiler (from the <htmlurl url="http://prep.ai.mit.edu" name="GNU Software Mirror Sites">)
is strongly recommended.
<item>
Solaris Sparc and X86 Binaries for GCC and Make  can be obtained from
<htmlurl url="http://smc.vnet.net/" name="http://smc.vnet.net/">.
</enum>
<sect1>Configuration
<p>
<p>
The LPRng package consists of:
<itemize>
<item> <em><tt>lpd</tt></em> - the LPD print server program
<item>
<em><tt>lpr</tt></em>,
<em><tt>lpq</tt></em>,
<em><tt>lprm</tt></em>,
<em><tt>lpstat</tt></em>,
and
<em><tt>lpc</tt></em> -
client programs for printing,
status queries, job removal, and server configuration respectively.
<item>
<em><tt>printcap</tt></em> print queue database file.
<item>
<em><tt>lpd.conf</tt></em> LPRng configuration options.
<item>
<em><tt>lpd.perms</tt></em> permission information.
</itemize>
<p>
By tradition,
UNIX systems have installed printer utilities in
in widely varied locations such as
<tt>/usr/lib</tt>,
<tt>/usr/bin</tt>,
<tt>/usr/libexec</tt>,
<tt>/usr/ucb</tt>,
<tt>/opt</tt>,
<tt>/usr/sbin</tt>,
and
<tt>/usr/etc/</tt>.
This can lead to a great deal of confusion when installation LPRng.
To simplify the installation,
the <tt/configure/ program is used to specify the exact locations
of programs.
It does this by setting the following variables that are
used during the installation process:
<tscreen>
<verb>
Installation directory variables:
  ${prefix}  (default /usr/local)
  ${exec_prefix}  (default ${prefix})
  ${bindir}  is usually ${exec_prefix}/bin, (/usr/local/bin)
  ${sbindir} is usually ${exec_prefix}/sbin (/usr/local/sbin)
  ${libexecdir} is usually ${exec_prefix}/libexec (/usr/local/libexec)
  ${sysconfdir} is usually ${prefix}/etc (/usr/local/etc)
  ${mandir} is usually ${prefix}/man     (/usr/local/man)
</verb>
</tscreen>
<p>
These values are used as follows by the LPRng installation
procedures (* indicates default SETUID root executable):
<tscreen>
<verb>
Executables:
  ${bindir}/   lpr *, lprm *, lpq *, lpstat *
  ${sbindir}/  lpc *, checkpc, lpd *
  ${libexecdir}/filters/ lpf, banner, etc
Configuration:
  ${sysconfdir}/ lpd.conf, lpd.perms, printcap
Man Pages
  ${mandir}/ man pages
</verb>
</tscreen>
<p>
The <tt/configure/ program has options which allow us to override and
specify the new values or exact locations for these files.
For a complete list of configuration options,
use the <tt/configure --help/ option.
You can set explicit values for the
<tt/prefix/
<tt/bindir/
<tt/sbindir/
<tt/libexecdir/
and
<tt/mandir/ variables using the <tt/--name=PATH/
option.
For example,
<tt>/configure --prefix=/usr</tt> will set the
<tt>${prefix}</tt> variable to <tt>/usr</tt>,
and files will be installed in
<tt>/usr/bin</tt>,
<tt>/usr/sbin</tt>,
<tt>/usr/libexec/filter</tt>,
and
<tt>/etc</tt>.
<p>
In addition to these general purpose options,
the <tt/configure/ script has the following LPRng specific ones.
These options allow extremely specific actions to be taken to control
how and were the various files are copied and used.
<descrip>
<tag><tt>
--disable-setuid
</tt></tag>
Install the executables without setuid ROOT permissions.
<tag><tt>
--disable-strip
</tt></tag>
Do not strip the executables before installing.
<tag><tt>
--enable-priv_ports.
</tt></tag>
Require connections to be made from a privileged port.
<tag><tt> --disable-force_localhost.  </tt></tag> By default,
the LPRng software is configured to expect to have a server running
on the local host.
This option will cause the location of the server to be obtained from the
<tt/lpd.conf/ or <tt/printcap/ information.
<tag><tt> --with-lpddir=DIR.  </tt></tag> lpd executable directory (default ${sbindir}).
<tag><tt> --with-filterdir=DIR.  </tt></tag> Filter directory (default ${libexecdir}/filters).
<tag><tt> --with-lpd_conf_path=PATH.  </tt></tag> Path of <tt/lpd.conf/ file.
<tag><tt> --with-lpd_perms_path=PATH </tt></tag> Path of <tt/lpd.perms/ file.
<tag><tt> --with-printcap_path=PATH </tt></tag> Path of <tt/printcap/ file.
</descrip>
<sect1>Installation
<p>
Unpack,  configure,
compile, and install,
and initialize the distribution using:
<tscreen>
<verb>
gunzip -c LPRng-<version>.tgz | tar xvf -
cd LPRng-<version>
# see discussion above for configuration options
# This configuration uses the standard /etc/printcap file
./configure --with-printcap_path=/etc/printcap
           [with other options as required]
gmake clean all
su   # you must do the following commands as root
gmake install
# if  you have not installed LPRng before,
# install default lpd.perms and lpd.conf file in /etc
if [ ! -f /etc/lpd.perms ]; then
    make default;
fi;
# update permissions,  create files needed for LPRng, check
# /etc/printcap file for problems.  Do as root:
./src/checkpc -f
</verb>
</tscreen>
<p>
<sect1>Solving Installation Problems
<p>
The <tt/configure/
script will determine the type of system and establish a set of defaults
for compilation and installation.
The <tt>LPRng/INSTALL</tt>
file contains detailed descriptions of the various configuration options and
capabilities.
<p>
If you have problems compiling the package, you can try these things:
<enum>
<item>Compiler complains about missing files or has a large number of
errors.
<newline>
Try <tt>gcc</tt> instead of your vendor's C compiler.
This can be done either by setting
the
<tt/CC/ environment variable or using the
<tt/--with-cc/ configure option.
<tscreen>
<verb>
CC=gcc ./configure
   OR
configure --with-cc=gcc
</verb>
</tscreen>

<item>
Missing libraries or include files.
<newline>
Usually this is caused when include files are in
<tt>/usr/local/include</tt>
and libraries are in
<tt>/usr/local/include</tt>
and these paths are not searched or used by the compiler.
This can be fixed by setting the
<tt/CPPFLAGS/ and <tt/LDFLAGS/ environment variables,
or using the
<tt/--with-cppopts=/
and
<tt/--with-ldopts=/
configure options.
<tscreen>
<verb>
CPPFLAGS="-I/usr/local/include -I/usr/include/kerberosIV" \
  LDFLAGS="-L/usr/local/lib -L/usr/lib/kerberosIV" \
  ./configure
   OR
configure --with-cppopts="-I/usr/local/include -I/usr/include/kerberosIV" \
  --with-ldopts="-L/usr/local/lib -L/usr/lib/kerberosIV"
</verb>
</tscreen>
</enum>
<p>
The <tt>configure</tt> and <tt>make</tt> steps must be run on
the target host,
especially if the target host has a different version of the operating system.
This is extremely important for SunOS or Solaris,
where
there tend to be changes in the system's include files between
versions
as well as support libraries.
<p>
Read the notes for your OS in section
<ref id="sysdep" name="System-dependent notes">
for specific installation help (if any).
<sect1>Advanced Configuration Options
<label id="disablelocalhost">
<p>
While the default LPRng configuration will be suitable for most
individual users,
administrators of large sites or which need to support 
<it/lightweight print clients/
will need to use the following configure options.
<enum>
<item><tt/--disable-force_localhost/
<newline>
The default LPRng configuration assumes that all printing will be done
via a <tt/lpd/ print spooler running on the local host system.
However,
many larger sites prefer that all users do their printing via a
few central servers,
and do not run
<tt/lpd/ servers on user systems.
The
<tt/--disable-force_localhost/
configuration will simply this type of operation by eliminating the need for a
<tt>/etc/lpd.conf</tt> file to override the <tt>force_localhost</tt> option.
<item><tt/--disable-setuid/
This option will install the LPRng executables without SETUID permissions.
Non-setuid clients and programs are inherently more secure than SETUID programs,
and system administrators would be well advised to install them without
SETUID root permissions.
Please see <ref id="setuid" name="Advanced Security Considerations">
for more details about this option.
<item><tt/--enable-priv_ports/
This option will install a default
<tt/lpd.perms/ file which disallows connections from non-privileged ports.
In effect,
this will require that on UNIX systems the originating user be root or
the program be SETUID root.
By default,
LPRng will allow connections from any port.
Please see <ref id="setuid" name="Advanced Security Considerations">
for more details about this option.
<item><tt/--disable-require_configfiles/
By default, the
<tt/lpr/,
<tt/lpq/,
<tt/lpc/, ...
clients will required a <tt/lpd.conf/ file and the <tt/printcap/
to be present.
The
<tt/--disable-require_configfiles/
option relaxes this requirement,
and if the files are missing,
will not complain.
</enum>
<sect1>Printcap and lpd.conf files
<label id="requireconfig">
<p>
The <tt>printcap</tt> file contains the definitions of print queues
and other information used by LPRng.
The exact location of the file is determined by the
<tt/configure/ options and defaults for your system.
The default used by <tt/configure/ is <tt>/usr/local/etc/printcap</tt>,
but it is more commonly found in <tt>/etc/printcap</tt>.
If your system does not have an <tt>printcap</tt> file,
then the following is suitable for initial testing and configuration:
<tscreen>
<verb>
# test printcap file
lp:cm=Test Printcap Entry:
 :lp=/dev/null
 :sd=/usr/spool/lpd/lp
</verb>
</tscreen>
<p>
The <tt>lpd.conf</tt>
(default location is <tt>/usr/local/etc/lpd.conf</tt>)
file contains settings that override the defaults provided at compile time.
You will find a prototype or template <tt/lpd.conf/ file in the LPRng distribution.
If you do not have an existing <tt/lpd.conf/ file,
the default one will be installed.
You can install this by hand using:
<tscreen>
<verb>
astart > cd LPRng/src
astart > su
ASTART # cp lpd.conf /usr/local/etc/lpd.conf
ASTART # chmod 644 /usr/local/etc/lpd.conf
</verb>
</tscreen>
<p>
The various client programs such as
<tt/lpr/,
<tt/lpq/,
etc. will check for a <tt/lpd.conf/ and <tt/printcap/
file.
You can relax this requirement by setting
the
<tt/require_configfile/ option false
(<tt/require_configfile@/)
by using the configuration option <tt/--disable-require_configfile/,
by setting the <tt/require_configfile/ option in the
<tt/lpd.conf/ file,
or building the
executables with <tt/make REQUIRE_CONFIGILE="1"/.
<sect1>Security, Permissions, and CHECKPC
<label id="group">
<label id="user">
<p>
By default,
the <tt/lpd/ server is run as a ROOT (user 0)
process.
(This is true not only for LPRng,  but also for all
other system processes which are started at boot time.)
However,
normally LPRng will do operations as a non-privileged user and group
which is defined by the value of the
<tt/user/ (default <tt/daemon/) and
<tt/group/ (default <tt/daemon/) option
in the <tt>/etc/lpd.conf</tt> configuration file
or the compile time defaults in the
<tt>LPRng/src/vars.c</tt> file.
<p>
The following steps must be taken in order to preserve
system security:
<enum>
<item>
Create a user and group <tt/daemon/ on the system.
This user does not need login privileges,
but will need a home directory if secure authentication
such as Kerberos or PGP will be done.
<item>
The <tt>lpd.conf</tt>
file should be owned by root (user 0),
and should have read-only (0444) permissions.
<item>
The <tt>printcap</tt>
file should be owned by root (user 0),
and should have read-only (0444) permissions.
<item>
The spool and working directories used by LPRng should be
owned by user <tt/daemon/,  group <tt/daemon/,
and have 0700 permissions (accessible only by user <tt/daemon/).
</enum>
<sect2>Using CHECKPC
<p>
The
<tt/checkpc/
program is used to make sure that
the spool directories and files used by LPRng have the correct permissions
and are in place.
By default,
<tt/checkpc/ will check permissions and report if there are any problems.
You should run this as <tt/root/.
For example:
<tscreen>
<verb>
% astart > su
#>cd LPRng/src
#>./checkpc
Warning - No configuration file '/usr/local/etc/lpd.conf'
Warning - No lpd only printcap file found in '/usr/local/lpd_printcap'
Warning -  ** cannot open '/var/run/lpd.printer' - 'Permission denied'
Warning -  bad directory - /var/spool/lpd/lp
Warning -   Printer_DYN 'lp' spool dir '/var/spool/lpd/lp' needs fixing
</verb>
</tscreen>
<p>
In the above example,
<tt/checkpc/ has discovered that the <tt>lpd.conf</tt>
file is missing.
This is not a serious problem if the system defaults are to be used,
but you might want to put the default <tt>LPRng/lpd.conf</tt> file from the
distribution in place.
<p>
The <it/lpd only printcap/
message is usually of concern to administrators who wish to use some of
LPRng's more exotic configuration options.
It is possible to have separate printcap databases for client and server programs.
This is useful when printcap files get extremely large and cuts down
substantially on system management problems.
<p>
The permission denied message for <tt>/var/run/lpd.printer</tt> is more serious,
as the <tt/lpd/ server uses this as a lock file.
<p>
The <it/bad directory/ message about the spool directory is usually caused by
bad permissions or when the directory is missing.
<p>The <tt/checkpc -f/ option causes <tt/checkpc/ to take action to rectify errors.
You can see what is happening if you run it with the <tt/-V/ (verbose) option:
<tscreen>
<verb>
% astart > su
#>cd LPRng/src
# ./checkpc -f -V
LPRng version LPRng-3.6.1
 DaemonUID 1, DaemonGID 12
Using Config file '/usr/local/etc/lpd.conf'
Checking for configuration files '/usr/local/etc/lpd.conf'
Warning - No configuration file found in '/usr/local/etc/lpd.conf'
Checking for printcap files '/usr/local/etc/printcap'
  found '/usr/local/etc/printcap', mod 0100644
Checking for lpd only printcap files
     '/usr/local/etc/lpd_printcap'
Warning - No lpd only printcap file found in
     '/usr/local/etc/lpd_printcap'
LPD lockfile '/var/run/lpd.printer'
  checking '/var/run/lpd.printer' file
Names
 :lp=lp
All
 :lp
Printcap Information
lp
 :force_localhost
 :lp=lw4@astart4.astart.com
 :sd=/var/spool/lpd/lp
Checking printcap info
Checking printer 'lp'
 Checking directory: '/var/spool/lpd/lp'
  file 'control.lp', size 0 K, unchanged in 2 hours
  file 'status.lp', size 0 K, unchanged in 2 hours
  file 'status', size 0 K, unchanged in 2 hours
  file 'log', size 0 K, unchanged in 2 hours
  checking 'control.lp' file
  checking 'status.lp' file
  checking 'status' file
  cleaning 'status' file, 0 bytes long: no truncation
  checking 'log' file
  cleaning 'log' file, 0 bytes long: no truncation
</verb>
</tscreen>
<p>
As you can see, <tt/checkpc/ can not only print detailed information about your
printing system,  but it also fixes up the various problems.
<sect2>Advanced Security Concerns
<label id="setuid">
<p>
While <tt/checkpc/ will set permissions,
there is always the problem with undetected errors in the LPRng
software that,
when exploited,
could cause severe system problems.
The most serious concern is that of gaining root (user 0) permissions.
<p>
One way to avoid this is to run
<it/client/
programs without root permission.
This operation is possible for LPRng
in contrast to other print spooling software.
<p>
A serious problem running LPRng as a nonprivileged
user (root) is the fact that the RFC protocol specifies
that connections are made to port 515
and
<tt/lpd/
requires root permissions to open and bind to port 515.
One option is to have the <tt/lpd/ server drop root permissions
soon after binding to this port and before accepting any user
commands.
However,
in order to fully compatible with RFC1179,
<tt/lpd/ must originate connections from a <it/reserved/
port in the range 721-731,
although in practice port 1-1023 seems to be acceptable.
<p>
If inter-operability with non-LPRng print spoolers is not desired,
then it is <it/trivial/
to configure LPRng using the <tt/lpd.conf/
file or by modifying the compile time
<tt/lpd_port/
value in the file or the <tt>LPRng/src/vars.c</tt>
so that all the software will run
as client programs.
For example,
in the <tt>/etc/lpd.conf</tt> file,
you only need to change the indicated lines:
<tscreen>
<verb>
# Purpose: lpd port
#   default lpd_port=printer
lpd_port=2000
</verb>
</tscreen>
<p>Now all the LPRng software will use port 2000 to transfer jobs and
commands.
You can also use this facility to establish a
<it/private/ set of print spoolers which can be used for testing.
<sect1>Stopping Existing Spooler Software
<p>
The next step is to shut down and remove the existing print
spooler,
and test the functionality of the LPRng <tt/lpd/
programs.
Unfortunately,
this process is fairly system dependent,
and requires a small amount of system expertise.
In addition to these general directions,
you should see the 
<ref id="sysdep" name="System specific notes"> for your system.
<sect2> SunOS and BSD Derived
<p>
This section provides instructions for  systems that use the
<tt/lpd/ print services,
such as SunOS,
BSD derived systems,
and Linux based systems.
These systems use an <tt/lpd/ print server,
as does LPRng.
<p>
We first kill the currently running <tt/lpd/ process.
While there may be a system shutdown script
in the <tt>/etc/rc.d/</tt> directory or other location for this,
do not bother using it.
<tscreen>
<verb>
# most BSD Systems
ps -auxw |grep lpd
# Kill it twice
kill (pid of lpd server)
#  This should report an error - if not then lpd did not terminate
kill (pid of lpd server)
#

Example:
astart % ps -axuw |grep lpd
papowell 23932  0.0  0.3  224  184  p3  S+  10:40AM  0:00.01 grep lpd
daemon  17763  0.0  0.2  448  120  ??  IWs  29Mar99  0:01.35 (lpd)
astart % kill 135
astart % kill 135
135: No such process
</verb>
</tscreen>
<p>
Next,
you should remove or rename the existing print system executables.
The following example shows how to use the
<tt/find/ utility to track down candidates.
<tscreen>
<verb>
astart# find /usr -type f -name lp\*  -print >/tmp/candidates
astart# find /sbin -type f -name lp\*  -print >>/tmp/candidates
astart# cat /tmp/candidates
/usr/bin/lpunlock
/usr/bin/lpqall.faces
/usr/bin/lpq             <---- old
/usr/bin/lpr             <---- old
/usr/bin/lprm            <---- old
/usr/bin/lptest
/usr/doc/samba-1.9.18p10/examples/printer-accounting/lp-acct
/usr/man/man1/lpq.1
/usr/man/man1/lpr.1
/usr/man/man1/lprm.1
/usr/man/man1/lptest.1
/usr/man/man4/lp.4
/usr/man/man8/lpc.8
/usr/man/man8/lpd.8
/usr/sbin/lpc            <--- old
/usr/sbin/lpd            <--- old
/usr/sbin/lpf            <--- old
/usr/local/bin/lpc    <-- LPRng
/usr/local/bin/lpq    <-- LPRng
/usr/local/bin/lpr    <-- LPRng
/usr/local/bin/lprm   <-- LPRng
/usr/local/sbin/lpd   <-- LPRng
astart # mv /usr/bin/lpq  /usr/bin/lpq.old
astart # mv /usr/bin/lpr  /usr/bin/lpr.old
astart # mv /usr/bin/lprm /usr/bin/lprm.old
astart # mv /usr/sbin/lpc /usr/sbin/lpc.old
astart # mv /usr/sbin/lpd /usr/sbin/lpd.old
astart # mv /usr/sbin/lpf /usr/sbin/lpf.old
...
</verb>
</tscreen>
<sect2> Solaris, HP, AIX, and SysVR4 Derived Systems
<p>
The original SysVR4 and other related systems did not have
any support for RFC1179 network printing (Berkeley LPD).
Support for this was added by various manufacture specific methods.
Unfortunately,
there are a wide range of possibilities.
<p>
The <tt/lpsched/ process (<tt>/usr/lib/lp/lpsched/</tt>)
process performs many of the functions of the LPRng and BSD
<tt/lpd/
server.
On Solaris systems,
it also stats the
<tt/lpNet/
server that provides network print services.
Unfortunately,
no <it/simple/ and reliable method of shutting down a running <tt/lpsched/
process
and the associated network services has been found.
However,
it turns out to be very simple to <em/prevent/ the services from
being started.
<p>
First,
you will need to locate the <tt>/etc/rc</tt> startup files
that start system services.
During system startup,
a set of shell scripts stored in the <tt>/etc/rc.d</tt>
directories are executed.
The individual startupfile files are usually links to a
common one in the <tt>/etc/init.d</tt> directory.
You first need to find the files containing the startup commands.
This is done as shown below:
<tscreen>
<verb>
SUN # cd /
SUN # grep -l lpsched /etc/rc* /etc/rc*/* init.d/* init.d/*/* >/tmp/files
SUN # cat /tmp/files
/etc/rc0.d/K20lp
/etc/rc2.d/K20lp
/etc/rc2.d/S80lp
/etc/init.d/lp
># ls -l ` cat /tmp/files `
lrwxrwxr-x 1 root bin 1 Dec 29 23:39 /etc/rc0.d/K20lp -> ../../init.d/lp
lrwxrwxr-x 1 root bin 1 Dec 29 23:39 /etc/rc2.d/K20lp -> ../../init.d/lp
lrwxrwxr-x 1 root bin 1 Dec 29 23:39 /etc/rc2.d/S80lp -> ../../init.d/lp
-rwxr--r-- 5 root sys 460 Sep 1 1998 /etc/rcS.d/K39lp
</verb>
</tscreen>
<p>
Here is the contents of the typical script file,  with the
indicated modifications that should be made for testing
<tscreen>
<verb>
#!/sbin/sh

#### ADD THE FOLLOWING LINE TO EXIT EARLY
exit 0
#### THE REST IS THE USUAL SCRIPT
case "$1" in
'start')
    [ -f /usr/lib/lpsched ] && /usr/lib/lpsched ;;
'stop' )
    [ -f /usr/lib/lpshut ] && /usr/lib/lpshut ;;
*) 
    echo "Usage: $0 &lcub; start | stop &rcub;"
    exit 1
esac
exit 0
</verb>
</tscreen>
<p>
Next,
as for the BSD installation,
we will find all of the printing related commands and rename them.
You can either rename them one by one,
or use the script method shown below.
The minimum of the indicated files should be renamed.
<tscreen>
<verb>
SUN # find /usr -type f -name lp\* -print >/etc/printingfiles
SUN # cat /tmp/printingfiles
/usr/bin/lp          <---
/usr/bin/lpstat      <---
/usr/lib/lp/bin/lp.cat
/usr/lib/lp/bin/lp.set
/usr/lib/lp/bin/lp.tell
/usr/lib/lp/lpNet    <---
/usr/lib/lp/lpsched  <---
/usr/lib/lp/lpdata   <---
/usr/sbin/lpadmin    <---
/usr/sbin/lpfilter   <---
/usr/sbin/lpforms    <---
/usr/sbin/lpmove     <---
/usr/sbin/lpshut     <---
/usr/sbin/lpsystem   <---
/usr/sbin/lpusers    <---
/usr/ucb/lpc         <---
/usr/ucb/lpq         <--- 
/usr/ucb/lpr         <---
/usr/ucb/lprm        <---
/usr/ucb/lptest
SUN # for i in ` cat /tmp/printingfiles ` ; do
>  mv $i $i.old
>  done
</verb>
</tscreen>
<p>
Next, you find if there is a <it/cron/ job scheduled
by the file
<tt>/var/spool/cron/crontabs/lp</tt>
to periodically update and roll over error logs.  
If there is, you should
(after having saved the file)
remove it.
<tscreen>
<verb>
cp /var/spool/cron/crontabs/lp /etc/cron.crontabs.lp
</verb>
</tscreen>
<p>
Check the <tt>/etc/inetd.conf</tt> file for a line like:
<tscreen>
<verb>
printer stream tcp nowait root /usr/lib/print/in.lpd in.lpd
</verb>
</tscreen>
<p>
Comment out this line.
This line is not present on all systems.
<p>
Now we must <em/reboot/  the machine.  You can use
<tt/reboot/ if you are in a rush,
and <tt/shutdown/ if you are not.
<tscreen>
<verb>
SUN # reboot
or
SUN # shutdown -y "Whooga! Whooga! Dive! Dive! System going down."
</verb>
</tscreen>
<p>
When the system reboots,
check to make sure that the
<tt/lpd/ server is not listening on port 515.
<tscreen>
<verb>
SUN # telnet localhost 515
Trying 127.0.0.1...
telnet: Unable to connect to remote host: Connection refused
</verb>
</tscreen>
<p>
If you do get a connection established
then you must use <tt/nlsadmin/ to force the
<it/tcpip listener/ to release the port, as illustrated below.
<tscreen>
<verb>
SUN # nlsadmin -v tcp
lpd  \x00020203000000000000000000000000  ENABLED  \
  NORPC  root  NOMODULES  /var/spool/lp/fifos/listenBSD  #
0  \x00020ACE000000000000000000000000  ENABLED    \
  NORPC  root  NOMODULES  /usr/lib/saf/nlps_server  #
lp  NOADDR  ENABLED  NORPC  root  NOMODULES \
  /var/spool/lp/fifos/listenS5  #
SUN # nlsadmin -r lpd tcp
SUN # nlsadmin -r lp tcp
</verb>
</tscreen>
<p>
Once you disable this,
you should try to reconnect to port 515.  If you still cannot,
then you have a problem  and need to reboot once more.
<p>
You might also want to run
<tt>pmadm -l</tt> and if you see anything other than zsmon stuff (e.g. lp
stuff is there), then use <tt>pmadm -r </tt>to remove it.
See the man page for details.
<sect1>Initial System Testing
<p>
We will now run the <tt/lpd/ executable in the
<tt/foreground/ and <tt/test/ mode,
and make sure that our system configuration is
correct.
It is best to do this with two screens or windows,
as you will want to observe the output.
<tscreen>
<verb>
# > /usr/local/bin/lpd -F
Fatal error - Another print spooler is using TCP printer port
# > /usr/local/bin/lpd -F -D1
...
1999-04-05-10:02:37.755 astart10 [28903] lpd  Read_file_and_split: \
  cannot open file '/etc/lpd.perms' - No such file or directory
1999-04-05-10:02:37.758 astart10 [28903] lpd  Read_file_and_split: \
  cannot open file '/usr/etc/lpd.perms' - No such file or directory
1999-04-05-10:02:37.759 astart10 [28903] lpd  Build_printcap_info: \
  list->count 0, raw->count 3
1999-04-05-10:02:37.777 astart10 [28903] lpd  lpd: listening socket fd -6
Fatal error - Another print spooler is using TCP printer port
1999-04-05-10:02:37.782 astart10 [28903] lpd  Get_max_fd: getrlimit returns 64
1999-04-05-10:02:37.783 astart10 [28903] lpd  Get_max_fd: returning 64
1999-04-05-10:02:37.786 astart10 [28903] lpd  cleanup: done, doing killpg \
   then exit(0)
</verb>
</tscreen>
<p>
If you get the above error message,
then you have either not killed off other the running <tt/lpd/ server
or you are not starting the <tt/lpd/ server as ROOT.
This is the most common error during setup.
Correct the problem and then restart the server if necessary.
You should see the output indicated below:
<tscreen>
<verb>
# > /usr/local/bin/lpd -F -D1
1999-04-05-14:35:14.023 astart27 [2667] Waiting  lpd: LOOP START
1999-04-05-14:35:14.024 astart27 [2667] Waiting  Get_max_servers: getrlimit returns 256
1999-04-05-14:35:14.024 astart27 [2667] Waiting  Get_max_servers: returning 128
1999-04-05-14:35:14.025 astart27 [2667] Waiting  lpd: max_servers 128, active 0
1999-04-05-14:35:14.025 astart27 [2667] Waiting  lpd: starting select timeout 'yes', 600 sec
</verb>
</tscreen>
<p>
Now from another window do the following commands:
<tscreen>
<verb>
# > lpq -Plp@localhost
Printer: lp@astart 
 Queue: no printable jobs in queue
# > lpq
Printer: lp@astart 
 Queue: no printable jobs in queue
</verb>
</tscreen>
<p>
At this point your LPRng software has been installed and tested.
You still need to set up
<it/Startup Scripts/
to automatically start it at boot time,
and
<tt>/etc/printcap</tt>
entries for your printers.
<sect1>Startup Scripts
<label id="startup">
<p>
The purpose of startup scripts is to automatically start the <tt/lpd/
print server at boot time.
Again,
the location and contents of these depend strongly on the
version of the Operating System, and system vendor.
<sect2> SunOS and BSD Derived
<p>
In most of these systems the startup script
for
<tt/lpd/
is already present in the
<tt>/etc/rc</tt> files
and only has to be modified.
It can be found by using:
<tscreen>
<verb>
ASTART # grep -l lp /etc/rc* /etc/rc*/* /etc/rc*/*/*
/etc/rc
ASTART # more /etc/rc
...
if [ -f /etc/printcap ]; then
    echo -n ' printer';     /usr/sbin/lpd
fi
</verb>
</tscreen>
<p> Modify this file so that path is to the LPRng <tt/lpd/ file.
<sect2> Solaris,  Linux, and SysVR4
<p>
These systems have individual startup files for each printing service.
We need to update the startup files to reference the LPRng executables.
<tscreen>
<verb>
SUN # grep -l lp /etc/rc* /etc/rc*/* init.d/* init.d/*/* >/tmp/files
SUN # cat /tmp/files
/etc/rc0.d/K20lp
/etc/rc2.d/K20lp
/etc/rc2.d/S80lp
/etc/init.d/lp
># ls -l ` cat /tmp/files `
lrwxrwxr-x  1 root  bin  1 Dec 29 23:39 /etc/rc0.d/K20lp -> ../../init.d/lp
lrwxrwxr-x  1 root  bin  1 Dec 29 23:39 /etc/rc2.d/K20lp -> ../../init.d/lp
lrwxrwxr-x  1 root  bin  1 Dec 29 23:39 /etc/rc2.d/S80lp -> ../../init.d/lp
-rwxr--r--  5 root  sys  460 Sep 1 1998 /etc/rcS.d/K39lp
</verb>
</tscreen>
<p>
Modify the startup files so that they use the LPRng <tt/lpd/ executable:
<tscreen>
<verb>
#!/sbin/sh
case "$1" in
'start')
        [ -f /usr/local/bin/lpd ] && /usr/local/bin/lpd
        ;;
'stop')
    echo "Shutting down lpd: \c"
    kill -2 `cat /var/run/lpd*` >/dev/null 2>1;
        ;;

*)
        echo "Usage: $0 &lcub; start | stop &rcub;"
        exit 1
esac
exit 0
</verb>
</tscreen>
<sect1>Replacing UNIX SystemV lp, lpstat Printing Services
<label id="lpsimulation">
<p>
Many UNIX utilities in the Solaris and HP UNIX environment use the
UNIX System V <tt>lp</tt> and <tt>lpstat</tt>
programs.
It is almost impossible to modify the programs themselves,
as many are <em/vintage/ software that is unsupported or which would
be too costly to update.
<p>
In order to support these applications,
LPRng provides simulation for the
<tt/lp/,
<tt/lpstat/,
and
<tt/clean/
commands.
<p>
The LPRng <tt/lpstat/ command is a modified version of the
<tt/lpq/ command,
and accepts the <tt/lpstat/ command line options and tries to return
status in an <tt/lpstat/ format.
<p>
If the <tt/lpr/ program is invoked with the name <tt/lp/,
it will simulate the <tt/lp/options.
Finally, if the <tt/lprm/ program is invoked with the name <tt/cancel/,
it will simulate the <tt/lp/options.
This can be done by using symbolic links or copying the programs.
<p>
Note that many of the <tt/vintage/ applications have fully qualified
paths to the <tt/lp/ and <tt/lpstat/ executables,
so it will be necessary to copy them to the original program locations.
<tscreen>
<verb>
# original - /usr/bin/lp
# original - /usr/bin/lpstat
cd /usr/local/bin
cp lpr /usr/bin/lp
cp lpstat /usr/bin/lpstat
cp lprm /usr/bin/cancel
</verb>
</tscreen>
<p>
See the man pages for lp, lpstat, and cancel in the LPRng/man directory.
Not all the functions of the original
programs are supported and
these man pages should be installed to replace the original
lp, etc, man pages.
<sect>System Specific Notes
<label id="sysdep">
<p>
The following are a set of suggestions and recommendations for
specific systems.
<sect1>Solaris 2.4, 2.5, 2.6, 2.7
<label id="solarisinstall">
<p>
The Sun Solaris operating system is derived from the System V UNIX
baseline.
Use the following installation procedure.
<enum>
<item>
First,
install the LPRng software
and then rename all of the existing Solaris print facilities.
See the
<ref id="installation" name="Installation"> section for details.
You should especially look out for
<tt>lp</tt>,
<tt>lpstat</tt>,
<tt>lpsched</tt>,
<tt>lpadmin</tt>,
and other executables used by Solaris for print support.
<item>
You may need to remove the <tt/printer/ entry in the
<tt>/etc/inetd.conf</tt> file.
Make sure it is removed.
<item>
<em>Reboot</em>.
Don't try to be fancy and kill off processes,
use the <em>nlsadmin</em> command,
or other insanity.
This is brutal,  but appears to be necessary in order to ensure
that the networking support is set up correctly.
</item>
<item>
When the system restarts, try using <tt>lpq</tt>
to check to see if the <tt>lpd</tt> server is active.
</item>
</enum>
<p>
James P. Dugal <tt>&lt;jpd@usl.ed&gt;</tt> has also made the following
suggestions as well.
<tscreen>
<verb>
From: "Dugal James P." <jpd@usl.edu>
To: lprng@iona.com
Subject: Re: [LPRng] start up trouble

Here are some more tips for Solaris:

1. If /var/spool/cron/crontabs/lp exists, remove it.

In fact, we actually test if /etc/init.d/lp exists on any newly-installed
system, and if so, we issue these commands:
        /etc/init.d/lp stop
        /usr/sbin/pkgrm -n SUNWpsu
        /usr/sbin/pkgrm -n SUNWscplp
        /usr/sbin/pkgrm -n SUNWpcu
        /usr/sbin/pkgrm -n SUNWpsr
        /usr/sbin/pkgrm -n SUNWpcr
        /bin/rm -f /var/spool/cron/crontabs/lp

Regards,
-- James Dugal, N5KNX           Internet: jpd@usl.edu
Associate Director              Ham packet: n5knx@k5arh.#lft.la.usa.noam
Computing Support Services      US Mail: PO Box 42770  Lafayette, LA  70504
University of Southwestern LA.  Tel. 318-482-6417       U.S.A.
</verb>
</tscreen>

<sect1>Solaris, Newsprint and FrameMaker
<p>
The following is a guide to using LPRng and
Sun Microsystems Newsprint by
Christopher Hylands, Ptolemy Project Manager
of the University of California.
<p>
The Sun Newsprint printer is actually
an OEM version of the  Tektronix PhaserII;
Sun Microsystems appears to have dropped support for Newsprint,
and the recommended migration path is to buy a PostScript printer.
If you want more information on using the Newsprint system,
notes are available via
<tt>http://ptolemy.eecs.berkeley.edu/~cxh/lprng.html</tt>.
<p>
Looking through the mailing list logs, it looks like everyone was
having a hard time getting lprng to work with Sun's brain-dead
newsprinters.  I tried using GhostScript, but the fonts were, IMHO,
ugly, so I spent a little time getting the newsprint fonts to work.
<p>
The key thing was to grab the file
<tt>/usr/newsprint/lpd/if</tt>
from a SunOS4.1.3 newsprint installation.
If you cannot get this code,
then the installation will be extremely difficult.
<p>
To install lprng on a Solaris2.x machine,
you need to first stop the existing print services and install the
startup scripts for LPRng.
Note that if there is a local printer, you may have
to also fix the permissions of the device. Typical commands are:
<tscreen>
<verb>
chown daemon /devices/sbus@1,f8000000/SUNW,lpvi@1,300000:lpvi0
</verb>
</tscreen>
<p>
We use the following simple <tt>if</tt> script.
<tscreen>
<verb>
#/bin/sh
# extremely simple filter script
/bin/cat
</verb>
</tscreen>
<p>
The Sparcprinters use licensed fonts from NeWSprint. To use the
licensed fonts, you must have the lprng spool directory for the
sparcprinter in the same location as spool directory of the brain
dead Solaris lp system.  If your printer is named xsp524, then this
directory would be <tt> /etc/lp/printers/xsp524</tt>.
<p>
The printcap entry looks like:
<tscreen>
<verb>
sp524|524:
    :mx=0:sf:sh:sb:
    :lp=:rm=doppler:rp=xsp524:
    :sd=/var/spool/lpd/sp524d:
    :lf=/var/spool/lpd/sp524d/log:
xsp524|Sun SPARCprinter NeWSprint printer:
    :mx=0:sf:sb:sh:rs:
    :lp=/dev/lpvi0:
    :sd=/etc/lp/printers/xsp524:
    :lf=/etc/lp/printers/xsp524/log:
    :af=/var/spool/lpd/xsp524/acct:
    :if=/usr/local/lib/newsprint/if:
</verb>
</tscreen>
<p>
The
<tt>/usr/local/lib/newsprint/if</tt>
was copied from
<tt>/usr/newsprint/lpd/if</tt>
in a SunOS4.x installation of the newsprint
software.
Unfortunately, the newsprint engine is so brain dead that it
needs many environment variables set, so it is fairly difficult to
come up with a clean script to start the engine. I made the following
changes to the file.
<enum>
<item>
First, set the path in the script.
You may also need to change defaults to suit your preferences:
<tscreen>
<verb>
PATH=/usr/ucb:/usr/bin:/etc:/usr/etc:/opt/NeWSprint/bin:/opt/NeWSprint/np/bin:
PATH=$PATH:$NPHOME/pl.$ARCH/bin:$NPHOME/np/bin; export PATH
</verb>
</tscreen>
</item>
<item>
You will also need a
<tt>/etc/lp/printers/printername/.params</tt>
file. If you
are using the same spooler directory as the directory that the Solaris
lp system uses, then the .param file should appear there. If you are
using a different spooler directory, then you will need to copy
the .param file from elsewhere and edit it accordingly.
</item>
<item>
If you are going to move a license to a new printer, you should
probably save the .param file in the old printer spooler directory.
Run /opt/NeWSprint/bin/fp_install and remove the license from the
old printer and assign it to the new printer.
You could run /opt/NeWSprint/bin/rm_np_printer and remove the printer,
but that will get rid of the .param file
</item>
<item>
FrameMaker under Solaris2.x uses the lp command. The fix is to edit
$FMHOME/fminit/FMlpr and comment out the lp line and add an lpr line
<tscreen>
<verb>
sunxm.s5.sparc)
    lpr -P"$PRINTER" "$FILE"
    #lp -c -d"$PRINTER" "$FILE"
</verb>
</tscreen>
</item>
</enum>
<tscreen>
<verb>
Christopher Hylands, Ptolemy Project Manager  University of California
cxh@eecs.berkeley.edu                 US Mail: 558 Cory Hall #1770
ph: (510)643-9841 fax:(510)642-2739       Berkeley, CA 94720-1770
home: (510)526-4010 (if busy -4068)       (Office: 493 Cory)
</verb>
</tscreen>
<sect1>Linux
<p>
At the time of this writing (Jan 1998),
the three major Linux
distributions (Slackware, Red Hat and Debian) carry an older version
of LPRng. Users of those systems should download the
latest stable release, and install that instead of the distributed
binaries.
<p>
This is mostly important for Slackware 3.2 users, as this version
installs LPRng by default.
Patrick Volkerding changed the default back to
BSD LPR in Slackware 3.3,
as many users had experienced problems
because they didn't realize they weren't using the BSD software.
<p>
Debian's <tt>dselect</tt> utility lets you choose between all
packages. Amongst these are LPRng, as well as the traditional LPR
software.
<p>
You have to make sure your kernel is configured correctly. The
documentation for the kernel sources in
<tt>/usr/src/linux/Documentation/</tt> and the <tt>Kernel-HOWTO</tt>
will help you to generate a new kernel if needed. You will need to set
the following options:
<itemize>
<item>Networking support (<tt>CONFIG_NET</tt>)</item>
<item>TCP/IP support (<tt>CONFIG_INET</tt>)</item>
<item>If your printer is connected to a parallel port, you will also
need the `Parallel Printer Support' (<tt>CONFIG_PRINTER</tt>).
You can use this as a module if you want.</item>
<item>For a serial printer, answer `Yes' when asked if you want
`Support for serial devices' (<tt>CONFIG_SERIAL</tt>). This is
also available as a module.</item>
</itemize>
<p>
Once you have done this,
the current releases of LPRng will install and run without
problems.
See the
<ref id="installingprograms" name="Installing the programs">
section for details on how to install LPRng and
deactivate the existing print support.
<p>
You may need to update the printcap file and filters.
See <ref id="printcapref" name="Using the Printcap Database">
for details.
<sect1>AIX
<p>
This information was supplied by
<htmlurl url="mailto:nitschke@math.unihamburg.de" name="Dirk Nitschke">,
as of August 1997,
and describes how to install the LPRng package on a workstation
running AIX 4.1.x and possibly 3.x.x as well.
Dirk would be interested in any comments or corrections.
<p>
Printing on AIX systems is different. AIX provides a general
queueing facility and printing is only one way to use it. You submit a
print job to a print queue using one of the commands
<tt>qprt</tt>, <tt>enq</tt>. You can use the BSD or
System V printing commands <tt>lpr</tt> or <tt>lp</tt>, too. The
qdaemon watches all (general) queues and knows how to handle your
job. A (general) queue is defined in the file
<tt>/etc/qconfig</tt>. The format of this file is different from
the <tt>printcap</tt> format.
<p>
OK, how to replace the AIX printing system? There is no group
<tt>daemon</tt> on AIX. Therefore you have to change the default
group for file ownership and process permissions. We decided to use
the <tt>printq</tt> group. The user <tt>daemon</tt> exists on
AIX but we have chosen <tt>lpd</tt> as the user who runs
<tt>lpd</tt> and all filters and owns the spooling directories.
You can change the values for <tt>group</tt>
and <tt>user</tt> in your
<tt>lpd.conf</tt> file or in the sources
<tt>src/common/vars.c</tt>. This is an example for
<tt>lpd.conf</tt>:
<tscreen>
<verb>
# Purpose: group to run SUID ROOT programs
#   default group=daemon
group=printq
# Purpose: server user for SUID purposes
#   default user=daemon
user=lpd
</verb>
</tscreen>
Compile and install the LPRng package. Create your
<tt>printcap</tt>, spooling directories, accounting and logfiles
and so on.
Don't forget to use
<ref id="checkpc" name="checkpc"> to make sure that all the
permissions are set correctly and the necessary files
are created.
<p>
Then stop all print queues defined on your workstation. Use
<tscreen>
<verb>
# chque -q queuename -a "up = FALSE"
</verb>
</tscreen>
for this (yes, blanks around <tt>=</tt> are needed).
<p>
If you have local printers attached to your system you will have an
<tt>lpd</tt> running. Stop this daemon using SMIT (Print Spooling,
Manage Print Server, Stop the Print Server Subsystem). Choosing
<tt>both</tt> also removes <tt>lpd</tt> from
<tt>/etc/inittab</tt>. Maybe it's faster to do this by hand:
<tscreen>
<verb>
# stopsrc -p'pid of /usr/sbin/lpd'
# rmitab "lpd"
</verb>
</tscreen>
<p>
Now delete all print queues (managed by qdaemon) defined on your
system. You can use SMIT for this or the commands
<tt>&lcub;mk,ch,rm&rcub;que</tt>, <tt>&lcub;mk,ch,rm&rcub;quedev</tt>,
<tt>&lcub;mk,ch,rm&rcub;virprt</tt>. The SMIT fast path is <tt>smit
rmpq</tt>.
<p>
To start the new <tt>lpd</tt> at system startup you have to add
an entry to <tt>/etc/inittab</tt>:
<tscreen>
<verb>
# mkitab "lpd:2:once:/full/path/lpd"
</verb>
</tscreen>
<p>
Some work has to be done if have have a local printer attached to
your workstation. You have to create a device file like
<tt>/dev/lp0</tt>. The SMIT fast path for this is <tt>smit
mkdev</tt>. Choose <tt>Printer/Plotter</tt> and then
<tt>Printer/Plotter Devices</tt>. Now <tt>Add a
Printer/Plotter</tt>. To create a parallel
printer device select the following:
<tscreen>
<verb>
Plotter type:              opp Other parallel printer
Printer/Plotter Interface: parallel
Parent Adapter:            ppa0 Available
</verb>
</tscreen>
Now define the characteristics of the device:
<tscreen>
<verb>
Port Number: p
</verb>
</tscreen>
(<tt>p</tt> is for parallel).
Go to the field
<tscreen>
<verb>
Send all characters to printer UNMODIFIED   no
</verb>
</tscreen>
and select <tt>yes</tt>! We have had a lot of trouble with
<tt>no</tt>.  This is very important! Expect erroneous output if
you choose <tt>no</tt>. If you have already created a device
file, change the characteristics! SMIT's fast path is <tt>smit
chdev</tt>.
<p>
Finally remove all AIX printing commands like <tt>qprt</tt>,
<tt>lp</tt>, <tt>cancel</tt>, <tt>lpr</tt>,
<tt>lprm</tt>. You will find a lot of them in
<tt>/usr/bin</tt>. Do not remove <tt>enq</tt> and friends if
you want to use the general queueing facility.
<p>
Now you can start your new <tt>lpd</tt>.
<sect1>AppleTalk Support
<p>
Netatalk is used to communicate from TCP/IP to
AppleTalk printers and vice versa.
The Netatalk distribution FAQ is at:
<p>
<htmlurl url="http://www.umich.edu/~rsug/netatalk" name="http://www.umich.edu/~rsug/netatalk">
<p>
There are two issues with using netatalk.  The first issue
has to do with printing to LPRng-served printers from Macs.
The second issue has to do with printing from LPRng to
network printers that speak AppleTalk.
<p>
<sect1>Apple to LPRng Printing
<p>
After you have installed and gotten netatalk working,
you can use the following configuration file to print
from a Macintosh to an LPRng printer.
<tscreen>
<verb>
Date: Tue, 30 Sep 1997 00:04:58 -0400 (EDT)
From: Edan Idzerda <edan@mtu.edu>
To: lprng@iona.com
Subject: Re: [LPRng] Netatalk configuration file
> Somebody posted a very nice Netatalk papd.conf file
> that showed the setup for LPRng.  If anybody has this
> handy could you post it?
Well, *I* use:
Your 32 Character Printer Name:\
        :pr=|/your/path/to/lpr -Pprintername
        :ppd=/your/path/to/ppd/files/yourprinter.ppd
--
Edan Idzerda    <edan@mtu.edu>
System Administrator -- Michigan Technological University, Houghton MI USA
</verb>
</tscreen>
<sect1>LPRng to AppleTalk Printing
<p>
The netatalk package comes with a PostScript filter called <tt>psf</tt>.  After
compilation, it is in (e.g.) <tt>netatalk-1.4b2/etc/psf</tt> and will be installed
in (e.g.) <tt>/usr/local/atalk/etc/</tt>.  After installation, there will also
be a directory <tt>/usr/local/atalk/etc/filters</tt> that contains
<tt>ifpap</tt>, <tt>ofpap</tt>,
et al.  These are just symlinks to <tt>psf</tt>, and <tt>psf</tt> will do the appropriate
thing based on how it was invoked.  If there's a 'pap' in the name,
<tt>psf</tt> uses AppleTalk to talk to the printer.  See psf(8) for more information.
<p>
A printcap entry for a network printer looks like the following:
<tscreen>
<verb>
dave|Dave's 32 Character Printer Name
    :sd=/var/spool/lpd/dave
    :if=/usr/local/atalk/etc/filters/ifpap
    :of=/usr/local/atalk/etc/filters/ofpap
    :lp=/var/spool/lpd/dave/null
</verb>
</tscreen>
<p>
There are three caveats to using netatalk this way.
<enum>
<item>
The first is that
<tt>psf</tt> (i.e., the filters) needs to run as root.  You can accomplish this
in one of two ways.  The first requires LPD to run the programs as root: 
<tscreen>
<verb>
# ROOT_CFLAG=-DROOT_PERMS_TO_FILTER_SECURITY_LOOPHOLE
</verb>
</tscreen>
<p>
The filter lines then need to look like the following:
<tscreen>
<verb>
    :if=ROOT /usr/local/atalk/etc/filters/ifpap
    :of=ROOT /usr/local/atalk/etc/filters/ofpap
</verb>
</tscreen>
<p>
The alternative is to make <tt>psf</tt> SETUID root.
To minimize the risk,
you may want to make <tt>psf</tt> executable only by group <tt>daemon</tt>.
(I haven't tested the first option.  I'm currently using the second option.)
<p>
<item>
The second caveat is that each network printer needs a <tt>.paprc</tt> in its
spool directory.  For instance, <tt>/var/spool/dave/.paprc</tt> looks like this:
<tscreen>
<verb>
Dave's 32 Character Printer Name:LaserWriter@Your AppleTalk Zone
</verb>
</tscreen>
<p>
See psf(8) and pap(1) for more information.
<p>
<item>
The third caveat concerns the lp line in the printcap entry.  For a
single printer, this can be <tt>/dev/null</tt>.  If the host spools to more
than one AppleTalk printer, you shouldn't use <tt>/dev/null</tt> for lp.  You
should use <tt>mknod</tt> to create a null device for each printer.  See psf(8).
</enum>
<tscreen>
<verb>
Chad Mynhier <mynhier@cs.utk.edu>
Lab Engineer, CS Department        
University of Tennessee, Knoxville                   
</verb>
</tscreen>
<sect1>SAMBA, SMB and LPRng
<label id="smb">
<p>
SMB is the protocol by which a lot of
PC-related machines share files and printers and other information
such as lists of available files and printers. Operating systems that
support this natively include Windows NT, OS/2, and Linux and add on
packages that achieve the same thing are available for DOS, Windows,
VMS, Unix of all kinds, MVS, and more. There is no reason why Apple
Macs and indeed any Web browser should not be able to speak this
protocol, and current development (in which the Samba team is heavily
involved) is aimed at exactly that. Alternatives to SMB include
Netware, NFS, AppleTalk, Banyan Vines, Decnet etc; many of these have
advantages but none are both public specifications and widely
implemented in desktop machines by default.
<p>
SAMBA is a package that supports the SMB protocol and provides
a simple and easy way to import and export file systems and printer
facilities.
The web site for SAMBA is
<htmlurl url="http://www.samba.org" name="http://www.samba.org">.
<p>
The SAMBA code is very easy to configure.  See the SAMBA
<tt>doc/text/Printing.txt</tt> and related documentation for details.
In the
<tt/samba.conf/ file
<tt/[global]/ section you specify the
<tt/print/, <tt/lpq/, and <tt/lprm/ commands to be used,
and in the <tt/[printing]/ section the location
of a temporary directory to hold print jobs when they are submitted.
<tscreen>
<verb>
[printers]
    path = /tmp
    guest ok = no
    print ok = yes
    printing = lprng
    load printers = yes 
    printcap name = /etc/printcap
    print command = /usr/local/bin/lpr  -P%p -r %s
    lpq command   = /usr/local/bin/lpq  -P%p
    lprm command  = /usr/local/bin/lprm -P%p %j
    lppause command = lpc hold %p %j
    lpresume command = lpc release %p %j
    queuepause command = lpc -P%p stop
    queueresume command = lpc -P%p start
	#
    # alternative to allow userid to be specified as well
	#
    # You will have to add the samba UID to the 'allow_user_setting'
    #   option in the /etc/lpd.conf file.
    # WARNING: the %U is the name the user requests.  If you have
	# 'guest' printer use,  then you should be aware that this
	# will allow anybody to impersonate a another user,  and they will
	# be able to execute the various LPRng commands as that user.
	#
#   print command = /usr/local/bin/lpr -U%U -P%p -r %s
#   lprm command  = /usr/local/bin/lprm -P%p -U%U %j
#   lppause command = lpc -U%U hold %p %j
#   lpresume command = lpc -U%U release %p %j
#   queuepause command = lpc -U%U -P%p stop
#   queueresume command = lpc -U%U -P%p start
</verb>
</tscreen>
<p>
The path= value specifies a directory where
the print files are temporarily stored.  This must NOT
be an LPRng printer spool directory,  but some other directory that
Samba has write permissions for.
<p>
If you plan to use SAMBA and LPRng,
then you should use the old BSD format for the printcap files,
i.e.- using the <tt/\/ line continuation indicator.
<sect1> Printing to a NetBEUI Printer
<p>
You can use the SAMBA smprint script to
send a print job to an SMB client.
<tscreen>
<verb>
#!/bin/sh -x
# This script is an input filter for printcap printing on a unix machine. It
# uses the smbclient program to print the file to the specified smb-based 
# server and service.
# For example you could have a printcap entry like this
#
# smb:lp=/dev/null:sd=/usr/spool/smb:sh:if=/usr/local/samba/smbprint
#
# which would create a unix printer called "smb" that will print via this 
# script. You will need to create the spool directory /usr/spool/smb with
# appropriate permissions and ownerships for your system.
#
# The /usr/spool/smb/.config file should contain:
#   server=PC_SERVER
#   service=PR_SHARENAME
#   password="password"
#
# Set these to the server and service you wish to print to 
# In this example I have a WfWg PC called "lapland" that has a printer 
# exported called "printer" with no password.
#
# E.g.
#   server=PAULS_PC
#   service=CJET_371
#   password=""
# Should read the following variables set in the config file:
#   server, service, password
config_file=.config
eval `/bin/cat $config_file`
# echo "server $server, service $service" 1>&2
# NOTE You may wish to add the line `echo translate' if you want automatic
# CR/LF translation when printing.
(
#   echo translate
    echo "print -"
    /bin/cat
) | /usr/local/bin/smbclient "\\\\$server\\$service" \
   "$password" -U "$server" -N -P 1>&2
</verb>
</tscreen>
<p>
If the above script was in <tt>/usr/local/lib/filters/smbprint</tt>,
the printcap entry for this printer would be:
<tscreen>
<verb>
pauls_pc:
  :sd=/var/spool/lpd/%P
  # we filter the output
  :lp=|/usr/local/lib/filters/smbprint
  # you can add filters if you want to do specific actions
  :ifhp=model=hp4
  if=/usr/local/lib/filters/ifhp
</verb>
</tscreen>
<sect1>Printer Specific notes
<label id="printspec">
<p>
This is a small collection of miscellaneous notes about printers
and applications.
<sect1>HP Deskjet
<p>
<tscreen>
<verb>
From: jarausch@igpm.rwth-aachen.de (Helmut Jarausch)
Subject: Re: Using gs (GhostScript) as a filter? 
To: lprng@iona.com
Cc: Rick Gaine <rgaine@nbcs.rutgers.edu>
Sender: majordomo-owner@iona.com
Reply-To: lprng@iona.com
>> 
>> Hello All:
>> 
>> I would like to use LPRng 3.1.4 with an HP LaserJet 4P.  I'd like to be
>> able to use gs to convert PostScript files so that I can print them on my
>> HP 4P.  Can I do this with LPRng?  If so, could someone send me a printcap
>> entry?  I'd appreciate it.  I am not sure how I will be connecting the
>> printer yet, but I am thinking either serial or network.  Probably serial
>> though.  Thanks for any help.
</verb>
</tscreen>
<p>
This printcap works for my Deskjet:
<tscreen>
<verb>
djps
    :cm=Local Deskjet(GhostScript)
    :sd=/var/spool/djps:sf:sh:mx=0
    :lp=/dev/plp
    :if=/usr/local/bin/LPRng/ps_to_deskjet:
</verb>
</tscreen>
<p>
and this is the script /usr/local/bin/LPRng/ps_to_deskjet
<tscreen>
<verb>
#!/bin/sh
nice -19 /usr/local/bin/gs -sDEVICE=cdj550 -sPAPERSIZE=a4 \
    -sOutputFile=- -q -r300 - 
</verb>
</tscreen>
<tscreen>
<verb>
Helmut Jarausch
Lehrstuhl f. Numerische Mathematik
Institute of Technology
RWTH Aachen
D 52056 Aachen, Germany
</verb>
</tscreen>
<sect1>HP LaserJet IIISiMX
<p>
<tscreen>
<verb>
> From majordomo-owner@iona.com Mon Aug 31 11:17:26 1998
> To: lprng@lprng.org
> Subject: [LPRng] problems printing PS-level2 jobs on LjIIsi's...
> Date: Mon, 31 Aug 1998 15:06:22 -0400
> From: "John Saroglou" <johny@yorku.ca>
>
> Greetings...
>
> I'm wondering if someone got around the problem of printing
> Postscript(R) Level 2  jobs on Laser Jet IIIsi printers.
> Our printers are direct network printers talking to a
> print server running solaris 2.6 and lprng-3.5.1.
>
> Is there a fix (possible drivers?) for such problem?
>
> Thanks in advance.
</verb>
</tscreen>
<p>
The LaserJet IIISi does not support PostScript level 2, only level 1
(really, it is called 3SiMX).
The Windows (you are under Windows, right?) HP driver for 3Si/3Si MX
PostScript should produce only PS level 1.
<p>
Beware: latest version of Adobe Windows PS driver produces *ONLY* PS
level 2.
So if you have (or receive) level 2 files, read them using GhostScript
and print a screen dump :-) or as a bitmap. 
<p>
You can also convert them into PDF (using either Adobe distiller or
GhostScript's ps2pdf) then use <it/acroread/ to print the result.
<it/Acroread/ can
produce either level 1 or level 2 PostScript. THE definite solution!
<p>
This trouble has nothing to do with the way they are connected,
it is only a driver problem.
I believe that HP had once a PS level2 update, but the price was so high
that buying a new printer was a better solution!
<tscreen>
<verb>
Bertrand
-- 
| Bertrand DECOUTY              | mailto:Bertrand.Decouty@irisa.fr   |
| IRISA - INRIA (Atelier)       | PHONE : 0299847346 / 0299847100    |
| Campus de Beaulieu            | FAX   : +33 (0) 299842534          |
| F-35042 Rennes Cedex - FRANCE | http://www.irisa.fr/               |
</verb>
</tscreen>
<sect1> HP JetDirect Interface
<p>
The  HPJetDirect  card  can  be configured through the front
panel  or through a set of network files.  Here is a summary
of  the  methods  used  from  UNIX  systems, or when you are
desperate, to configure the printer.
<sect2> Setting Up IP Networking and Address
<p>
You can set the network address from the front panel.
Reset  the printer,
put it in offline mode.
and then use the MENU, +-, SELECT keys as follows:
<tscreen>
<verb>
 MENU  -> MIO MENU (use MENU to display MIO MENU)
 ITEM  -> CFG NETWORK=NO*
 +     -> CFG NETWORK=YES
 ENTER -> CFG NETWORK=YES*
 ITEM  -> TCP/IP=OFF* (use ITEM to display TCP/IP)
 +     -> TCP/IP=ON
 ENTER -> TCP/IP=ON*
 ITEM  -> CFG TCP/IP=NO* (use ITEM to display TCP/IP)
 +     -> CFG TCP/IP=YES
 ENTER -> CFG TCP/IP=YES*
 ITEM  -> BOOTP=NO*
     (Enable BOOTP if you want to - see below)
 ITEM  -> IP BYTE 1=0*
     This is IP address MSB byte.
     Use +- keys to change value, and then ENTER to change
     Use ITEM keys to get IP BYTE=2,3,4
 ITEM  -> SM BYTE 1=255*
      This is the subnet mask value
     Use +- keys to change value, and then ENTER to change
     Use ITEM keys to get IP BYTE=2,3,4
 ITEM  -> LG BYTE 1=255*
     This is the Syslog server (LoGger) IP address
     Use +- keys to change value, and then ENTER to change
     Use ITEM keys to get IP BYTE=2,3,4
 ITEM  -> GW BYTE 1=255*
     This is the subnet gateway (router) IP address
     Use +- keys to change value, and then ENTER to change
     Use ITEM keys to get IP BYTE=2,3,4
 ITEM  -> TIMEOUT=90
      This is the connection timeout value.  It puts a limit
     on time between connections.  A value of 10 is reasonable.
</verb>
</tscreen>

<sect2> BOOTP Information

<p>
If  you have a bootp server, you can put this information
in  the  bootptab  file.   To  use this, you must enable the
bootp  option  on  the printer.  The T144 option specifies a
file to be read from the bootp server.  This file is read by
using  the  TFTP  protocol, and you must have a TFTPD server
enabled.  Here is a sample bootptab entry.
<tscreen>
<verb>
# Example /etc/bootptab: database for bootp server (/etc/bootpd).
# Blank lines and lines beginning with '#' are ignored.
#
# Legend:
#
#       first field -- hostname
#                       (may be full domain name)
#
#       hd -- home directory
#       bf -- bootfile
#       cs -- cookie servers
#       ds -- domain name servers
#       gw -- gateways
#       ha -- hardware address
#       ht -- hardware type
#       im -- impress servers
#       ip -- host IP address
#       lg -- log servers
#       lp -- LPR servers
#       ns -- IEN-116 name servers
#       rl -- resource location protocol servers
#       sm -- subnet mask
#       tc -- template host (points to similar host entry)
#       to -- time offset (seconds)
#       ts -- time servers
#
# Be careful about including backslashes where they're needed.  Weird (bad)
# things can happen when a backslash is omitted where one is intended.
#
peripheral1:
:hn:ht=ether:vm=rfc1048:
:ha=08000903212F:
:ip=190.40.101.22:
:sm=255.255.255.0:
:gw=190.40.101.1:
:lg=190.40.101.3:
:T144="hpnp/peripheral1.cfg":
</verb>
</tscreen>
<p>
If  you  are  using the T144 option, you will need to create
the  configuration file.  The sample configuration file from
the HP Direct distribution is included below.
<tscreen>
<verb>
#
# Example HP Network Peripheral Interface configuration file
#
# Comments begin with '#' and end at the end of the line.
# Blank lines are ignored.  Entries cannot span lines.

# Name is the peripheral (or node) name.  It is displayed on the peripheral's
# self-test page or configuration plot, and when sysName is obtained through
# SNMP.  This name can be provided in the BOOTP response or can be specified
# in the NPI configuration file to prevent the BOOTP response from overflowing
# the packet.  The domain portion of the name is not necessary because the
# peripheral does not perform Domain Name System (DNS) searches.  Name is
# limited to 64 characters.

name: picasso

# Location describes the physical location of the peripheral.  This is the
# value used by the interface for the MIB-II sysLocation object.  The default
# location is undefined.  Only printable ASCII characters are allowed.
# Maximum length is 64 characters.

location: 1st floor, south wall

# Contact is the name of the person who administers or services the peripheral
# and may include how to contact this person.  It is limited to 64 characters.
# This is the value used by the interface for the MIB-II sysContact object.
# The default contact is undefined.  Only printable ASCII characters are
# allowed.  Maximum length is 64 characters.

contact: Phil, ext 1234

# The host access list contains the list of hosts or networks of hosts
# that are allowed to connect to the peripheral.  The format is
# "allow: netnum [mask]", where netnum is a network number or a host IP
# address.  Mask is an address mask of bits to apply to the network number
# and connecting host's IP address to verify access to the peripheral.
# The mask usually matches the network or subnet mask, but this is not
# required.  If netnum is a host IP address, the mask 255.255.255.255 can
# be omitted.  Up to ten access list entries are permitted.

# to allow all of network 10 to access the peripheral:
allow: 10.0.0.0  255.0.0.0

# to allow a single host without specifying the mask:
allow: 15.1.2.3

# Idle timeout is the time (in seconds) after which an idle
# print data connection is closed.  A value of zero disables
# the timeout mechanism.  The default timeout is 90 seconds.

idle-timeout: 120

# A community name is a password that allows SNMP access to MIB values on
# the network peripheral.  Community names are not highly secure; they are
# not encrypted across the network.  The get community name determines which
# SNMP GetRequests are responded to.  By default, the network peripheral
# responds to all GetRequests.  The get community name is limited to 32
# characters.
#
# For hpnpstat and hpnpadmin, the community name can be stored in
# /usr/lib/hpnp/hpnpsnmp.

get-community-name: blue

# The set community name is similar to the get community name.  The set
# community name determines which SNMP SetRequests are responded to.  In
# addition, SetRequests are only honored if the sending host is on the
# host access list.  By default, the network peripheral does not respond
# to any SetRequests.  The set community name is limited to 32 characters.
#
# The set community name can come from /usr/lib/hpnp/hpnpsnmp
# if it is the same as the get community name.  We recommend that the
# set community name be different from the get community name though.

set-community-name: yellow

# SNMP traps are asynchronous notifications of some event that has occurred.
# SNMP traps are useful only with network management software.  Traps are
# sent to specific hosts and include a trap community name.  Up to four
# hosts can be sent SNMP traps.   The trap community name is limited to
# 32 characters.  The default name is public.

trap-community-name: red

# The SNMP trap destination list specifies systems to which SNMP
# traps are sent.  Up to four IP addresses are allowed.  If no
# trap destinations are listed, traps are not sent.

trap-dest: 15.1.2.3
trap-dest: 15.2.3.4

# The SNMP authentication trap parameter enables or disables the sending
# of SNMP authentication traps.  Authentication traps indicate that an SNMP
# request was received and the community name check failed.  By default,
# the parameter is off.

authentication-trap: on

# The syslog-facility parameter sets the source facility identifier that the
# card uses when issuing syslog messages.  Other facilities, for example,
# include the kernel (LOG_KERN), the mail system (LOG_MAIL), and the spooling
# system (LOG_LPR).  The card only allows its syslog facility to be configured
# to one of the local user values (LOG_LOCAL0 through LOG_LOCAL7).  The
# selectible option strings, local0 through local7 (configured to LOG_LOCAL0
# through LOG_LOCAL7, respectively) are case insensitive.  The default
# syslog-facility for the card is LOG_LPR.

syslog-facility: local2

# This parameter allows the card to treat hosts on other subnets as if the
# hosts were on the card's subnet.  This parameter determines the TCP
# Maximum Segment Size (MSS) advertised by the card to hosts on other subnets
# and affects the card's initial receive-window size.  The card will use a
# TCP MSS of 1460 bytes for local hosts, and 536 bytes for a non-local host.
# The default is off, that is, the card will use the maximum packet sizes
# only on the card's configured subnet.
#
# The configuration utility does not allow access to this parameter.  If you
# want to configure it, you must manually edit the NPI configuration file
# and add it to the bottom of the entry for the network peripheral.

subnets-local: on

# This parameter affects how the card handles TCP connection requests from
# the host.  By default, the JetDirect MPS card will accept a TCP connection
# even if the peripheral is off-line.  If this parameter is set to "on", then
# the card will only accept a TCP connection when the peripheral is on-line.

old-idle-mode: off
</verb>
</tscreen>

<sect2> Paper Tray Selection
<p>
Be careful with your paper tray selection.  You should configure the
printer,  using the front panel switches,  to select the FIRST paper
tray.  See your printer documentation on this.  Unfortunately,  different
models of HP printers have different methods of handling paper trays.
<sect1>Lexmark Printers
<p>
Some Lexmark printers do not send
<em>end of job</em> status back unless configured
to do so.
Here is what is needed to force this.
<tscreen>
<verb>
Date: Wed, 21 Jan 1998 18:25:50 -0600 (CST)
From: Matt White <whitem@bofh.usask.ca>
To: lprng@iona.com
Subject: Re: [LPRng] ifhp with Lexmark Optra N printer

On Wed, 21 Jan 1998, Simon Greaves wrote:

> Apologies in advance if this is way off mark, but we've been evaluating a
> commercial print charging package (Geomica) which works by talking to the
> printer in what I think is a similar way to the ifhp filters. Lexmarks are
> currently a big headache because they seem to fail to return the message
> that they have finished printing which screws things up somewhat. In our
> case, it is believed to be a problem with the Lexmark firmware which they
> are looking into. 

There is a fix for that...it is originally from the Lexmark 4039 series,
but it still works on the Optra S 1650 machines that we have (and should
work on the rest of the optra line).  Just send this little chunk of
postscript to the printer once:

-----------snip----------
%! Postscript utility file to set the 4039 printer into synchronous mode
serverdict begin 0 exitserver
statusdict begin true setenginesync end
-----------snip----------

Basically, it causes the printer to wait until it is finished printing
before actually reporting that it is done.  I've got 3 Optra S printers
running with ifhp right now with no extra options (just defaults).
 
---------------------------------------------------------------------
- Matt White                         whitem@arts.usask.ca           -
- Network Technical Support          http://arts.usask.ca/~whitem   -
- College of Arts & Science          University of Saskatchewan     -
---------------------------------------------------------------------
</verb>
</tscreen>

<sect1>Network Base Tektronix Phaser Printers
<label id=P450>
<p>
The <tt/ifhp/ filter supports the
<ref id="appsocket" name="APPsocket"> protocol used by Tektronix.
You will need a printcap similar to the following:
<tscreen>
<verb>
phaser:
 :sd=/var/spool/lpd/%P
 # need a dummy device for output
 :lp=/dev/null
 # You need to specify the IP address of the printer's network interface
 #  In this example it is 10.0.0.1 - replace with the correct value
 # The filter will actually open the connection.
 :if=/usr/local/lib/filter/ifhp -Tdev=10.0.0.1%9100,model=tek
</verb>
</tscreen>
<sect1>Duplex Printing
<p>
Duplex printing is when you print on both sides of a page.
Some printers which do duplex printing require that you
send them special commands to force this mode.  This is
usually done by the FILTERS.  The IFHP filter makes a stab at sending
the PJL or PostScript commands to the printer.  Many people have
reported problems doing duplex printing,  so  here is a check
list.
<enum>
<item>
Make sure you have enough memory for the worst case
print job.  Usually the printer has to rasterize both
pages before it can produce an impression.  It may require
much more memory than you expect.
<item>
Check your printer manual to discover the EXACT form of the
<tt>enter duplex mode</tt> command and make sure that either the command
is part of the job (PJL language at the start of the job,
postscript header, etc), or that the filter generates the
correct form.
<p>
Note there is a PostScript Printer Description file (PPD) for
most printers that support PostScript,  and they even have the
PJL and PostScript code for this in the PPD file.
<item>
It has been observed that even with what would apparently be
sufficient memory,  that many duplex jobs print 'oddly',
that they are not aligned on the same side in the same way,
etc etc.  This may not be the fault of the software,  but of the
support for duplex operation.
<item>
Read the IFHP documentation,
and create a configuration section in the <tt/ifhp.conf/ file
for your printer.
</enum>
<p>
I know this is painful,  but until there is a uniform way to get the
correct commands extracted from either PPD or some other database then
this appears to be the only way to do it.
<quote>
<em>
Patrick Powell
</em>
</quote>
<sect1>Test Version  and Portability Testing
<p>
The LPRng code has the ability to run as non-setuid software,
and to use the non-default TCP/IP ports for communication.
This facility allows a <em>Test Version</em> to be run in parallel with the
normal LPRng software.
<p>
To simplify testing and portability issues,
a simple test version of the spool queues and jobs has been supplied with the
LPRng distribution.
These queues can be placed in a suitable location
(<tt>/tmp</tt> is common) and the LPRng software tested.
<p>
The test version of the software will use the <tt>LPD_CONF</tt>
environment variable to specify the location of the configuration file.
It will read this configuration file on startup and use the values
to override the normal defaults.
Since a user could maliciously set up their own configuration files
with values that could compromise system security,
it is strongly recommended that the test version is not made SETUID root.
In fact,
the LPRng code will chatter messages when the LPD_CONF ability is enabled
and it is run as root.
<sect2>Compiling the Test Version
<p>
Edit <tt>src/Makefile</tt>, and uncomment the indicated line.
Then run <tt>make</tt> to regenerate the distribution.
<tscreen>
<verb>
#### ****** TESTING AND SECURITY LOOPHOLE ******************************
# Define GETENV to allow the LPD_CONFIG environment
#  variable to be used as the name of a configuration file.  In non-testing
#  systems,  this is a security loophole.
#CF := $(CF) -DGETENV

</verb>
</tscreen>
<sect2>Setting Up The Test Version Spool Queues
<p>
The LPRng <tt>TESTSUPPORT</tt> directory contains a set of shell scripts
and files that need to be installed in the appropriate directory.
The following steps are used.
<enum>
<item>
First,
you need to set up your <tt>HOST</tt> environment variable to the fully
qualified domain name of your host
and your <tt>USER</tt> environment variable to your user name.
This is done in order to get values to put into the Test Version configuration files.
<item>
In the <tt>TESTSUPPORT</tt> directory,
edit the <tt>Makefile</tt>,
and specify the location of the <tt>Test Version</tt> spool queues.
The default location is <tt>/tmp</tt>;
since on most systems these files are deleted or are available to everybody,
a more secure location should most likely be used.
<bf>DO NOT USE THE RAW TESTFILE DIRECTORY</bf>.
These files need to be copied and placed in another directory.
<item>
The <tt>LPD_CONF</tt> environment variable should be set to the
location of the installed <tt/lpd.conf/ file.
<item>
In the <tt>TESTSUPPORT</tt> directory,
run <tt>make</tt>.
This will copy and install the necessary files.
</enum>
<p>
Example:
<tscreen>
<verb>
  CSH:
    setenv HOST &lcub;fully qualified domain name&rcub;;
    setenv USER `whoami`
    setenv LPD_CONF /tmp/LPD/lpd.conf
    set path=( /tmp/LPD $path )
    unsetenv PRINTER
   Example:
      setenv HOST astart1.astart.com
      setenv USER papowell
      setenv LPD_CONF /tmp/LPD/lpd.conf
      set path=( /tmp/LPD $path )
      unsetenv PRINTER
  Bourne Shell:
    HOST=&lcub;fully qualified domain name&rcub;; export HOST;
    USER='whoami'; export USER
    LPD_CONF=/tmp/LPD/lpd.conf.$HOST; export LPD_CONF
    PATH=/tmp/LPD:$PATH; export PATH
    PRINTER=; export PRINTER
   Example: 
      HOST=astart1.astart.com; export HOST
      USER=papowell; export USER
      LPD_CONF=/tmp/LPD/lpd.conf.$HOST; export LPD_CONF
      PATH=/tmp/LPD:$PATH; export PATH
      PRINTER=; export PRINTER
  cd TESTSUPPORT
  make
</verb>
</tscreen>
<sect2>Running the Test Version Software
<p>
Set your current directory to the location of the compiled <tt>Test Version</tt>
executables.
Execute the various executables using <tt>./cmd</tt>,
or set <tt>.</tt> <bf> as the first entry in the PATH </bf>.
If it is not the first entry,
then the standard system executables will be used.
<enum>
<item> Run <tt>./checkpc</tt>.
this will print out the various values for the spool queues in the <tt>Test Version</tt>
setup.
If the <tt>t1</tt>, <tt>t2</tt>,... spool queues are not displayed,
make sure that the LPD_CONF environment variable is set correctly and that you
are using the <tt>Test Version</tt> executable.
<item>Run <tt>./checkpc -f</tt>.
This will fix up the (deliberately introduced) problems in the spool queues.
<item>
Next,  run <tt>./lpd -F</tt> in one window,
and then run <tt>./lpq -a </tt> in another window.
This will check that the server is working.
<item>
You can now amuse yourself by sending jobs,
setting up permissions checking,
and other chores.
<item>
When everything appears to be working correctly,
you can then remove the <tt>Test Version</tt> flag from the
<tt>src/Makefile</tt>, recompile,
and install the LPRng software.
</enum>
<sect>The Most Frequently Asked Questions
<label id="FAQ">
<p>
In this section, the Most Frequently Asked Questions
have been placed, together with their answers.
You may notice that some questions have the same answer,
but the symptoms appear differently.
<p>
Some of these answers will reference other material in this FAQ,
or the LPRng man pages.
<sect1>Why do I get malformed from address errors?
<p>
This is the number one question asked by most LPRng users
who try to use LPRng with network printers or other systems
supporting
<ref id="rfc1179" name="RFC1179"> printing.
For details about LPRng and RFC1179, see
<ref id="rfc1179ref" name="RFC1179 and LPRng">.
<p>
The
<tt> malformed from address </tt> error is usually reported when
trying to send a print job from LPRng to other BSD LPR or RFC1179
LPR implementations, or with network connected printers
that have a built in LPR server.
This is due to the following RFC1179 rule:
<quote>
Servers originate a connection from ports in the range 721-731.
</quote>
<p>
WHY?  These are a subset of the 'reserved' ports in UNIX, and normal users
cannot open connections from them.  This provides a small amount
of security from UNIX users on the host 'spoofing' a server.
<p>
IMPLICATION:  in order to do use a reserved port,  the program
must have root privileges.  This means the LPR, LPD, LPQ, etc.,
programs must be installed SUID root.  This can open up a can
of worms with regard to security,  but LPRng has been designed to
take as much paranoid care as possible to avoid problems.
<p>
WHAT TO DO:
<newline>
When installing LPRng,  you will need to install the executables
SUID root.
In the <tt>src/Makefile</tt>,  you can remove the comment from the line
<tscreen>
<verb>
PERMS=SUID_ROOT_PERMS
</verb>
</tscreen>
and then do <tt> make install</tt>.
This will install the executables
SUID, and owned by root.
<sect1>It was working normally, then I get connection refused errors
<p>
This message usually appears when you have been sending a large number
of jobs to a network printer or a remote system.
The reason for this is a combination the above port 721-731 restriction
and the TCP/IP timeouts.
For details, see
<ref id="rfc1179ref" name="RFC1179 and LPRng">,
but here is a quick explanation.
<p>
A TCP/IP connection is usually specified as between
<tt>srchost:srcport, desthost:destport</tt>,
although in practice the order of source (src) and destination
(dest) is not important.
<p>
When a connection is established,  each end of the connection
exchanges the necessary flow control and error control information.
When a connection is terminated,
each end of the connection will not accept another connection from
the same <tt>host:port</tt> that was previously active
for a specified timeout period,
usually 10 minutes.
<p>
Some TCP/IP implementations go further:  they will not allow
<bf>ANY</bf> connection to be <bf>originated</bf>
(via the <tt>bind()</tt> system call or API)
from a port that was active,
or accepted on a port that was active for this timeout period.
<p>
Now let us see what happens when we have a client program,
which must originate a connection on port 721-731, connect
to the server, which waits for a connection on port 515.
We first try to make a connection from host:port
<tt>1.1.1.1:721</tt> to
<tt>1.1.1.2:515</tt>.
The first time that we make the connection (or the first connection)
we succeed.
We can transfer a file, etc., and then close the connection.
When we try to reconnect from
<tt>1.1.1.1:721</tt> to
<tt>1.1.1.2:515</tt>
we get an error such as
"address already in use"
or "connection refused".
<p>
Luckily,  we can use port 722 to originate a connection,
and we can connect from
<tt>1.1.1.1:722</tt> to
<tt>1.1.1.2:515</tt>.
We continue on, until we come to port 731,
and then we need to wait for our timeouts.
<p>
SOLUTION:
<p>
It appears that most RFC1179 implementations do not check for the exact
port
range 721-731,  but only that the connection originates from a
reserved port,
i.e. - in the range 1-1023.
You can extend the range of ports used by LPRng by changing the
<tscreen>
<verb>
originate_port=721 731
</verb>
</tscreen>
value in the defaults (<tt>LPRng/src/common/defaults.c</tt>) file or in the <tt>lpd.conf</tt>
file.  I recommend the following:
<tscreen>
<verb>
originate_port=512 1022
</verb>
</tscreen>
This is, in fact, now the default in LPRng software.
If you get the infamous
<tt>malformed from address</tt>
error message from your spooler, then
you will have to set originate_port=721 731,  and live with
a delayed throughput.
<sect1>Job is not in print queue, but it gets printed!
<p>
In the original BSD LPD implementation,
the LPR program copied users files to a special spool queue directory,
and then caused the LPD server to peek in the directory and print
the files.
<p>
This type of operation required spool directory space,
special SETUID programs,
and a slew of headaches in system security and management.
<p>
The LPR, LPQ, and other user programs in the LPRng suite use TCP/IP
connections and transfer jobs directly to a LPD server running on
a remote host,
or even the local host if appropriate.
Note that this type of operation does not require a LPD server to run
on each local machine.
In fact,  you can have a single host system performing all of your
printing.
This type of operation is very similar to a central mail server versus
individual systems, each having their own mail server and queues.
<p>
However,
some users require or want their jobs to be spooled on the local host system,
and then transferred to the remote printer.
This is usually the case when some type of processing (filtering)
is needed in order to print the job correctly.
There are several methods that can be used to force this.
<p>
Method 1: Explicit Printer Address
<p>
You can force a job to be sent directly to the <tt> pr </tt>
serviced by the LPD server on
<tt>host</tt>
by using the form:
<tscreen>
<verb>
lpr -Ppr@host file
</verb>
</tscreen>
<p>
You can also set the <tt>PRINTER</tt> environment variable to
a similar form, and get the same effect:
<tscreen>
<verb>
PRINTER=pr@host; export PRINTER;
lpr file
</verb>
</tscreen>
<p>
Method 2: User and Server Printcap Entries
<p>
If you want to have the benefits of a printcap file,
i.e. - you can use aliases or abbreviations for the names of printers,
then here is a couple of hints.
First,
the LPRng software scans the <tt>/etc/printcap</tt> file for printcap
entries, combining information for the same printer into a single entry.
Information found later in the printcap file will override earlier
information.
In addition,
you can tag entries as either being used for all utilities or just
for the LPD server.
Here are a couple of examples:
<tscreen>
<verb>
# for all utilities
pr:lp=pr@host
# just for LPD
pr:server
  :lp=/dev/lp
# more information
pr:check_for_nonprintable@
# --- final result for LPR
pr:lp=pr@host:check_for_nonprintable@
# --- final result for LPD
pr:lp=/dev/lp:check_for_nonprintable@
</verb>
</tscreen>
<p>
As you can see,
the <tt>server</tt>
keyword indicates that the printcap entry is only for the printer.
The LPR utility will send the job to the host, while the LPD server
will print it on <tt>/dev/lp</tt>.
<p>
Note that the <tt>lp=...</tt> information overrides the
<tt>:rp:</tt> (remote printer)
and
<tt>:rm:</tt> (remote machine) fields if they are present.
<p>
Method 3: Force sending to server on <tt>localhost</tt>
<p>
The
<tt>force_localhost</tt>
printcap or configuration flag forces non-LPD applications to send all
requests and print jobs to the server running on the local host.
<p>
This method is similar to the previous one,
but has the benefit that it can be configured as a global (i.e. -
applies to all printers) rather than printer specific.
You can put this in the <tt>/etc/lpd.conf</tt> file for general
application,  or have a printcap entry of the following form:
<tscreen>
<verb>
# for all utilities
pr:lp=pr@host:force_localhost
</verb>
</tscreen>
<p>
The LPD server will ignore the
<tt>force_localhost</tt> flag,
and send jobs to the <tt>pr</tt> queue on the <tt>host</tt>
machine.
However, the LPR, LPQ, etc., utilities will send their requests to the
server running on the local host.
<sect1>Job disappears and is never printed, but lpr works
<p>
This is a rather disconcerting problem,
and usually occurs when sending jobs to either a network printer or
a nonconforming
<ref id="rfc1179" name="RFC1179">
print spooler.
For details about LPRng and RFC1179, see
<ref id="rfc1179ref" name="RFC1179 and LPRng">,
but here is a quick explanation.
<p>
An LPD job consists of a control file,  which contains information
about the job,  and one or more data files.  RFC1179 is silent on the
order that jobs are sent;  however some implementations REQUIRE that
the data files be sent first,  followed by the control file.
<p>
SOLUTION:
<p>
Set the <tt>send_data_first</tt> flag in the printcap for the particular
printer,  or in the <tt>lpd.conf</tt> configuration file.  This is:
<tscreen>
<verb>
:send_data_first:  (printcap)
send_data_first    (lpd.conf)
</verb>
</tscreen>
<p>
Note that some printers/servers INSIST on the control file first;
You can clear the flag using <tt>send_job_first@</tt> if you need to.
<sect1>I get messages about bad control file format
<p>
RFC1179 describes a set of fields that MAY appear in the control file.
It is silent if other ones can appear as well.
Unfortunately,  some implementations will reject jobs unless they contain
ONLY fields from a very small set.  In addition,  RFC1179 is silent
about the ORDER the fields can appear.
<p>
LPRng quite happily will accept jobs from poor or nonconforming RFC1179
spooler programs,
and fix them up to be conformant.
<p>
If you are sending jobs to one of a non-conforming spooler,
you can force LPRng to send jobs with only the fields described
in RFC1179 by setting the
the <tt> :bk: </tt> (BacKwards compatible) flag in the
printcap for your printer.
<sect1>What is RFC 1179, the Line Printer Daemon Protocol?
<label id="rfc1179">
<p>
RFC1179 defines a standard method by which print jobs can be transferred
using the TCP/IP protocol between hosts.
The standard was developed by simply detailing the way that
a version of the BSD LPD software did its job.
<p>
From the RFC Introduction:
<quote>
RFC 1179 describes a print server protocol widely used on
the Internet for communicating between line printer daemons (both
clients and servers).  RFC1179 is for informational purposes only,
and does not specify an Internet standard.
</quote>
<p>
Having said this,
the RFC then goes on to describe the protocol used
by a particular implementation of LPD.
The problem was that the RFC did not provide
any way to put extensions to the operations into the system,
and failed to specify such interesting details as the order in which
print jobs and their components could be transferred.
<p>
Comment by Patrick Powell <tt> &lt;papowell@astart.com> </tt>:
<quote>
<p>
Since 1988,
there have been a large number of print spooling systems developed which
claim RFC1179 conformance,
but which are mutually incompatible.
<p>
Rather than live with the limited capabilities of the RFC1179 standard,
LPRng has extended them by adding capabilities to perform remote control
of print spoolers,
encrypted and authenticated data transfers,
and other operations missing from the RFC1179 specification.
However,
great effort was made to be backwards compatible with older and other LPD
based systems.
<p>
LPRng was developed in order to be able to both accept and provide
interactions with these systems.  It does so by allowing various options
to be used to <em>tune</em> how print jobs would be exchanged.
Currently,
LPRng can be configured to send and receive print jobs between a vast number
of the existing spooling systems.
It is flexible enough to act as a gateway between non-compatible systems,
and has provisions to transform jobs from one format to another in a dynamic
manner.
</quote>
<p>
For a detailed explanation
about LPRng and RFC1179, see
<ref id="rfc1179ref" name="RFC1179 and LPRng">.
<sect1>I want to replace lp, lpstat, etc, but my programs need them
<p>
LPRng was designed as a replacement the BSD printing system. As such,
it inherited its command names and options from the latter. As you
might know, System&nbsp;V uses a totally different set of commands,
incompatible with the BSD ones.
<p>
The good news is that the LPRng binaries include an emulation for the
System&nbsp;V commands.
(See
<ref id="lpsimulation" name="lp Simulation">
for details.
Briefly, you create links to the appropriate programs,
and invoke them by the link names.
<em>Actually, these links are installed by default in recent versions.</em>
<p>
<tscreen>
<verb>
ln -s lpr lp
ln -s lpq lpstat
ln -s lprm cancel
</verb>
</tscreen>
<p>
If you make these links, calling <tt>lp</tt>, <tt>lpstat</tt> and
<tt>cancel</tt> will give you a (partial) SVR4 emulation. They have
their own man pages, which you should read if you need the emulation.
<p>
Since it is a <bf>partial</bf> emulation, you shouldn't expect everything
to work. In particular, I would guess that any script which relies on
the output format of one of your system binaries will break.
Again, see
<ref id="lpsimulation" name="lp Simulation">
for more details or additional suggestions.
<sect1>What are the drawbacks to LPRng?
<p>
There are many reasons to run LPRng, and most of them are related to
the extra features it has, compared to vanilla BSD LPR. A short list
is given in section
<ref id="secfeatures" name="What is LPRng?">. (A
more elaborate description can be found in the LPRng package itself.)
<p>
On the other hand, there are also reasons <bf>not</bf> to switch to LPRng:
<itemize>
<item>Switching from a System&nbsp;V system will require some work.
On the other hand,
getting System&nbsp;V printing to work correctly for you may be even more work.
</item>
<item>You don't need any of the enhanced features,
and are not worried about security issues.
On the other hand,
you may not have known about them.</item>
<item>While there are many resources and books devoted to the old BSD
printer daemon, documentation for LPRng is rather limited.
On the other hand, you get lots of diagnostics and error messages when things
go wrong.
</item>
</itemize>
<sect>Client To Server Connection Information
<p>
The LPRng software is a true set of client/server applications.
The LPRng clients,
<tt/lpr, lprm, lpq,/ and <tt/lpc/ connect to a <tt/lpd/ server using a
TCP/IP connection.
This means that you must have TCP/IP networking enabled on your workstation
to use LPRng.
<p>
However,
you do not need to have an external network connection to the Internet.
For most single system users,
the <tt/lpd/ server is running on the same workstation as the client program,
and the clients will simply talk to the <tt/localhost/.
<sect1>Printer Name and Server IP Address
<label id="printerenv">
<label id="PRINTER">
<label id="defaulthost">
<label id="defaultprinter">
<label id="defaultprinterwhenunknown">
<label id="forcelocalhost">
<p>
Options used:
<itemize>
<item> <tt>PRINTER</tt><em>&nbsp;&nbsp;Environment variable </em>
<item> <tt>force_localhost</tt><em>&nbsp;&nbsp;force clients to send requests to localhost </em>
<item> <tt>default_printer_when_unknown</tt>&nbsp;&nbsp; <em>used by LPD when printer name not in printcap </em>
</itemize>
<p>
When an LPRng client such as
<tt/lpr/,
<tt/lpq/,
<tt/lprm/,
or
<tt/lprc/
needs to communicate with a print server,
the only information they normally need is:
<enum>
<item>
The spool queue or <it/remote printer/
to be used in requests to the <tt/lpd/ print server.
This is sometimes referred to as the <it/printer/ or <it/print queue/ name.
<item>
The IP address or hostname of the <it/print server/ or <it/remote server/.
This is sometimes called the <it/remote host/ or simply <it/server/.
<item>
Options that control <em/how/ jobs or commands are transferred to the server host.
These options might include encryption and client side job filtering.
We will discuss these capabilities later.
</enum>
<p>
LPRng has several ways to specify the <it/printer queue/ and <it/server/ information.
<sect2>Command Line -Pprinter@host
<p>
The <tt/-P printer@host/ option specifies both the print queue and
server.
<tscreen>
<verb>
lpr -Plaser@10.0.0.1
lpq -Plp@myserver
</verb>
</tscreen>
<p>
When used as a command line option,
the printcap database will not be consulted for other options or information.
This allows LPRng clients to function without a printcap database,
and without a <tt/lpd/ print server running on their local host.
However,
options set in the <tt>/etc/lpd.conf/</tt> and the compile time defaults
will still be used.
<sect2>Command Line -Pprinter
<p>
This form will cause the LPRng clients to look in the
<tt>/etc/printcap</tt>
for a printcap entry with the name or alias <tt/printer/
and use the information in that printcap entry.
We will discuss the format of the printcap entry in a moment.
Example:
<tscreen>
<verb>
lpr -Plp
</verb>
</tscreen>
<sect2>PRINTER Environment Variable
<p>
If no command line option is specified,
the LPRng clients will check for a <tt/PRINTER/ environment variable value
and will use it as though specified as a
<tt/-P$PRINTER/ command line option.
<p>
If the $PRINTER value has the form
<tt/printer@host/ the print queue will be <tt/printer/ on server <tt/host/.
and not consult the printcap database
If the $PRINTER value has the form <tt/printer/ then the printcap will be searched
for a <tt/printer/ printcap entry.
For example:
<tscreen>
<verb>
export PRINTER=laser@10.0.0.1; lpr
export PRINTER=pr; lpr
</verb>
</tscreen>
<sect2>Default Printer From Printcap
<p>
If you do not specify a printer on the command line or in the <tt/PRINTER/
environment variable,
then LPRng will search the printcap and use the first valid printcap entry
as the printer.
<sect2>Default Printer When No Printcap
<p>
If you do not have a <tt>/etc/printcap</tt> file,
then LPRng will use the
<tt>default_printer</tt>
and
<tt>default_remote_host</tt>
<it/fallback/
values set in the <tt>/etc/lpd.conf</tt> file or by the compile time defaults.
<p>
Using the fallback values is usually not a desirable event and may indicate
that you have a misconfigured host, so the fallback values are usually set
by administrators to <tt/missingprinter@localhost/ to provoke an annoying message for users.
<sect2>LPD Default Printer
<p>
For completeness,
there is even a <tt>default_printer_when_unknown</tt> configuration
entry for use by LPD when it is given a printer name not in its printcap
database.
By default,
it will look up this name in the database and treat the job as though it was
sent to this printer.
<sect1> LPD Server Runnning on Localhost
<p>
Workstations for personal use or in extremely simple configurations
will always run an <tt/lpd/ server on the <it/localhost/.
This is the most common situation for the majority of new
users,
and the
default LPRng installation sets the default value of the
<tt/force_localhost/ configuration parameter to <bf/TRUE/ or to 1.
The
<tt/lpr/
<tt/lpq/
<tt/lprm/
and
<tt/lpc/ will connect to <tt/localhost/ (usually IP address 127.0.0.1)
unless explicitly overridden by the command line <tt/-Pprinter@host/ argument.
<p>
Larger sites or organizations which want to use a central print server
to handle multiple printers or printer sharing
may want the clients to connect directly to the server.
In this case the system administrator should set
<tt/force_localhost@/ in the
<tt>/etc/lpd.conf</tt> or modify the compile time default.
See <ref id="lp" name="Simple Client Printcap Entry">
for ways to change this.
<sect>Using the Printcap Database
<label id="printcapref">
<p>
As described in the
<ref id="overview" name="Print Spooling Overview">,
the heart of the LPRng system is information in the <tt>/etc/printcap</tt>
file.
The printcap information specifies:
<enum>
<item>
The print queues available to users.
<item>
How client programs communicate with the <tt/lpc/ print server.
<item>
The configuration,
location,
and other information for each print queue on the print server.
<item>
How the <tt/lpd/ server processes jobs in each print queue.
</enum>
<p>
In order to explain a complex subject,
we will start with a set of simple printer configurations,
and explain the purpose and effect of each entry in the printcap.
<p>
For details about individual printcap
options, see the <tt>printcap(5)</tt>
man page from the LPRng distribution,
or use the <ref id="index" name="Index To All The Configuration and Printcap Options"> to find a specific
printcap option and its effects.
<sect1>Simple Client Printcap Entry
<label id="lp">
<label id="rm">
<label id="rp">
<p>
Options used:
<itemize>
<item> <tt>rm=</tt><em>remote host (machine)</em>
<item> <tt>rp=</tt><em>remote printer</em>
<item> <tt>lp=</tt><em>destination printer information</em>
<item> <tt>client</tt>&nbsp;&nbsp;client only printcap FLAG
</itemize>
<p>
I'll use this simple example to explain the basics of the LPRng
printcap format
and introduce some of the LPRng network configuration options.
Here is a simple printcap file used to provide client programs
(<tt/lpr, lprm,/ etc)
with <it/remote printer/ and <it/server/ information.
<tscreen>
<verb>
# printer lp1
lp1|printer1
  :rm=localhost
# printer lp2 with continuation
lp2:\
  :lp=pr@10.0.0.1:client
# printcap lp3, to printer pr, with overrides
lp3:rp=pr:rm=hpprinter.astart.com
  :force_localhost@
# Simplest possible printcap entry - defaults for everything
lp4
</verb>
</tscreen>
<enum>
<item>
Lines starting with a <tt>#</tt> sign are comments, and all
leading and trailing <em>whitespace</em>,
i.e. - spaces, tabs, etc, are ignored.
Empty lines are ignored as well.
<item>
A printcap entry starts with the printcap entry <bf/name/,
followed by one or more <em/aliases/,
followed by one or more options.
In the above example we have three printcap entries: <tt/lp1/ with an alias
<tt/printer1/
and <tt/lp2/, <tt/lp3/, and <tt/lp4/ with no aliases.
<item>
Aliases start with the <tt/|/ character and options with the <tt/:/ character;
tabs and spaces before and after the <tt/|/ or <tt/:/ characters
and at the start and end of lines are ignored.
You can use backslash (tt/\/) at the end of a line to create a multi-line
value for an option.
The backslash will cause the next line to be appended to the
current line;
watch out for comments and ends of printcap entries if you use this facility.
As you can see from the example,
there is no <tt/Name/ printcap entry - this is part of the <tt/cm/
option on the previous line.
<item>
Options take the form of a
keyword/value pair, i.e.-
<verb>
:option=value
:option#value   (legacy, not advised for new systems)
:option
:option@
</verb>
<item>
Option names are case insensitive, but option values are not.
While <tt>Ts</tt> and <tt>ts</tt> are the same option name,
<tt/ts=Testing/ and <tt/ts=testing/ have their case preserved.
A string or integer value is specified by <tt/option=value/
or <tt/option#value/.
<item>
The use of the legacy <tt/option#value/
form is <bf/NOT/ recommended as some preprocessors
and database systems will treat <bf/#/ as the start of a comment
and delete the remainder of the line.
This has caused great consternation for sysadmins who wonder why their
NIS distributed printcap entries have been mysteriously truncated.
<item>
If you want to set a string option to <it/empty/ value,
use <tt/option=/. The <tt/option/ will set it to <tt/1/.
If an option value contains a colon, then use the C (or Perl or Tck/Tk)
string escape <tt>\072</tt> to represent the value.
<item>
Boolean options are set TRUE (1) if no value follows the keyword and FALSE (0) by
appending a <tt>@</tt>.
For example
<tt>sh</tt>
will set
<tt>sh</tt> to TRUE and
<tt>sh@</tt> to FALSE.
</enum>
<p>
There may be multiple options on the same line, separated
by colons.
However, this does make the file less readable. The next tip was
supplied by James H. Young &lt;<tt>jhy@gsu.edu</tt>&gt;:
<p>
<quote>
My personal preference for readability is to always put each
option on its own line.  Putting each option on its own line is
worth the trouble even though it detracts from the usability
of certain grepping techniques when trying to maintain these
types of files.
</quote>
<p>
Now let's examine the first printcap entry in detail.
It is reproduced here for convenience:
<tscreen>
<verb>
# printer lp1
lp1|printer1
  :rm=localhost
</verb>
</tscreen>
<enum>
<item>
We start with a comment, followed by the printcap entry name and and alias.
Aliases are useful when you want to refer to a single printer or print queue
by different names.
This can be useful in advanced printcap and print queue setups.
By default,
the remote printer name is the printcap entry name.
<item>
The <tt/rm/ (remote machine or host) option specifies the name or IP address
of the <tt/lpd/ host running <tt/lpd/.
In this example the remote host is <tt/localhost/
or the machine that the client is running on
and we assume that the <tt/lpd/ server is running on the localhost.
Thus,
we would communicate with printer
<tt/lp1@localhost/.
</enum>
<p>
Let's look at the next printcap entry:
<tscreen>
<verb>
# printer lp2 with continuation
lp2:\
  :lp=pr@10.0.0.1:client
</verb>
</tscreen>
<enum>
<item>
The <tt/lp2/ printcap entry illustrates the use (and abuse)
of the <tt/\/ continuation.
If you think about this,
we have really defined a printcap entry of the form:
<tscreen>
<verb>
lp2: :lp=pr@10.0.0.1:client
</verb>
</tscreen>
<p>
Luckily, LPRng ignores empty options like <tt/:&nbsp;:/.
While it is strongly recommended that <tt/\/
be avoided it may be necessary for compatibility with other system utilities.
<item>
The <tt/lp=pr@10.0.0.1/ option is an alternate way to
specify a remote queue and server.
If the <tt/force_localhost/ default is being used,
then the LPRng clients will ignore the <tt/10.0.0.1/ address
and still connect to <tt/pr@localhost/.
There is further discussion about this in the next section.
<item>
The <tt/client/ option explicitly labels client only printcap information.
The <tt/lpd/ server will ignore any printcap with the <tt/client/ option.
When constructing complex printcaps,
this option is used to keep ensure that you have consistent printcap information.
</enum>
The following printcap entry shows how to override the
<tt/force_localhost/ default,
and force the LPRng clients to connect directly to a remote server:
<tscreen>
<verb>
lp3:rp=pr:rm=hpprinter.astart.com
  :force_localhost@
</verb>
</tscreen>
<enum>
<item>
The <tt/rp=/  (remote printer)
remote print queue name to used when sending commands to the <tt/lpd/ print server.
<item>
The <tt/force_localhost@/ option is an example of a <it/flag/ option.
The <tt/@/ sets the option value to 0 (false).
We set <tt/force_localhost/ to false,
which now allows the LPRng clients to connect directly to the
specified remote printer.
In this example,
the <tt/hpprinter.astart.com/ could be a HP LaserJet Printer with a
JetDirect interface,
which supports the RFC1179 protocol.
<item>
One disadvantages of sending a job directly to a printer using the above
method is that <tt/lpr/ program will not
terminate or exit until all of the files have been transferred to the printer,
and this may take a long time
as the printer processes the files as they are received.
</enum>
<p>
Now let's look at the last printcap entry:
<tscreen>
<verb>
# Simplest possible printcap entry - defaults for everything
lp4
</verb>
</tscreen>
<p>
The last example is the simplest possible printcap entry.
This will cause LPRng clients to use the default values for everything.
The printer will be <tt/lp4/,
i.e. - the name of the printcap,
and the server will be <tt/localhost/ if <tt/force_localhost/ is set,
or the value of the <tt/default_remote_host/ configuration option
if it is not.
<sect1>Simple Server Printcap Example
<label id="cm">
<label id="mx">
<label id="secprintcap">
<p>
Options used:
<itemize>
<item> <tt>cm=</tt><em>comment for status</em>
<item> <tt>if=</tt><em>default job file filter </em>
<item> <tt>lf=</tt><em>log file </em>
<item> <tt>mx=</tt><em>maximum job size</em>
<item> <tt>lp=</tt><em>output device</em>
<item> <tt>sd=</tt><em>spool directory file </em>
<item> <tt>sh</tt><em>&nbsp;&nbsp;suppress headers (banners) </em>
<item> <tt>sf</tt><em>&nbsp;&nbsp;suppress form feeds between files</em>
</itemize>
<p>
The previous section discussed printcap entries for use by the client programs.
Now we will discuss printcap entries for use by the <tt/lpd/ server.
In simple configurations or when we have the <tt/force_localhost/
option enabled
we can use the same printcap for both LPRng clients and the <tt/lpd/
server.
<p>
<tscreen>
<verb>
# Local ASCII printer
lp1|printer
  :server
  :cm=Dumb printer
  :lp=/dev/lp1
  :sd=/var/spool/lpd/lp1
  :lf=log:af=acct
  :if=/usr/local/sbin/lpf
  :mx=0:sh:sf
</verb>
</tscreen>
<p>
<enum>
<item>
The printcap entry name is <tt/lp1/.
This information will be displayed when requesting status information using
the <tt/lpq/ program.
<item>
The <tt/printer/ alias.
This allows a single spool queue to have multiple names.
</item>
<item>
The <tt/server/ corresponds to the <tt/client/ flag
and indicates this printcap entry is for the <tt/lpd/
server only.
</item>
<item>The <tt>cm</tt> field supplies a information field
for <tt/lpq/ (printer status) output.
</item>
<item> The <tt>lp</tt> value
specifies the destination file, device or remote spool queue to which data is sent.
In this example it is the device <tt>/dev/lp1</tt>.
By default,
IO devices are opened for <em/write-only/ operation.
<item>The <tt>sd</tt> specifies the <it/spool directory/ where print job files
are stored until they are printed.
</item>
<item> The <tt/lf/ and <tt/af/ options specify the names
for the log and accounting files, respectively.
These have the default values <tt/log/ and <tt/acct/ respectively,
and if not absolute pathnames are relative to the spool queue directory.
A log file is highly recommended.
If these files don't exist, they will not be created,
and no logging or accounting will be done. You will
need to create them manually (e.g., by using <tt>touch</tt>)
or by using the
<tt><ref id="checkpc" name="checkpc"></tt>
program.
<item>
The <tt/if/ option specifies a filter program to be used
for jobs with the <tt/f/ or default job format format.
Filters and print formats are discussed in section
<ref id="secfilter" name="Filters">.
The <tt/lpf/ filter translates <tt/LF/ (line feed)
to <tt>CR/LF</tt> (carriage return/line feed) sequences,
eliminating <em>staircase</em> output.
</item>
<item><tt>mx</tt> indicates the maximum file size for a print job.
Specifying 0 means that there is no limit.
</item>
<item>The <tt>sh</tt> <it/suppress headers/ flag will suppress
printing banner pages.
<item>The <tt>sf</tt> <it/suppress form feeds/ flag will suppress
form feeds between the files of a multi-file print job.
</enum>
<sect1>The Printcap Parsing Rules
<label id="printcapparse">
<label id="server">
<label id="client">
<label id="tc">
<label id="oh">
<p>
Options used:
<itemize>
<item> <tt>client</tt><em>&nbsp;&nbsp; printcap entry valid only for client programs </em>
<item> <tt>oh</tt><em>&nbsp;&nbsp; printcap entry valid only on these hosts </em>
<item> <tt>server</tt><em>&nbsp;&nbsp; printcap entry valid only for lpd server </em>
<item> <tt>tc</tt><em>&nbsp;&nbsp; add named printcap entry contents </em>
</itemize>
<p>

In this section,
we will discuss the remaining tricky parts of the LPRng printcap
database:
combined client and server printcaps,
host specific printcap entries,
and the
<tt/tc/ <it/include/ facility.
<p>
The following is a complete description of how a printcap file is processed:
<enum>
<item>
When processing a printcap file,
the LPRng software reads and parses each entry individually.
Leading whitespace is removed.
Lines starting with <tt/#/ and blank lines are ignored.
<item>
Lines ending with <tt/\/ will have the <tt/\/ discarded,
and all lines of a printcap entry are joined by removing the line separators (<tt/\n/)
and replacing them with a space.
<item>
The printcap entry is parsed,
and the printcap name, aliases, and options are determined.
Colons <tt/:/ act as option separators,
and leading and trailing whitespaces are removed.
<item>
Options are sorted and expect for the 
<tt/tc=.../ option only the last option setting is retained.
<item>
Client programs will discard a printcap entry with a <tt/server/ option
and
server programs will discard a printcap entry with a <tt/client/ options.
<item>
The <tt/oh/ (<bf/o/n this <bf/h/ost) option specifies a list of
IP addresses and mask pairs or glob strings which are used to determine
if this printcap entry is valid for this host
(see discussion below).
<item>
After the above processing,
if there is an existing termcap entry with the same name,
the two sets of options are combined,
with the last option setting retained except for the <tt/tc/ entries
which are combined.
<item>
When a printcap entry is actually used,
the printcap entries listed by the <tt/tc/ include option
are extracted and combined in order.
(This allows include entries to appear after the referring printcap entry.)
Then printcap options will be combined with the included ones.
This has the effect that the options specified in the printcap entry
will override the ones from the <tt/tc/ included entries.
<item>
Finally,
each string printcap option with a <it/%X/ value
has <it/%X/ replaced by the following values.
Unspecified values will not be modified.
<tscreen>
<verb>
%P           printcap name
%h           short host name  (host)
%H           fully qualified host name  (host.dns.whatever)
%R           remote printer (rp value)
%M           remote host (rm value)
%D           date in YYYY-MM-DD format
</verb>
</tscreen>
<item>
When parsing multiple printcap files,
these are processed in order,
and all of their printcap entries are combined according to the
above procedures.
The <tt/tc/ resolution and <it/%X/ expansion is done after all the files
have been processed.
</enum>
<p>
The following examples show how to use the above rules
to your advantage.
You can combine both client and server printcap information in
a single file
as well as dividing a printcap entry into several parts.
Here is an example:
<tscreen>
<verb>
# seen by both client and server
lp1:lp=lp@pr1:mx=100
lp1:sd=/usr/local/spool/lp1:mx=0
# seen only by client
lp2:lp=lp@pr2:client
# seen only by server
lp2:lp=/dev/lp:server
</verb>
</tscreen>
<enum>
<item>
Printcap entries with the same name are combined.
The first printcap entry, <tt/lp1/,
the information is seen by both client and server.
The next printcap entry,  with the same name <tt/lp1/,
will be combined with the second one.
The order of options is important - the entries are scanned in order
and an option will have the last value set.
Thus,
after having read both the <tt/lp1/ printcap entries,
both client and server will have:
<tscreen>
<verb>
lp1:lp=lp@pr1
  :mx=0
  :sd=/usr/local/spool/lp1P
</verb>
</tscreen>
<item>
The <tt/lp2/ has a client and server version.
This is recommended when complex printcaps on multiple hosts and servers
are used.
Thus, the LPRng clients will see:
<tscreen>
<verb>
lp1
  :lp=lp@pr1
  :mx=0
  :sd=/usr/local/spool/lp1P
lp2
  :client
  :lp=lp@pr2
</verb>
</tscreen>
and the server will see:
<tscreen>
<verb>
lp1
  :lp=lp@pr1
  :mx=0
  :sd=/usr/local/spool/lp1P
lp2
  :lp=/dev/lp
  :server
</verb>
</tscreen>
</enum>
<p>
If you have multiple printers of the same type whose configuration is almost
identical,
then you can define a set of <it/tc/ only printcap entries containing common
information
and use the <tt/tc/ include facility.
<p>
By convention,
all printer names start with an alphanumeric character and contain only
alphanumeric values, underscore (<tt/_/) or hyphen (<tt/-/).
A printcap entry starting with
period (<tt/./),
question mark (<tt/?/),
or
exclamation mark (<tt/!/),
is processed by LPRng
but can only be used with the <tt/tc/ include facility.
For example:
<tscreen>
<verb>
.hp:
  :sd=/usr/local/spool/%P
  :mx=0:sf:sh
hp1:tc=.hp,.filter
  :lp=lp@10.0.0.1
hp2:tc=.hp,.filter
  :lp=lp@10.0.0.2
.filter
  :if=/usr/local/bin/ifhp
  :lpd_bounce
</verb>
</tscreen>
<enum>
<item>
The <tt/.hp/ and <tt/.filter/ printcap entities will not be used as
real printcaps by LPRng,
but can be referenced by the <tt/tc/ printcap include facility.
After <tt/tc/ include processing is completed,
the printcap information would resemble:
<tscreen>
<verb>
hp1
  :lp=lp@10.0.0.1
  :if=/usr/local/bin/ifhp
  :lpd_bounce
  :mx=0
  :sd=/usr/local/spool/%P
  :sf
  :sh
hp2
  :lp=lp@10.0.0.2
  :if=/usr/local/bin/ifhp
  :lpd_bounce
  :mx=0
  :sd=/usr/local/spool/%P
  :sf
  :sh
</verb>
</tscreen>
<item>
The <it/%X/ processing will replace <tt/%P/ with the
printcap name,
so we would have:
<tscreen>
<verb>
hp1
  :lp=lp@10.0.0.1
  :mx=0
  :sd=/usr/local/spool/hp1
  :sf
  :sh
hp2
  :lp=lp@10.0.0.2
  :mx=0
  :sd=/usr/local/spool/hp2
  :sf
  :sh
</verb>
</tscreen>
</enum>
<p>
When administering a large number of printers over a large area,
it is sometimes desirable to have a <it/default/ printer for
each host.
This default printer may be different for each host,
and can be selected by using the <tt/oh/ entry.
The <tt/oh/ value is a list of the following entries
<tscreen>
<verb>
IP/n     - address + mask length    10.0.0.0/8
IP/IP    - address + mask           10.0.0.0/255.0.0.0
vvv      - glob for hostname        pc*.org.com    
</verb>
</tscreen>
<p>
The LPRng software will determine the hostnames and IP addresses assigned to the
host and then check to see if there is a match in the listed hostnames
or IP addresses.
If there is a match,  the printcap entry will be used.
If not,  then the entry will be discarded.
For example:
<tscreen>
<verb>
lp:oh=*.admin.org.com,10.0.0.5,10.2.0.0/16:lp=pr1@server1
lp:oh=*.eng.org.com:lp=hp@server2
</verb>
</tscreen>
<enum>
<item>
In the above example,
if our host name is
<tt/booster.admin.org.com/,
then we would use <tt/lp=pr1@server1/,
as the <tt/*.admin.org.com/ glob pattern would match our host name.
<item>
if our host name is
<tt/booster.dev.org.com/ and our IP address is 10.2.0.1,
then we would use <tt/lp=pr1@server1/,
as the <tt>10.2.0.0/16</tt> ip address would be in the specified address range.
</enum>
<sect1>Displaying Printcap Information
<p>
If you are generating complex printcap entries,
you might need to find out exactly what the LPRng servers or clients
will actually see.
The LPRng software has several diagnostic tools to help you.
The most simple to use is the
<tt/lpc/ program.
<p>
The <tt/lpc client all/ and 
<tt/lpc server all/ commands will display the printcap information that the
LPRng clients and <tt/lpc/ server would see when executing on the host.
For example:
<tscreen>
<verb>
#> lpc client all
lp1
  :lp=lp@pr1
  :mx=0
  :sd=/usr/local/spool/lp1P
lp2
  :client
  :lp=/dev/lp
</verb>
</tscreen>
<sect1>Remote Printer Using RFC1179
<p>
Options used:
<itemize>
<item> <tt>lp=</tt><em>destination</em>
<item> <tt>rm=</tt><em>remote host (machine)</em>
<item> <tt>rp=</tt><em>remote printer (machine)</em>
</itemize>
<p>
You can have the <tt/lpd/ server forward jobs to another server
or print which supports the RFC1179 protocol by using the
following printcap:
<tscreen>
<verb>
# Simplest
remote|Remote Printer
   :lp=raw@server
# historical
remote:
  rp=raw:rm=server
# Sometimes you have to connect to a non-standard port
special:lp=lp@server%2000
</verb>
</tscreen>
<enum>
<item>
If the <tt/lp/ printer entry is present, it will override the
<tt/rm/ and <tt/rp/ printer entries.
<item>
The <tt/lp=pr@host/ format specifies that the output device is actually
a remote spool queue,
and jobs should be transferred using RFC1179 protocol.
<item>
By default,
LPRng will attempt to
<bf/sanitize/ all jobs that it originates or forwards.
This sanitization will result in an RFC1179 compliant <tt/control file/,
and will not modify any of the job information.
</enum>
<sect1>Remote Printer Using Socket API
<p>
If the spool queue destination is a remote printer supporting the
Socket API,
then you can have LPRng open a connection directly to the printer.
These include the older Apple printers with TCP/IP support and the
HP JetDirect supported printers.
<tscreen>
<verb>
# Simplest
remote
   :lp=10.24.2.3%9100
   :sh:sf
</verb>
</tscreen>
<enum>
<item>
The <tt/lp=server%port/ or <tt/lp=IPaddr%port/ format
specifies that <tt/lpd/ should open a TCP/IP connection to the remote
host and simply transfer verbatum the files to be printed.
<item>
The <tt/sh/ and <tt/sf/ will prevent <tt/lpd/ from trying to generate
banner pages or put form feeds between jobs.
</enum>
<p>
While this is the simplest printcap,
it is also the most dangerous as there is nothing to prevent
a malformed job from being sent to the printer.
The next printcap example is much more robust:
<tscreen>
<verb>
# Simplest
remote
   :lp=10.24.2.3%9100
   :of=/usr/local/lib/ifhp
   :if=/usr/local/lib/ifhp
   :sh:sf
</verb>
</tscreen>
<enum>
<item>
This version will use the <tt/ifhp/ filter to precondition the printer
and to process jobs.
See <ref id="ifhp" name="IFHP Filter"> for details.
The <tt/ifhp/ filter will perform the appropriate printer resets,
translate job information,
and ensure correct printer operation in the presence of errors.
It will also produce voluminous error messages and status information.
</enum>
<sect1>Parallel Printer
<p>
The parallel printer printcap is very simple.
<tscreen>
<verb>
# parallel printer
lp:
   :lp=/dev/lpr
   :sh:sf
</verb>
</tscreen>
<enum>
<item>
The <tt>lp=/dev/lpr</tt>
specifies that <tt/lpd/ should open the device for APPEND and simply transfer
job files to it.
<item>
The <tt/sh/ and <tt/sf/ will prevent <tt/lpd/ from trying to generate
banner pages or put form feeds between jobs.
</enum>
<p>
If you discover that UNIX print jobs result in a <it/staircase/
appearance,
then you need to force your printer to do <tt/LF/ (linefeed) to <tt>CR/LF</tt>
(carriage return/line feed) translation,
or do the translation yourself.
<tscreen>
<verb>
# Simple parallel printer
lp:
   :lp=/dev/lpr
   :if=/usr/local/bin/lpf
   :sh:sf
</verb>
</tscreen>
<p>
By using the <tt/if=...lpf/ filter,
the job will be passed through the <tt/lpf/ filter,
which will do the <tt/LF/ to <tt>CR/LF</tt> translation.
<p>
If you have a more complex printer that handles PostScript, PCL, and PJL,
then you will need to use the more powerful
<tt/ifhp/ filter:
<tscreen>
<verb>
# Simple parallel printer
lp:
   :lp=/dev/lpr
   :ifhp=model=hp4,status@
   :of=/usr/local/bin/ifhp
   :if=/usr/local/bin/ifhp
   :sh:sf
</verb>
</tscreen>
<p>
See <ref id="ifhp" name="IFHP Filter"> for details.
This entry will specify that the printer is an HP4,
and that no status information is available.
This is usually the case with a parallel port.
<sect1>A serial printer queue
<label id="br">
<label id="stty">
<p>
Options used:
<itemize>
<item> <tt>rw</tt><em>&nbsp;&nbsp;device opened RW flag</em>
<item> <tt>br#</tt><em>serial port bit rate</em>
<item> <tt>stty=</tt><em>stty options for serial port configuration</em>
</itemize>
<p>
The following is a typical printcap for a serial printer:
<tscreen>
<verb>
# Local Serial ASCII printer
lp2
  :lp=/dev/ttya
  :rw
  :cm=Serial printer
  :sd=/var/spool/lpd/lp2
  :stty=9600 -echo -crmod -raw -oddp -evenp pass8 cbreak ixon
  :if=/usr/local/sbin/lpf
  :mx=0:sh
</verb>
</tscreen>
<p>
Let's examine the new options:
<enum>
<item>
A serial port is usually <em/bidirectional/,
and printers will report errors back to the host computer.
The <tt/rw/ flag will cause the printer port to be opened 
<tt/read-write/,
and the <tt/lpd/ server will report status information.
<item>
The <tt>sy</tt> option specifies the <tt>stty(1)</tt>
flags and line speed needed to configure the serial line
(See
<ref id="secserial" name="Serial Printers">
for details).
<item>
The legacy <tt>br</tt> (bit rate) option
can be used to specify the line speed as well.
</enum>
<sect1>Single Printcap File for Large Installation
<label id="secoh">
<p>
One of the major problems faced by administrators of large sites is how
to distribute printcap information.
They would like to have a single printcap file either distributed by
a file server (NFS) or by some other method such as <tt/rdist/.
By using the
<tt>server</tt>
and
<tt>oh</tt>
tags,
information for the specific sites can be separated out.
For example:
<tscreen>
<verb>
#/etc/printcap file
pr1:lp=pr1@serverhost1:oh=*.eng.site.com,130.191.12.0/24
pr2:lp=pr1@serverhost1:oh=*.eng.site.com,130.191.12.0/24
pr1:lp=pr2@serverhost2:oh=*.admin.site.com
pr2:lp=pr2@serverhost2:oh=*.admin.site.com
pr1:server:oh=serverhost1.eng.com:lp=/dev/lp:tc=.common
pr2:server:oh=serverhost2.admin.com:lp=/dev/lp:tc=.common
.common:sd=/usr/local/lpd/%P
</verb>
</tscreen>
<p>
The above example has some interesting effects.
The <tt>pattern</tt> is used as a <em>glob</em> pattern
and is applied to the fully qualified domain name (FQDN) of the
host reading the printcap file.
For example,
<tt>*.eng.site.com</tt> would match host
<tt>h1.eng.site.com</tt>
but would not match
<tt>h1.admin.site.com</tt>.
Thus, the effects of the first couple of entries would be to
specify that the
<tt>pr1</tt> and <tt>pr2</tt> printers on the
<tt>eng</tt> hosts would be <tt>pr1@serverhost1</tt>,
and on the
<tt>admin</tt> hosts would be <tt>pr2@serverhost2</tt>,
<p>
Also,
the lpd daemons on
<tt>serverhost1</tt>
and
<tt>serverhost2</tt>
would extract the additional
information for
<tt>pr1</tt>
and
<tt>pr2</tt> respectively,
overriding the common <tt/lp/ entries.
<sect1>Bounce queues
<label id="bq">
<label id="lpdbounce">
<label id="bqformat">
<label id="bouncequeues">
<p>
Options used:
<itemize>
<item> <tt>lpd_bounce</tt>&nbsp;&nbsp;<em>lpd filters and then forwards</em>
<item> <tt>bq=</tt><em>destination for filtered job</em>
<item> <tt>bq_format=</tt><em>format of filtered job</em>
</itemize>
<p>
When the destination of a spool queue is another spool queue
the job is simply forwarded without any modifications.
However,
sometimes it is essential that the job be modified before
forwarding,
as when the remote spool queue is actually a printer,
and
jobs need to be converted to the format acceptable by
the remote printer or banner pages added.
<p>
The <tt/lpd_bounce/ flag marks a spool queue as a bounce queue.
<tt/Lpd/ will perform all of the usually job processing steps,
such as banner generation,
filtering files,
etc,
but
saves the output to a file.
This file is then sent to the destination print queue for further
processing.
<p>
<tscreen>
<verb>
# Simple example of a bounce queue
bounce:lp=bounce@bouncehost
bounce:server
    :lp=lp@remote
    :lpd_bounce
    # LEGACY
    #bq=lp@remote
    :sd=/usr/spool/lpd/%P
    :if=/usr/local/bin/lpf
    :vf=/usr/local/bin/lpf
    :bq_format=l
    # uncomment ab if you want banner
    #ab
</verb>
</tscreen>
<p>
Some comments:
<p>
<enum>
<item>The
<tt/lpd_bounce/
option marks the job as a bounce queue,
and the <tt/lpd/ server will process the job through the appropriate
filter programs.
<item>The legacy <tt/bq=host/
has the same effect as
<tt/lpd_bounce/.
This option is retained for compatibility with previous versions of LPRng.
It is recommended that this option not be used.
<item>The printcap has filter specifications for different job formats.
These are the programs that will be used by LPRng to process the job.
<item>The
<tt>bq_format</tt>
specifies the job format for the output file sent to the remote spool queue.
If not specified, it defaults to
<tt>l</tt> (literal or binary).
<item>
The <tt>ab</tt>
(always print a banner) flag will force a banner to be
added to the job.
The banner generation is done as discussed in
<ref id="bannerprinting" name="Banner Printing">.
</item>
</enum>
<sect1>Changing Job Formats
<label id="translateformat">
<p>
Options used:
<itemize>
<item> <tt>translate_format=</tt><em>format of filtered job</em>
</itemize>
<p>
A rarely encountered problem is when a job is printed with
one format but for compatibility needs to be processed with another.
The simple
<tt>translate_format=vlxf</tt>
option will rename format
<tt>x</tt>
files to
<tt>f</tt> format.
<p>
This can be used to resolve problems with PC based software,
which spools jobs using the <tt/v/ format.
Unfortunately,
many RCF1179 print spoolers do not understand the
<tt/v/ format and mishandle the job.
A simple forwarding queue with the following entries will rename
<tt/v/ format to <tt/l/ (binary) format.
<tscreen>
<verb>
lp
  :sd=/usr/spool/lpd/%P
  :translate_format=vl
  :lp=lp@printerserver
</verb>
</tscreen>
<sect1>LPR Filters Files
<label id="lprbounce">
<p>
Options used:
<itemize>
<item> <tt>lpr_bounce</tt><em>&nbsp;&nbsp;lpr does filtering</em>
</itemize>
<p>
Some users would like the advantages of
the filtering and processing capabilities of a lpd daemon
without running a lpd daemon on their system.
By having the <tt>lpr</tt> program
process the job by passing it through the various filters
and then send the output of the filters as the print job you can
get the desired effect.
<tscreen>
<verb>
# Simple example of an lpr_bounce entry
bounce
  :lpr_bounce
  :lp=lp@remote
  :if=/usr/local/bin/lpf
</verb>
</tscreen>
<p>
The
<tt>lpr_bounce</tt>
flag, if present in the printcap entry,
will force <tt> lpr </tt> to process the job using the
specified filters and send the outputs of the filters to the remote printer
for further processing.
<sect1>Dynamic Routing
<label id="destinations">
<label id="router">
<label id="routing">
<p>
Options used:
<itemize>
<item> <tt>destinations=</tt><em>destinations for jobs</em>
<item> <tt>router=</tt><em>router program</em>
</itemize>
<p>
LPRng has the ability to route a job to one or
more destinations in a dynamic manner.
This is not the same as
<it/load balancing/,
as the destinations are hard coded and not able to be changed.
This is accomplished by having
a <tt>router</tt> filter generate a set of destinations.
Here is a sample printcap entry:
<tscreen>
<verb>
t2|Test Printer 2
    :sd=/var/spool/LPD/t2
    :lf=log
    :destinations=t1@server1,t1@server2,t1@localhost
    :router=/usr/local/LPD/router
</verb>
</tscreen>
<p>
When a job arrives at the <tt/lpd/ server,
the 'router' filter
is invoked with the standard filter options which include
the user, host, and other information obtained from the control file.
STDIN is connected to a temporary copy of the control file,
and the CONTROL environment variable is set to the value of the
actual control file itself.
<p>
The routing filter exit status is used as follows:
<itemize>
<item>
0  (JSUCC) - normal processing
<item>
37 (JHOLD) - job is held
<item>
any other value - job is deleted from queue
</itemize>
<p>
The router filter writes to STDOUT a file specifying the destinations
for the job.
The destinations entries in this file file have the following format.
Entry order is not important,
but each destination must end with the 'end' tag.
<tscreen>
<verb>
dest (destination queue)
copies (number of copies to be made)
priority (priority letter)
X(controlfile modifications)
end
</verb>
</tscreen>
<p>
Example of router output:
<tscreen>
<verb>
dest t1@localhost
copies 2
CA
priority B
end
dest t2@localhost
CZ
priority Z
end
</verb>
</tscreen>
<p>
In this example,
two copies of the job will be sent to the t1 and t2 spool queue servers.
The Class (C letter value) and job priority information will be rewritten
with the indicated values.
<p>
If routing information
is specified by the router filter the job will be sent to the default
destination.
<p>
LPQ will display job information in a slightly different format
for multiple destination jobs.  For example:
<verb>
Printer: t2@astart2 'Test Printer 2' (routed/bounce queue to 't1@astart2.astart.com')
  Queue: 1 printable jobs in queue
 Rank  Owner/ID        Class Job Files                           Size Time
active  papowell@astart2+707 A 707  /tmp/hi                         3 10:04:49
 - actv papowell@astart2+707.1 A 707 ->t1@localhost <cpy 1/2>       3 10:04:49
 -      papowell@astart2+707.2 A 707 ->t2@localhost                 3 10:04:49
</verb>
<p>
The routing information is displayed below the main job information.
Each destination will have its transfer status displayed as it is
transferred.  By convention,  the job identifier of the routed jobs
will have a suffix of the form .N added;  copies will have CN added
as well.  For example, papowell@astart2+707.1C2 will be the job
sent to the first destination, copy two.
<p>
Routed jobs can be held, removed, etc., just as normal jobs.  In addition,
the individual destination jobs can be manipulated as well.  The LPC
functionality has been extended to recognize destination jobids as well
as the main job id for control and/or selection operations.
<p>
The optional
<tt>destinations</tt> entry specifies the possible set of
destinations that the job can be sent to,
and is for informational purposes only.
In order for LPQ/LPRM to find the job once it has passed through LPD,
LPQ/LPRM uses the list of printers in the
<tt>destinations</tt>,
and loop over all the names in the list looking for the "job" that you are interested in.
If there is no
<tt>destinations</tt>
information, the
<tt>bq</tt> information will be used.
<p>
Lars Anderson &lt;<tt>lsa@business.auc.dk</tt>&gt; supplied this example
(slightly edited):
<p>
This script will attempt to distribute print jobs evenly on
2 printers hpl5a and hpl5b when sending to hpl5bounce.
<p>
<tscreen>
<verb>
hpl5bounce|for PLP/LPRng software - network based HP JetDirect card:
        :lpd_bounce
        #default
        :rp=hpl5b
        :destinations=hp5a,hp5b
        :router=/usr/local/admscripts/bouncer.pl
hpl5a|for PLP/LPRng software - network based HP JetDirect card:
        :lp=hpl5a%9100
        :tc=.hplcommon
hpl5b|for PLP/LPRng software - network based HP JetDirect card:
        :lp=hpl5b%9100
        :tc=.hplcommon
# Common settings
.hplcommon:
        :sd=/var/spool/lpd/%P
        :rw:sh:ps=status
        :fx=flp
        :if=/usr/local/lib/filters/ifhp -Tbanner=on
        :of=/usr/local/lib/filters/ofhp -Tbanner=on
</verb>
</tscreen>
<p>
The perl script <tt>bouncer.pl</tt> looks like this:
<p>
<tscreen>
<verb>
#!/usr/bin/perl
#
# Script for printjob load sharing
#   This is static, not dynamic balancing
#
# Printqueues to check
$printer1=&quot;hpl5a\@localhost&quot;;
$printer2=&quot;hpl5b\@localhost&quot;;
# obtain number of jobs in each printqueue
$lpq1=`/usr/local/bin/lpq -s -P$printer1`;
$lpq2=`/usr/local/bin/lpq -s -P$printer2`;
$lpq1=~ (/(\d+) jobs?/); $numjobs1=$1;
$lpq2=~ (/(\d+) jobs?/); $numjobs2=$1;
if ($numjobs1 == 0) &lcub;
    print &quot;dest $printer1\nCA\nend\n&quot;;
    exit;
&rcub;
if ($numjobs1 &gt; $numjobs2) &lcub;
    print &quot;dest $printer2\nCA\nend\n&quot;;
    exit;
&rcub;
print &quot;dest $printer1\nCA\nend\n&quot;; 
</verb>
</tscreen>
<sect1>Printer Load Balancing
<p>
In a large site, you could have several equivalent printers, which
will be used by many people. The reason for this is, of course, to
increase the printer output by enabling several jobs to be printed at
once.
<p>
LPRng supplies mechanisms to define a `virtual' printer for such a set
of real printers. If properly set up, print jobs will be distributed
evenly over all printers.
<p>
<sect2>Multi-server print queue
<label id="ss">
<label id="sv">
<p>
Options used:
<itemize>
<item> <tt>ss=</tt><em>queue served by printer </em>
<item> <tt>sv=</tt><em>printers where jobs are sent (servers)</em>
</itemize>
<p>
A multi-server print queue is one that feeds jobs to other queues.
The main queue
<tt>sv=q1,q2,...</tt> printcap entry specifies the names of the printers
that will be sent jobs.
These printers must have their spool queues on this LPD server.
<p>
Servers that are fed jobs have a
<tt>ss=</tt><em>mainqueue</em>
printcap entry.
This informs the <tt>lpd</tt> server that the queue operates under the
control of the <em>mainqueue</em> print queue,
and is fed jobs from it.
<p>
During normal operation,
when the <tt>lpd</tt> server has a job to print in the <em>mainqueue</em>,
it will check to see if there is an idle <em>service</em>  queue.
If there is,
it will transfer the job to the service queue spooling directory
and start the service queue printing activities.
<p>
Users can send jobs directly to the individual printers serving a queue.
<p>
The next example (and the comments underneath) was supplied by John Perkins
&lt;<tt>john@cs.wisc.edu</tt>&gt; (slightly edited).
<p>
Here's how I've set up a bounce queue that feeds 6 LaserWriters:
<p>
<tscreen>
<verb>
laser|pi|Room 1359 LaserWriters
    :lp=laser@server.com
laser|pi|Room 1359 LaserWriters
    :server
    :lf=/usr/adm/laser-log
    :sv=laser1,laser2,laser3,laser4,laser5,laser6
    :sd=/usr/spool/laser
.commonlaser
    :sd=/usr/spool/%P
    :rw:mx=0:sh
    :lf=/usr/adm/laser1-log
    :if=/s/lprng/lib/filters/cappsif
    :of=/s/lprng/depend/cap/bin/papof
    :ss=laser
    :fx=fdginpt
laser1|pi1|Room 1359 LaserWriter #1
    :lp=laser1@server.com
laser1|pi1|Room 1359 LaserWriter #1
    :server
    :lp=/dev/laser1
    :tc=.commonlaser
laser2|pi2|Room 1359 LaserWriter #1
    :lp=laser2@server.com
laser2|pi2|Room 1359 LaserWriter #2
    :server
    :lp=/dev/laser2
    :tc=.commonlaser
</verb>
</tscreen>
<p>
and so on for the other 4 <tt>laser</tt><em>N</em> queues.
<p>
This will forward a job from <tt>laser</tt> to <tt>laser</tt><em>N</em>, once
one of those queues is available. It will hold jobs in the
``<tt>laser</tt>'' queue until one of the other queues is empty.
<p>
Even though the queues are not meant for
direct use,
people can print directly to individual queues.
This allows a specific load sharing printer to be used.
If you wanted to
<em>hide</em> the load sharing printers,
i.e. - not allow direct spooling to them,
then you would simply remove the non-server entries from the printcap.
<sect2>Checking Busy Status of Server Queues
<label id="checkidle">
<p>
Options used:
<itemize>
<item> <tt>check_idle=</tt><em>check for idle printer program </em>
</itemize>
<p>
The previous section outlined how LPRng uses the <tt>sv</tt> and <tt>ss</tt>
flags to indicate that the server spool queue has multiple destination queues.
However,
there is a problem when the actual printer being served by the destination queue
is a remote device,
and can be busy or offline.
<p>
The <tt>check_idle</tt> option specifies a program that is invoked by the
<tt>lpd</tt>
server to determine if the spool queue device is available.
<p>
The program is invoked with the standard filter options,
STDIN and STDOUT connected to <tt>/dev/null</tt>,
and STDERR to the status file.
<p>
The program should make a connection to the remote device or system
and should determine that the remote device is available for use,
and then exit with the following status.
<tscreen>
<verb>
Key      Value   Meaning
JSUCC    0       Successful - printer is idle
JABORT   non-zero Printer is not accepting jobs
</verb>
</tscreen>
<p>
If the printer is accepting jobs but is temporarily busy,
the program should poll the printer until it becomes free,
only exiting when it is available for use.
If the printer is not accepting jobs, the program should exit with a non-zero
exit code. 
<p>
The following is a sample printcap entry, showing how the <tt>check_idle</tt>
facility can be used.
<tscreen>
<verb>
pr:
  :lp=laserjet%9100
  :check_idle=/usr/local/filters/remote_check lp@laserjet
  :if=/usr/local/filters/ifhp
</verb>
</tscreen>
<p>
The following perl program shows how to generate a query to the
remote printer by simulating an <tt>lpq</tt> query and checking for
returned status.
<tscreen>
<verb>
#!/usr/local/bin/perl
# Usage:
#  remote_check printer@host[%port] [-options]
#   -Tflag[,flags]*
#  flag
#    debug  - turns debugging on
#    long   - use long status format
#
# query the remote printer whose name is passed on the command line
# 
# Note that -Txxx options are passed AFTER the printer
use English;
use IO::Socket;

my $JSUCC = 0;
my $JABORT = 33;
my $JNOSPOOL = 38;
my $JNOPRINT = 39;

my $debug = 0;
my $optind;

# pull out the options
my($key,$value,$opt,$long,$opt_c);

$printer = $ARGV[0];

for( $i = 1; $i < @ARGV; ++$i )&lcub;
    $opt = $ARGV[$i];
    print STDERR "XX opt= $opt\n" if $debug;
    if( $opt eq '-c' )&lcub;
        $opt_c = 1;
    &rcub; elsif( ($key, $value) = ($opt =~ /^-(.)(.*)/) )&lcub;
        if( $value eq "" )&lcub;
            $value = $ARGV[++$i];
        &rcub;
        $&lcub;"opt_$key"&rcub; = $value;
        print STDERR "XX opt_$key = " . $&lcub;"opt_$key"&rcub; . "\n" if $debug;
    &rcub; else &lcub;
        $optind = $i;
        last;
    &rcub;
    print STDERR "XX opt_P = $opt_P\n" if $debug;
&rcub;

$long = 0;  # short

if( defined($opt_T) )&lcub;
    print STDERR "XX CHECK_REMOTE opt_T=$opt_T\n" if $debug;
    if( $opt_T =~ /debug/ )&lcub;
        $debug = 1;
    &rcub;
    if( $opt_T =~ /short/ )&lcub;
        $long = 1;
    &rcub;
    if( $opt_T =~ /long/ )&lcub;
        $long = 0;
    &rcub;
&rcub;

print STDERR "XX CHECK_REMOTE " . join(" ",@ARGV) . "\n" if $debug;

if( !defined($printer) or $printer =~ /^-/ )&lcub;
    print STDERR "$0: no printer value\n";
    exit( $JABORT );
&rcub;

while( checkstatus( $printer, $long ) )&lcub;
    print STDERR "XX CHECK_REMOTE sleeping\n" if $debug;
    sleep(10);
&rcub;

exit $JSUCC;

sub checkstatus &lcub;
    my ($printer,$long) = @_;
    my ($remote,$port);
    my ($count, $socket, $line);

    if( $long )&lcub;
        $long = 4;
    &rcub; else &lcub;
        $long = 3;
    &rcub;
    if( $printer =~ /@/ )&lcub;
        ($printer,$remote) = $printer =~ m/(.*)@(.*)/;
    &rcub;
    $remote="localhost" unless $remote;

    if( $remote =~ /%/ )&lcub;
        ($remote,$port) = $remote =~ m/(.*)%(.*)/;
    &rcub;
    $port = 515 unless $port;
    print STDERR "XX CHECK_REMOTE remote='$remote',"
        . " port='$port', pr='$printer', op='$long'\n" if $debug;

    $socket = getconnection( $remote, $port );

    $count = -1;
    # send the command
    printf $socket "%c%s\n", $long, $printer;

    while ( defined( $line = <$socket>) && $count < 0 )&lcub;
        chomp $line;
        print STDERR "XX CHECKREMOTE '$line'\n" if $debug;
        if( $line =~ /printing disa/ )&lcub;
            print STDERR "XX CHECKREMOTE printing disable\n" if $debug;
            exit $JNOPRINT;
        &rcub; elsif( $line =~ /spooling disa/ )&lcub;
            print STDERR "XX CHECKREMOTE printing disable\n" if $debug;
            exit $JNOSPOOL;
        &rcub; elsif( $line =~ /([0-9]*)\s+job.?$/ )&lcub;
            $count = $1;
            print STDERR "XX CHECKREMOTE $count jobs\n" if $debug;
        &rcub;
    &rcub;
    close $socket;
    if( $count < 0 )&lcub;
        print STDERR "CHECKREMOTE cannot decode status\n";
        exit $JABORT;
    &rcub;
    return $count;
&rcub;

sub getconnection &lcub;
    my ($remote,$port) = @_;
    my ($socket);
    print STDERR "XX CHECK_REMOTE remote='$remote', port=$port\n" if $debug;
    $socket = IO::Socket::INET->new(
        Proto => "tcp",
        PeerAddr => $remote,
        PeerPort => $port,
        );
    if( !$socket )&lcub;
        print STDERR "CHECK_REMOTE IO::Socket::INET failed - $!\n";
        exit $JABORT;
    &rcub;
    $socket->autoflush(1);
    $socket;
&rcub;
</verb>
</tscreen>
<p>
The example of the previous section can be modified now
so that it uses the <tt>check_idle</tt> facility.
The master queue will send jobs only to the server queue queues
which report idle status.
<tscreen>
<verb>
laser1|pi1|Room 1359 LaserWriter #1
    :server:check_idle=/usr/local/lib/filters/remote_check pr@laser1
    :lp=laser1%9100
    :tc=@commonlaser
laser2|pi2|Room 1359 LaserWriter #2
    :server:check_idle=/usr/local/lib/filters/remote_check pr@laser1
    :lp=laser2%9100
    :tc=@commonlaser
</verb>
</tscreen>
<sect1>Locations of Printcap Files
<label id="lpdprintcappath">
<label id="printcappath">
<label id="details">
<p>
Options used:
<itemize>
<item> <tt>printcap_path=</tt><em>printcap file locations</em>
<item> <tt>lpd_printcap_path=</tt><em>additional server printcap file locations</em>
</itemize>
<p>
The
<tt>printcap_path </tt>
and
<tt> lpd_printcap_path </tt>
configuration options (see
<ref id="lpdconf" name="lpd.conf(5)">) specify a set of paths for the
printcap information.
Client programs use only <tt>printcap_path</tt> and the <tt>lpd</tt>
server uses both
<tt>printcap_path</tt> and <tt>lpd_printcap_path</tt>.
The path names can be separated with whitespace,
commas, semicolons, or colons.
The default values are:
<tscreen>
<verb>
printcap_path      /etc/printcap /usr/etc/printcap
lpd_printcap_path  /etc/lpd_printcap /usr/etc/lpd_printcap
</verb>
</tscreen>
<sect2>Separate Server and Client Printcap Files
<p>
Since only the LPD server uses the
printcap file specified by the
<tt/lpd_printcap_path/,
you can place server specific information there.
This allows you to have a common printcap file for clients and an
additional one for the lpd servers.
<sect2> ALL Printcap Entry
<p>
The <tt/all/ printcap name and <tt/all/ option
is reserved to provide a list of printers
available for use by the spooling software.
This is a desperation,
last ditch,
back to the wall option for
administrators
with systems that do not have ways to provide a list of printcap entries.
The 'all' printcap entry has the form:
<tscreen>
<verb>
all:all=pr1,pr2,...
</verb>
</tscreen>
<p>
The value of the <tt/all/ option should be a list of printcap names
whose values will then be extracted.
<sect1>Management Strategies for Large Installations
<p>
One very effective way to organize print spooling is to have a small
number of print servers running a
<tt>lpd</tt> daemon,
and to have all the other systems send their jobs directly to them.
By using the above methods of specifying the printer and server host
you eliminate the need for more complex management strategies.
<p>
However,
you still need to inform users of the names and existence of these printers,
and how to contact them.
One method is to use a common
<tt>/etc/printcap</tt>
file which is periodically updated and transfered to all sites.
Another method is to distribute the information using the
NIS or some other database.
LPRng has provided a very flexible method of obtaining and distributing
database information:  see
<ref id="secnis" name="Using Programs To Get Printcap Information">
for details.
<sect1>Using Programs To Get Printcap Information
<label id="secnis">
<p>
In the
<tt>lpd.conf</tt>
file you can specify:
<tscreen>
<verb>
printcap_path=|program
</verb>
</tscreen>
This will cause the LPRng software to execute the specified program,
which should then provide the printcap information.
The program is invoked with the standard filter options,
and has the name of the printcap entry provided on
<tt>STDIN</tt>.
The filter
should supply the printcap information on
<tt>stdout</tt>
and exit with a 0
(success) error code.  By convention,  the printcap name 'all'
requests a printcap entry that lists all printers.
<p>
This technique has been used to interface to the Sun Microsystem NIS
and NIS+ databases with great success.
By having the invoked program a simple shell script or front end to the
<tt>nismatch</tt> or <tt>ypmatch</tt> programs,
the complexity of incorporating vendor specific code is avoided.
<sect2>How to use NIS and LPRng
<p>
This note is based on material sent to the
<tt>lprng@lprng.org</tt>
mailing list by
Paul Haldane
<tt>&lt;paul@ucs.ed.ac.uk></tt>.
<p>
<tscreen>
<verb>
 # From: Paul Haldane <paul@ucs.ed.ac.uk>
 # To: lprng@lprng.org
 # Subject: Re: Problem using plp with NIS
 # 
</verb>
</tscreen>
<p>
We generally don't use NIS for printcap files (we've
moved to hesiod) but I can show you what we've done in the past.
<p>
The input to NIS is a normal printcap file:
<tscreen>
<verb>
# Classical printcap entry
lp23a|lp23|lp|main printhost printer - KB, EUCS front Door:\
        :lp=lp23a@printhost:\
        :sd=/usr/spool/lpr/lp23a:
 
#lprng printcap entry
lplabel|lpl|TEST - Labels printer:
        :lp=:rm=printhost:rp=lplabel:
        :sd=/usr/spool/lpr/lplabel:
        :rg=lpadm:mx=1:
</verb>
</tscreen>
<p>
To build the NIS printcap.byname map we add the following to
the NIS makefile (along the other bits and pieces that the makefile
needs to know about a new map).
<tscreen>
<verb>
PRINTCAP=$(DIR)/printcap
#PRINTCAP=/etc/printcap
# warning : [  ] is actually [<space><tab>] in the script
printcap.time: $(PRINTCAP) Makefile
  if [ -f $(PRINTCAP) ]; then \
    sed < $(PRINTCAP) \
      -e 's/[   ][  ]*$$//' -e '/\\$$/s/\\$$/ /' \
    | awk '$$1 ~ /^#/&lcub;next;&rcub; $$1 ~ /^[:|]/ &lcub;printf "%s", $$0; next;&rcub; \
        &lcub;printf "\n%s", $$0 &rcub;' \
    | sed -e 's/[   ]*:[  ]*:/:/g' -e 's/[  ]*|[  ]*/|/g' \
      -e '/^[   ]*$$/d' > .printcap.$$$$; \
    cat .printcap.$$$$; \
    if [ $$? = 0 -a -s .printcap.$$$$ ]; then \
      awk <.printcap.$$$$ '&lcub; FS=":"; OFS="\t"; &rcub; &lcub; \
          n = split($$1, names, "|"); \
          for (i=1; i<=n; i++) \
              if (length(names[i]) > 0 \
              && names[i] !~ /[ \t]/) \
                  print names[i], $$0; \
      &rcub;' | $(MAKEDBM) - $(YPDBDIR)/$(DOM)/printcap.byname; \
      awk <.printcap.$$$$ '&lcub; FS=":"; OFS="\t"; &rcub; &lcub; \
          n = split($$1, names, "|"); \
          if (n && length(names[1]) > 0 && names[1] !~ /[ \t]/) \
              print names[1], $$0; \
      &rcub;' | $(MAKEDBM) - $(YPDBDIR)/$(DOM)/printcap.bykey; \
      rm -f .printcap.$$$$; \
      touch printcap.time; echo "updated printcap"; \
    fi \
  fi
  @if [ ! $(NOPUSH) -a -f $(PRINTCAP) ]; then \
      $(YPPUSH) printcap.byname; \
      $(YPPUSH) printcap.bykey; \
      touch printcap.time; echo "pushed printcap"; \
  fi
</verb>
</tscreen>
<p>
To specify that you want YP database rather than file access,
use the following entry in your <tt>/etc/lpd.conf</tt> file:
<tscreen>
<verb>
printcap_path |/usr/local/lib/pcfilter
</verb>
</tscreen>
<p>
Put the following shell script in /usr/local/lib/pcfilter
<tscreen>
<verb>
#!/bin/sh
#/usr/local/lib/pcfilter
read key
ypmatch "$key" printcap.byname
</verb>
</tscreen>
<p>
<sect2>How to use NIS and LPRng - Sven Rudolph
<p>
<tscreen>
<verb>
 Date: Wed, 11 Sep 1996 00:11:02 +0200
 From: Sven Rudolph <sr1@os.inf.tu-dresden.de>
 To: lprng@lprng.org
 Subject: Using :oh=server: with NIS
</verb>
</tscreen>
<p>
When I use a cluster-wide printcap,
two entries for each printer will appear, e. g.:
<tscreen>
<verb>
---------- start of /etc/printcap snippet
lp1
 :lp=lp1@server
lp2
 :lp=lp2@server
lp1
 :server:oh=servername
 :sd=/var/spool/lpd/lp1
 :lp=/dev/lp1
 :sh:mx=0
---------- end of /etc/printcap snippet
</verb>
</tscreen>
<p>
When I create a NIS map out of this,
the printer name is used as a key
and must be unique. So NIS' makedbm decides to drop all but the last
entry for each printer. This makes the printer on the clients
unavailable.
I solved this by a hack where the second entry is called lp1.server
and the NIS client script has to request the right entry.
<enum>
<item>
Assumptions
<p>
Perl is available at the YP server in /usr/bin/perl .
A Bourne Shell is available at all clients in /bin/sh
The printcap that is to be exported is in /etc/printcap .
The printcap is written in the new format.
<p>
In the examples the printer is called lp1 .
</item>
<item>
Add the following to your YP Makefile (/var/yp/Makefile) on the YP
server :
<tscreen>
<verb>
---------- start of /var/yp/Makefile snippet
PRINTCAP  = /etc/printcap
printcap: $(PRINTCAP)
    @echo "Updating $@..."
    $(CAT) $(PRINTCAP) | \
        /usr/lib/yp/normalize_printcap | $(DBLOAD) -i $(PRINTCAP) \
        -o $(YPMAPDIR)/$@ - $@
    @if [ ! $(NOPUSH) ]; then $(YPPUSH) -d $(DOMAIN) $@; fi
    @if [ ! $(NOPUSH) ]; then echo "Pushed $@ map." ; fi
---------- end of /var/yp/Makefile snippet
</verb>
</tscreen>
<p>
(These lines are for Debian GNU/Linux, other systems might require
other modifications)
<item>
Install the programs <tt>match_printcap</tt>
and <tt>normalize_printcap</tt> to <tt>/usr/lib/yp</tt>.
normalize_printcap
is only required on the YP server.
The <tt>normalize_printcap</tt> processes only the LPRng printcap format.
<tscreen>
<verb>
---------- start of /usr/lib/yp/normalize_printcap
#! /usr/bin/perl
$debug = 0;
$line = "";
$new = "";
while (<>) &lcub;
    chomp;
    next if ( /^\s*\#.*/ );
    s/^\s*$//;
    next if ( $_ eq '' );
    print "new: " . $_ . "\n" if $debug;;
    if (/^\s/) &lcub; # continuation line
        $line = $line.$_;
        print "continued: $line\n" if $debug;
        next;
    &rcub; else &lcub;
        $line =~ s/\s+\:/:/g;
        $line =~ s/\:\s+/:/g;
        $line =~ s/\:\s*\:/:/g;
        print "line: $line\n" if $debug;
        push(@lines, $line) if $line;
        $line = $_;
    &rcub;
&rcub;
$line =~ s/\s+\:/:/g;
$line =~ s/\:\s+/:/g;
$line =~ s/\:\s*\:/:/g;
push(@lines,$line) if $line;
@lines = sort(@lines);
foreach $line (@lines) &lcub;
    ($printers) = split(/\:/,$line);
    @printers = split(/\|/,$printers);
    foreach $printer (@printers) &lcub;
      $num&lcub;$printer&rcub;++;
      push(@allprinters,$printer);
      print "allprinters: @allprinters\n" if $debug;
      print $printer."_".$num&lcub;$printer&rcub;."\t$line\n";
    &rcub;
&rcub;
@pr = keys %num;
print "printers @pr\n" if $debug;
if ($#allprinters >=0) &lcub;
    print "all_1\tall:all=".join(",",@pr)."\n";
&rcub;
---------- end of /usr/lib/yp/normalize_printcap
</verb>
</tscreen>
<p>
The result of processing the sample printcap file is:
<tscreen>
<verb>
lp1_1 lp1:lp=lp1@server
lp1_2 lp1:server:oh=servername:sd=/var/spool/lpd/lp1:lp=/dev/lp1:sh:mx=0
lp2_1 lp2:lp=lp2@server
all_1 all:all=lp1,lp2
</verb>
</tscreen>
<p>
Observe that each of the real printer entries has a key consisting of the
printer name with a numerical suffix.
This leads to the following method of extracting the printcap information
using <tt>ypmatch</tt>:
<tscreen>
<verb>
---------- start of /usr/lib/yp/match_printcap
#!/bin/sh
read p
n=1
while ypmatch "$&lcub;p&rcub;_$&lcub;n&rcub;" printcap 2>/dev/null; do
    n=`expr $n + 1`
done
---------- end of /usr/lib/yp/match_printcap
</verb>
</tscreen>
<item>
Now test the YP arrangement:
<tscreen>
<verb>
$ cd /var/yp; make # this should create the printcap map
$ ypcat printcap # should provide the whole normalized printcap
$ echo lp1 |/usr/lib/yp/match_printcap # yields lp1 printcap
</verb>
</tscreen>
<item>
Add the printcap_path entry to <tt>/etc/lpd.conf</tt>:
<tscreen>
<verb>
printcap_path=|/usr/lib/yp/match_printcap
</verb>
</tscreen>
<item>
Test the use of the printcap path entry:
<tscreen>
<verb>
$ lpq -Plp1 # shows the status of lp1
</verb>
</tscreen>
<item>
Restart the lpd server and check to see that it accesses
the right printcap information.
Use the same <tt>lpq</tt> command,
and then try <tt>lpc printcap lp1</tt>.
</enum>
<sect>LPRng checkpc Utility
<label id="checkpc">
<p>
The <tt>checkpc</tt> (check printcap file) is one of the most
useful utilities in the LPRng package.
<p>
It will read all the configuration files, printcap files and tests
whether devices are set up correctly. Optionally, it will also set the
permissions for spool directories and device files. Additionally, it
will truncate the accounting and log files to a maximum size. Another
use for <tt>checkpc</tt> is to remove old entries from queue
directories.
<p>
For a new installation, you will want to run
<tscreen>
<verb>
checkpc -f -V
</verb>
</tscreen>
to set the permissions right. The <tt>-f</tt> flag instructs the
program to correct file permissions. If you don't run this as
<tt>root</tt>, you'll receive a warning about that fact and any
<bf>chown(2)</bf> calls will (most likely) fail.
<p>
The program reports everything it changes. Since it isn't too clever
about some things (visit the man page), you should keep an eye on the
output, and run it again if needed. If it keeps failing, change the
permissions yourself.
<sect1>Maintenance
<p>
Later, you will want to use <tt>checkpc</tt> for the daily
maintenance of your system. I have this line in user <tt>lp</tt>'s
crontab:
<tscreen>
<verb>
32 5 * * * checkpc -t 10K -A3 -r &gt;/dev/null 2&gt;&1
</verb>
</tscreen>
This job will:
<enum>
<item>truncate all log and accounting files to 10KB (<tt>-t 10K</tt>).
Actually, it will keep the last 10K from the file, starting on a
complete line.</item>
<item>remove all stale files older than three days (<tt>-A3 -r</tt>).</item>
</enum>
I'm redirecting output to <tt>/dev/null</tt>, because <tt>checkpc</tt>
is a little noisy to my taste. (But too noisy is better than too
silent :)
<sect1> Printcap Information
<p>
You can use <tt/checkpc -V -P/
to examine printcaps and tell you what
they contain.
This is identical to the <tt/lpc server all/ operation,
but with a higher level of verbosity.
<sect>Spool Queues and Files
<label id="sd">
<label id="cd">
<p>
When files are accepted by the <tt>lpd</tt> server for printing,
they are stored in a spool queue directory,
together with other files controlling the print operation.
This section describes these files and how the LPRng software uses them.
<p>
For descriptive purposes,
we will use the following printcap entry as a guide:
<p>
<tscreen>
<verb>
pr|alias
  :sd=/var/lpd/pr_public
  :cd=/var/lpd/pr
</verb>
</tscreen>
<sect1>Spool Queue
<p>
<itemize>
<item> <tt>sd=</tt><em>Spool queue directory name</em>
</itemize>
<p>
The
<tt>sd</tt>
option in the printcap entry specifies the spool queue
directory.
If there is no
<tt>sd</tt>
entry or value,
then the printer can only be used by the clients such as <tt>lpr</tt>
to locate the destination for a print job.
All information,
files,
etc.,
for a print queue is stored in the spool directory.
<sect1>Queue Lock File
<label id="queue_lock_file">
<p>
<itemize>
<item> <tt>spool_lock_file</tt><em>&nbsp;&nbsp;spool queue lock file - default %P</em>
</itemize>
<p>
When the <tt>lpd</tt> server starts printing,
it will fork individual worker processes to service each queue.
To prevent multiple processes from working on the same queue,
a printer lock file specified by the
<tt/queue_lock_file/ option
(default <tt/%P/ - the %P is expanded to the print queue name)
is used.
In our example,
the lock file would be:
<tt>/var/lpd/pr/pr</tt>.
<p>
The process ID of the currently active printer is stored in the lock file.
By reading the lock file and testing to see if the process is still active,
programs such as <tt/lpq/ can determine queue activity.
<p>
Similarly,
the worker process may need to create other processes to assist it.
These in turn will create lock or temporary files in the spool directory
as well.
<sect1>Spool Control File
<label id="queue_control_file">
<p>
<itemize>
<item> <tt>spool_control_file</tt><em>&nbsp;&nbsp;spool queue control file - default control.%P</em>
</itemize>
<p>
The spool control file is used to control the operations of the
spooler,
and is in the spool or control directory.
The file name specified by the
<tt/queue_control_file/ option
(default <tt/control.%P/ - the %P is expanded to the print queue name);
in our example,
the control file would be:
<tt>/var/lpd/pr/control.pr</tt>.
<p>
The <tt>lpc</tt> program sends spool control requests to the
<tt>lpd</tt> daemon,
which updates the control file and then signals the appropriate
spool server processes that an update has been performed.
The control file contents have the form:
<tscreen>
<verb>
key value
</verb>
</tscreen>
<p>
The following keys and their values are currently supported.
<p>
<!--  START TABLE2 -->
<tt>printing_disabled&nbsp;&nbsp;&nbsp;</tt>
<tt>0 or 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>
<tt>disable printing of jobs in queue</tt> <newline>
<tt>spooling_disabled&nbsp;&nbsp;&nbsp;</tt>
<tt>0 or 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>
<tt>disable placing jobs in queue</tt> <newline>
<tt>holdall&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>
<tt>0 or 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>
<tt>hold jobs until released</tt> <newline>
<tt>redirect&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>
<tt>printer&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>
<tt>transfer jobs to indicated printer</tt> <newline>
<tt>class&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>
<tt>glob expression&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>
<tt>print only jobs whose class matches glob expression</tt> <newline>
<tt>server_order&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>
<tt>printer name list&nbsp;&nbsp;&nbsp;</tt>
<tt>preferred order of printer use</tt> <newline>
<tt>debug&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>
<tt>debugging options&nbsp;&nbsp;&nbsp;</tt>
<tt>debugging and tracing</tt> <newline>
<!--  END TABLE2 -->
<p>
The <tt>printing_disabled</tt> and <tt>spooling_disabled</tt>
are managed using the <tt>lpc start</tt>, <tt>lpc stop</tt>,
<tt>lpc enable</tt> and <tt>lpc disable</tt>
commands.
Similarly,
<tt>holdall</tt> is enabled and disabled by <tt>holdall</tt> and
<tt>noholdall</tt>
commands respectively.
When holdall is enabled,
jobs placed in the print queue will be held until they are explicitly
released for printing by an <tt>lpc release</tt> command.
<p>
The <tt>redirect</tt> entry is used to redirect or transfer jobs
which are spooled to this queue to another queue,
and is managed by the redirect command.
The <tt>lpc redirect off</tt> removes the redirect entry from the
control file.
<p>
The <tt>class</tt> entry is similar in operation to the
<tt>holdall</tt>,
but allows jobs whose class identification matches the glob
expression to be printed.
This can be useful when you have special forms or paper required for a
print job,
and want to run only these jobs when the paper is in the printer.
<p>
The <tt>server_order</tt>
entry is created and updated for a multiple printer queue.
It records the order in which printers should next be used
for normal print operations.
This allows <em>round robin</em> use of printers,
rather than having all jobs printed to the first printer in the
list of printers.
<p>
The <tt>debug</tt>
entry is set by the <tt>lpc debug</tt> command,
and is used to enable or disable debugging and tracing information
for a spool queue.
This facility is for diagnostic purposes only.
<sect1>Log and Status Files
<label id="lf">
<label id="ps">
<label id="short_status_date">
<label id="maxstatusline">
<label id="maxstatussize">
<label id="minstatussize">
<label id="maxlogfilesize">
<label id="minlogfilesize">
<label id="createfiles">
<label id="queue_status_file">
<p>
<itemize>
<item> <tt>create_files</tt><em>&nbsp;&nbsp;create log, accounting and status files</em>
<item> <tt>lf=</tt><em>log file name (default: log)</em>
<item> <tt>max_log_file_size#</tt><em>&nbsp;&nbsp;maximum log file size (Kbytes)</em>
<item> <tt>min_log_file_size#</tt><em>&nbsp;&nbsp;minimum log file size (Kbytes)</em>
<item> <tt>max_status_line#</tt><em>&nbsp;&nbsp;maximum status line length (characters) </em>
<item> <tt>max_status_size#</tt><em>&nbsp;&nbsp;maximum status file size (Kbytes)</em>
<item> <tt>min_status_size#</tt><em>&nbsp;&nbsp;minimum status file size (Kbytes)</em>
<item> <tt>ps=</tt><em>filter status file name (default: status)</em>
<item> <tt>queue_status_file=</tt><em>queue status file (default: status.%P)</em>
<item> <tt>short_status_date=</tt><em>display short (hh:mm) timestamp (default: true)</em>
</itemize>
<p>
During operation,
the <tt>lpd</tt> server records the current printing operations
in the spool queue status file specified by the <tt/spool_status_file/ option
(default <tt/status.%P/ - the %P is expanded to the print queue name);
for our example, this would be
<tt>/var/lpd/pr/status.pr</tt>.
In order to prevent this file from growing too large,
the server will periodically truncate the file.
You can force creation of these files by setting the
<tt/create_files/ option.
The
<tt>max_status_size</tt> configuration or printcap option
sets the maximum size (in Kbytes) of the status file;
if the file exceeds this,  only the last
<tt>min_status_size</tt> bytes
or 25% of the maximum size (default if not specified)
will be preserved.
<p>
Similarly,
the server logs its operations in the log file specified by the
<tt>lf</tt> (log file) option (default is <tt>lf=log</tt>).
The <tt>max_log_file_size</tt>
value
(default 0)
specifies the maximum length
of the log file in Kbytes.
If this value is non-zero,
then the log file is truncated to
<tt>min_log_file_size</tt> bytes
or 25% of the maximum file size.
Again, the last portion of the log file is preserved.
If the <tt>max_log_file_size</tt> value is 0,
then the log file grows without limit.
<p>
Some filters require an additional filter status file
that they use for recording additional filter status or
other operational information.
The
<tt>ps</tt> names this file,
and it is passed to a print filter using the <tt>$s</tt>
option
(see
<ref id="filtercmd" name="Filter Command Line Flags">).
<p>
The STDERR output for filters is put into the printer
status file.
This allows the filter to produce informative messages that can be displayed
as part of the user status.
In addition,
a separate status file specified by the
<tt>ps</tt> (Printer Status) can be used as well.
This file is 
<em>not</em>
truncated by the LPRng system.
<p>
When reporting status information,
the length of line returned can be a problem.
The <tt>max_status_line#79</tt> option restricts the status line
to a maximum of 79 characters.
<p>
The <tt>short_status_date</tt> (default is true)
option causes short (hour:minute) timestamps to be displayed
on status queries.
<sect1>Job Files
<p>
<label id="nline_after_file">
<itemize>
<item> <tt>longnumber</tt><em>&nbsp;&nbsp; long job number</em>
<item> <tt>default_priority=</tt><em>default job priority</em>
<item> <tt>nline_after_file=</tt><em>N line after data file</em>
</itemize>
<p>
A print job consists of a control file and one or more data files.
<ref id="rfc1179" name="RFC1179">
specifies the general format of these files and how they are to be
transfered between servers.
LPRng has extended the contents of the control files and the transfer protocol
to provide a more powerful set of features,
but has extensive provisions for backwards compatibility with
non-LPRng software.
A sample control file is shown below:
<tscreen>
<verb>
Hastart4.astart.com
J/tmp/file1 /tmp/file2
CA
Lpapowell
Ppapowell
fdfA002230astart4.astart.com
N/tmp/file1
UdfA002230astart4.astart.com
fdfB002230astart4.astart.com
N/tmp/file2
UdfB002230astart4.astart.com
</verb>
</tscreen>
<p>
The first part of the control file contains general information generated
by the <tt>lpr</tt> or other spooling program.
The information lines start with an uppercase letter or digit.
Some other spooling systems also start information lines with
various punctuation marks such as underscores (_) or periods (.).
<p>
Following this are a set of entries about each of the various files to
be printed.
These lines start with a lower case letter,
followed by the print file name.
The lower case letter is the
<em>format</em> to be used to process the file.
See
<ref id="format" name="print file formats">
for more information about its use.
<p>
<table>
<tabular ca="|l|l|l|">
Key
|
Meaning
|
Generated By
@
A
|
identifier *
|
LPRng internal
@
C
|
class
|
lpr -C class
@
D
|
date
|
lpr
@
H
|
originating host
|
lpr
@
I
|
indent
|
lpr -i indent
@
J
|
jobname
|
lpr -J jobname (default: list of files)
@
L
|
bnrname
|
lpr -U username
@
N
|
filename
|
(see text)
@
M
|
mailname
|
lpr -m mailname
@
P
|
logname
|
lpr
@
Q
|
queuename
|
lpr -Q
@
R
|
accntname
|
lpr -R accntname
@
S
|
slinkdata *
|
lpr
@
T
|
prtitle
|
lpr -T prtitle
@
U
|
unlnkfile
|
(see text)
@
W
|
width
|
lpr -w width
@
Z
|
zopts *
|
lpr -Z zopts
@
1
|
font1
|
lpr -1 font1
@
2
|
font2
|
lpr -2 font2
@
3
|
font3
|
lpr -3 font3
@
4
|
font4
|
lpr -4 font4
@
</tabular>
</table>
<p>
The entries marked with * are used only by LPRng.
<tt>N</tt> and <tt>U</tt> lines
are associated with a print file.
The <tt>N</tt> line is the original name of the print
file.
By default,
LPRng places this line <it>before</it>
the corresponding data file.
You can use the
<tt/nline_after_file/
option to have LPRng place the N line after the data file line.
The <tt>U</tt> line originally was used to indicate that the
named file was to be unlinked after printing.
This information is now ignored by LPRng.
These lines are always grouped with a print file entry.
<p>
The names of control and data files follow a very strict pattern.
Control files have the format <tt>cfX<em>number</em><bf>host</bf></tt>,
where X is an upper case letter,
<em>number</em> is (usually) a 3 digit number,
and <bf>host</bf> is the host name.
<ref id="rfc1179" name="RFC1179">
restricted the total length of the control file name to 32 characters;
LPRng has a much looser limit.
<p>
Data file names must follow the same pattern as the control file name,
and have the format
<tt>dfX<em>number</em><bf>host</bf></tt>.
The X can be in the range A-Za-z,
allowing at most 52 data files for a job.
The <em>number</em> and <bf>host</bf> must be identical to the corresponding
control file.
<p>
By convention,
LPRng uses the X of the control file name to set a priority for the
job.
A job with control file name
<tt>cfA...</tt>
will have <em>lower</em> format
than a job with format
<tt>cfB...</tt>,
and so forth.
The <tt>lpr</tt> program uses the first letter of the class name
or an explicit priority indication to set the letter value.
If none of these are specified, then the
<tt>default_priority</tt> value from the configuration or printcap
entry is used.
<p>
The job number is usually a 3 digit value.
However,
in systems where a large number of jobs are spooled and need to be
kept for printing at scheduled times,
this can lead to problems.
The
<tt>longnumber</tt>
option will use 6 digit job numbers.
This must be used with care when operating with non-LPRng software.
<sect1>Job Hold File
<p>
Associated with each control file is a
hold file that has additional information controlling the printing operations.
The entries in this file have the form:
<tscreen>
<verb>
key [value]
</verb>
</tscreen>
<p>
The following is an example of a hold file:
<tscreen>
<verb>
server 0
subserver 0
attempt 3
error cannot open printer
hold 0
priority 0
remove 0
routed 0
</verb>
</tscreen>
<p>
The
<tt>server</tt>
and
<tt>subserver</tt>
entry records the process ID of the server process
and the subserver process that is printing the job.
The
<tt>attempt</tt>
field records the total number of attempts to print the job.
The
<tt>error</tt>
field records any error that would prevent the job from being printed.
This information is reported by the <tt>lpq</tt> program.
<p>
The
<tt>hold</tt>
field is non-zero when the
<tt>lpc hold</tt>
command is used to
explicitly prevent the job from being printed;
<tt>lpc release</tt>
will clear the field and allow the job to be printed.
<p>
The
<tt>priority</tt>
field is modified by the
<tt>lpc topq</tt>
command and is used to provide an overriding priority to printing the file.
<p>
The
<tt>remove</tt>
field is non-zero when the file has been printed and should be removed.
<p>
The
<tt>routed</tt>
field is used to indicate that there is routing information present in
the hold file,
and that special handling is needed.
The routing information is provided by a
<ref id="routing" name="routing filter">.
The information is recorded by information in the hold file.
The following is an example of routing information.
Normally this information is stored in a URL escaped format,
with one line per destination,
but for clarity this has been broken out into plain text form:
<p>
<tscreen>
<verb>
active 0
attempt 0
done 0
hold 0
priority 0
remove 0
routed 880892602
route 1
  dest t1
  ident papowell@astart4+705.1
  error 
  copies 1
  copy_done 0
  status 0
  active 0
  attempt 0
  done 0
  hold 0
  sequence 0
  priority B
  CB
  end 
route 2
  dest t1
  ident papowell@astart4+705.2
  error 
  copies 0
  copy_done 0
  status 0
  active 0
  attempt 0
  done 0
  hold 0
  sequence 1
  end 
</verb>
</tscreen>
<p>
Routing information lines start with
<tt>route</tt> followed by individual routing entry information.
The <tt>route</tt> <tt>dest</tt>,
<tt>copies</tt>,
<tt>priority</tt>,
and
<tt>Xnnnn</tt>
entries are
derived from the output of the router program;
other fields are used during the printing process.
The <tt>copy_done</tt> records the numbers of copies done,
while the <tt>done</tt> records that the entry has been completed.
The <tt>status</tt> is the process ID of the server process
doing the printing.
<p>
The output from  route filter  that generated the above file was:
<tscreen>
<verb>
dest t1
copies 1
priority B
CB
end
dest t1
end
</verb>
</tscreen>
<sect1>Job State
<label id="ah">
<p>
Options used:
<itemize>
<item> <tt>ah</tt><em>&nbsp;&nbsp;Automatically hold jobs</em>
</itemize>
<p>
A job can be in the following state:
<enum>
<item>Initial.
This is the state during job submission.
Jobs in the initial state do not have any status displayed for them.
<item>Held.
Once a job is submitted,
it can either be printed or <em>held</em>.
The <tt>ah</tt> printcap option specifies that all jobs are
automatically held on submission.
The
<tt>lpc release</tt>
and
<tt>lpc redo</tt>
command will cause these jobs to be printed and
the <tt>lprm</tt> command can remove these jobs.
<item>
Active.
The job is being processed for printing or transfer to another queue.
<item>
Pending.
Jobs which can be printed but are not active.
This can be due to the printer being busy or
the job <bf>class</bf> not being printed.
<item>
Error.
Jobs which have encountered an error during printing.
The
<tt>lpc release</tt>
and
<tt>lpc redo</tt>
command will cause these jobs to be printed and
the <tt>lprm</tt> command can remove these jobs.
<item>
Done.
Jobs which have completed printing,
but which are not yet removed from the print queue.
See the
<tt><ref id="savewhendone" name="save_when_done"></tt>
flag for more information.
The <tt>lprm</tt> command can remove these jobs.
</enum>
<p>
Normally the job sequences is initial, pending, active, and done.
However, a job may be put in the error state by problems processing the job
or by actions of the <tt>lpc</tt> command.
<sect1>Job Identifier
<label id="useidentifier">
<p>
Options:
<itemize>
<item> <tt>use_identifier</tt><em>&nbsp;&nbsp;put job identifier in control file</em>
</itemize>
<p>
For each job in a spool queue,
the LPRng software creates a unique identifier.
This identifier is recorded in the control file <tt>A</tt> line.
It can be used by the various client programs for identifying jobs,
and is displayed by the <tt>lpq</tt> program as status information.
<sect>Configuration File lpd.conf and Options
<label id="configfile">
<label id="lpdconf">
<p>
The values in the LPRng configuration file
(default: <tt>/etc/lpd.conf</tt>)
override the compile time default values for printcap options.
See the
<ref id="index" name="Index To All The Configuration and Printcap Options">
for an index to a complete list of configuration options.
<sect1>Configuration File Format
<p>
The LPRng distribution contains a template <tt>lpd.conf</tt> file
which can be installed as
<tt>/etc/lpd.conf</tt>.
The configuration file has the following format:
<tscreen>
<verb>
# lpd.conf generated from  on Wed Apr  7 07:59:48 PDT 1999

#   The values in this file are the default values.
#   If you modify the file,  set the value to something other than the default
#   For example, '# default force_localhost' means the 'force_localhost' option
#    change this to 'force_localhost@' to have the opposite effect.

# Purpose: always print banner, ignore lpr -h option
#   default ab@
# change ---
ab
# Purpose: query accounting server when connected
#   default achk@
# Purpose: accounting at end (see also af, la, ar, as)
#   default ae=jobend $H $n $P $k $b $t
# Purpose: name of accounting file (see also la, ar)
#   default af=
...
</verb>
</tscreen>
<p>
The options are set exactly as for a printcap file,
but do not require a leading colon (:).
<p>
To change the default value of an option,
remove the comment character and edit the entry as shown in the above example.
<p>
To force the <tt>lpd</tt> server to use the new options,
use the <tt>lpc reread</tt> command.
<sect1>Configuration Information
<label id="allowgetenv">
<p>
In order to protect system security,
the
<tt>/etc/lpd.conf</tt>
and
<tt>/etc/printcap</tt>
files should be read only.
<p>
For testing purposes
when LPRng is compiled with the <tt>-DGET_ENV</tt> option
LPRng uses the value of the <tt>LPD_CONF</tt> environment variable
as the path to the <tt/lpd.conf/ file.
<bf>This is a security loophole,
and should not be used when running SETUID ROOT or as ROOT.</bf>
<sect1>Configuration Options
<p>
The following variables are used to set default behavior
for the LPRng software,
or are commonly used for configuration of LPRng operations.
<sect2>default_format
<label id="defaultformat">
<p>
Default format for printing.
Usually,
<tt>default_format=f</tt>,
but setting it to
<tt>default_format=l</tt> will cause all files spooled by lpr
to be spooled as binary files.
<sect2>default_permission=ACCEPT
<label id="defaultpermission">
<p>
The default permissions to use when checking for printing or other permissions.
<sect2>default_priority=A
<label id="defaultpriority">
<p>
The default priority for a print job.
<sect2>default_remote_host=localhost
<label id="defaultremotehost">
<p>
The default <tt>lpd</tt> server host.
<sect2>default_tmp_dir=/tmp
<label id="defaulttmpdir">
<p>
The default directory for temporary files.
<p>
This option can be used to specify a default
printer. If no value is given (default), the first printer in the
printcap file will be used when no printer is specified.
<sect2>domain_name=domain.name
<p>
You will only need to set this if LPRng can't determine your
hosts domain name itself.
This is usually a desperation option when DNS or some other
database system is not available.
The value of the $USER environment variable will be used as the return address.
<sect1>The Record Queue Name qq and force_queuename flags
<label id="qq">
<label id="usequeuename">
<label id="forcequeuename">
<p>
Options used:
<itemize>
<item> <tt>qq</tt><em>&nbsp;&nbsp;Insert queue name into control file</em>
<item> <tt>use_queuename</tt><em>&nbsp;&nbsp;(alias for qq)</em>
<item> <tt>force_queuename=</tt><em>&nbsp;Queuename to be used</em>
</itemize>
<p>
The printcap information consists of the printer name and aliases;
when a job is spooled to a printer alias,
it is actually spooled to the main printer entry.
<p>
The
<tt>qq</tt>
use queuename option or its
alias
<tt>use_queuename</tt>
tells
LPRng to record the queue name that a job was queued to,
and make it available to other software for processing.
The
<tt>force_queuename=...</tt>
entry forces this name to be used.
This capability has some interesting possibilities,
as shown below.
<tscreen>
<verb>
pr1_landscape|pr1_portrait|pr_raw:lp=pr@host:qq
</verb>
</tscreen>
<p>
If a job is printed using
<tt>lpr -Ppr1_landscape</tt>,
then
<tt>pr1_landscape</tt>  will be recorded as the spool queue name
by the LPRng software.
<p>
Later,
when the job is processed by a filter,
the filter will be invoked with a
<tt>-Qpr1_landscape</tt>
command line option.
The filter can use the name of the queue to enable say,
landscape,
portrait,
or raw
orientations.
<tscreen>
<verb>
john|tom|frank:lp=pr@host:force_queuename=office
</verb>
</tscreen>
<p>
This printcap entry forces the queuename to be <tt>office</tt>;
this information could be used by a central routing facility to
process the information is a suitable manner.
<sect1>The check_for_nonprintable Flag
<label id="checkfornonprintable">
<label id="ml">
<label id="xt">
<p>
Options used:
<itemize>
<item> <tt>check_for_nonprintable</tt><em>&nbsp;&nbsp;LPR checks for non-printable file </em>
<item> <tt>ml=</tt><em>&nbsp;&nbsp;minimum number of printable characters </em>
</itemize>
<p>
Normally, <tt>lpr</tt>
checks an <tt>f</tt> format file
for non-printable characters (i.e., escape characters) at the start
of the print file.
Disabling this check allows you to print executable files,
etc., which can cause extreme abuse of your printer.
<p>
Disabling can be done on a single printcap basis,
or you can do this on a global basis by modifying the
configuration information (see
<ref id="lpdconf" name="lpd.conf">).
<p>
The <tt>ml</tt> value specifies the number of characters that
are to be checked.
Clearly,  if it is 0, none will be checked.
<sect1>The rg Restrict Use to Group Members Option
<label id="rg">
<p>
Options used:
<itemize>
<item> <tt>rg=</tt><em>Restricted group list</em>
</itemize>
<p>
The <tt>rg</tt> value specifies a list of groups.
If this value is present use of a printer or operation is restricted to only
users in a particular group.
<p>
This was a wimpy attempt to do restrictions on print facilities.
The -Ppr@host option overrides this check,
unless the <tt>rg</tt> value is put in the LPRng defaults.
<p>
However,
it does provide a simple tool to have clients do some form of permissions
checking that only the <tt>lpd</tt> server could normally do.
<sect1>The fx Allowed Formats Option
<label id="fx">
<p>
Options used:
<itemize>
<item> <tt>fx=</tt><em>supported formats for printing</em>
</itemize>
<p>
The <tt>fx</tt> option restricts the formats supported by
a spool queue.
The <tt>lpr</tt> program uses these to check if a requested format
is supported.
By default, all formats are supported.
<sect1>Fixing Bad Control Files and Metacharacters
<label id="safechars">
<p>
Options used:
<itemize>
<item> <tt>safe_chars=</tt><em>additional safe characters for control file </em>
</itemize>
<p>
RFC1179 defines a simple protocol and standard for print jobs to be
interchanged between print spooling systems.
Unfortunately,
there were some major mistakes in not specifying the exact form
that text would take when placed in the control file.
<p>
In addition,
there are some simple coding errors that have been made,
but due to their wide distribution in major vendors software,
need to be accommodated.
See
<ref id="reverselpqformat" name="reverse_lpq_format">
for an example.
<p>
By default,
LPRng will brutally convert a non-conforming RFC1179 control file
into one that is acceptable to most,
if not all,
existing RFC1179 implementation.
<p>
In order to prevent problems with 
LPRng ruthlessly purges all characters but
upper and lower case letters,
spaces, tabs, and <tt>-_.@/:()=,+-%</tt> from the control file,
replacing suspicious characters with '_'.
<p>
For some installations,
the default set of safe characters may be overly restrictive.
For example,
<em>vintage</em> software may generate files with <tt>#</tt> characters
in the <tt>J</tt> line of the control file.
The replacement of this character may cause other things to stop
working.
<p>
The <tt>safe_chars</tt> option allows the user to specify an additional
set of safe characters in the <tt>lpd.conf</tt> configuration file(s).
For example, <tt>safe_chars=#"</tt> would allow the
<tt>#</tt>
and
<tt>"</tt>
characters to appear in the control file.
<p>
In addition,
LPRng will ruthlessly regenerate control file entries and data file names
so that they are compliant with all known RFC1179 implementations.
<sect1>Using the bk Option and Control File Filters
<label id="bk">
<label id="controlfilterbk">
<p>
Options:
<itemize>
<item> <tt>bk</tt><em>&nbsp;&nbsp;Berkeley compatible control file</em>
<item> <tt>control_filter=</tt><em>Control file filter</em>
</itemize>
<p>
One of the more serious problems is when a print spooler (LPR) program
does not generate print jobs in a manner compatible with a remote system.
<p>
While LPRng performs checks for improper implementations of RFC1179,
it will try to accept a job
even under the most severe abuse of the protocol.
However,
other spoolers are not so forgiving.
<p>
Some spoolers require that the contents of the control file
be in <bf>exactly</bf> the order that the original 1988 BSD LPR software
generated them.
While some entries can be missing,
all the entries present in the file must be in an explicit order.
<p>
The <tt>bk</tt> (Berkeley LPD compatible control file) option
causes LPR and LPD to reformat the control file,
removing objectionable entries.
The control file of a job being sent to
a remote printer will have its control file entries restricted to
letters in (and the same order) as  HPJCLIMWT1234.
<p>
However,
there are some very odd commercial implementations that require
<em>more</em> information than is present.
To assist with this,
the <tt>control_filter</tt> option can be used.
This specifies a program that will process the control file
before it is sent to a remote destination.
See
<ref id="secfilter" name="Filters"> for details on filter
operation,
and
<ref id="controlfilter" name="Control Filters"> for details on the
point during job processing when the
<tt>control_filter</tt> 
is used.
<p>
The <tt>control_filter</tt> program is run with the standard set of filter options.
STDIN is attached to the control file and
the STDOUT will be used as the control file value
sent to the remote host.
<p>
The
<tt>control_filter</tt>
can rewrite the control file.
The only restriction is that it cannot modify the
<bf/names/ or delete datafiles.
Here is a small snip of PERL code that shows how to
rewrite the control file:
<tscreen>
<verb>
# you need to get PERL to do a 'dup' call on FD 0
$status = 0;
@cf_lines = &lt;STDIN>;
# mess about with the control file
foreach $line (@cf_lines) &lcub;
   # or whatever you want
   print STDOUT $line;
&rcub; 
exit $status;
</verb>
</tscreen>
<p>
The exit code of the
<tt>control_filter</tt>
is used to determine whether to proceed in processing.
See
<ref id="errorcodes" name="Errorcodes"> for details.
<sect1>Maximum Copies
<label id="mc">
<p>
Options used:
<itemize>
<item> <tt>mc#</tt><em>maximum copies </em>
</itemize>
<p>
The <tt> mc</tt> value specifies the maximum number of
copies of a job that can be printed on a printer using the
<tt>lpr -Knn </tt> or
<tt>lpr -#nn </tt> option.
<sect1>The minfree Minimum Spool Queue Space Option
<label id="minfree">
<p>
Options used:
<itemize>
<item> <tt>minfree=</tt><em>Size in Kbytes</em>
</itemize>
<p>
If this value is non-zero,
then the <tt>lpd</tt> receiving server checks to see that there is the
specified number of Kbytes of file space available before
accepting a job.
<sect1>Debugging
<label id="db">
<label id="fulltime">
<label id="mstimeresolution">
<label id="syslogdevice">
<label id="usedate">
<label id="useinfocache">
<p>
Options used:
<itemize>
<item> <tt>debugging=</tt><em>debugging options</em>
<item> <tt>full_time</tt><em>&nbsp;&nbsp;full or extended time format</em>
<item> <tt>ms_time_resolution</tt><em>&nbsp;&nbsp;millisecond time resolution</em>
<item> <tt>syslog_device=</tt><em>syslog alternative device</em>
<item> <tt>use_date</tt><em>&nbsp;&nbsp;put date information in control file</em>
<item> <tt>use_info_cache</tt><em>&nbsp;&nbsp;cache printcap and other information</em>
</itemize>
<p>
The LPRng software has a very powerful debugging capability.
Since most printing problems occur on remote systems where it is impossible
to run debuggers,  and since most systems do not do core dumps of SETUID ROOT
programs,
the LPRng software provides a very verbose set of log file trace messages.
<p>
First,
serious errors or other information are logged using the
<em>syslog()</em> facilities.
If these are not present on a system,
then the messages are logged to the device specified by
<tt>syslog_device</tt>.
<p>
For client programs, the debugging options are specified on the command
line and output is directed to STDERR.
For the <tt>lpd</tt> server,
debugging commands can be specified on the command line OR as the
<tt>db=options</tt> printcap value.
Output is directed to the log file (<tt>lf</tt> option value, default log).
<p>
A typical debug entry has the format <tt>2,network+1,database</tt>.
This sets the general
debugging level to 2, network debugging to 1 and the database debugging level
to the default.  The following debugging options and levels are supported.
<itemize>
<item>nnn - general purpose debugging level
<item>network - network debugging
<item>database - database debugging
<item>receive - job or command reception debugging
<item>print - detailed job printing debugging
</itemize>
<p>
The <tt>full_time</tt> flag forces the logging and other information
which has timestamps to have a full (year, month, day, etc.) timestamp.
The
<tt>ms_time_resolution</tt> flag forces millisecond time resolution
in the time stamp.
The
<tt>use_date</tt> flag forces a date value to be placed in a control file
if there is none.
<p>
The <tt>use_info_cache</tt> (default ON) causes <tt>lpd</tt>
to cache printcap and configuration information.
This is desirable except when trying to change values in printcap files and
test the results.
By using <tt>use_info_cache@</tt> in the configuration information,
you can get immediate responses.
Also, see
<ref id="lpcreread" name="lpc reread">
for another method.
<sect1>LPD Specific
<label id="ipv6">
<label id="lockfile">
<label id="spooldirperms">
<label id="spoolfileperms">
<label id="spreadjobs">
<label id="reportserveras">
<p>
Options used:
<itemize>
<item> <tt>ipv6</tt><em>&nbsp;&nbsp;use IPV6 Network facilities </em>
<item> <tt>lockfile=</tt><em>lpd server lock file</em>
<item> <tt>report_server_as=</tt><em>server name for status reports</em>
<item> <tt>spool_dir_perms#</tt><em>spool directory permissions </em>
<item> <tt>spool_file_perms#</tt><em>spool file permissions </em>
<item> <tt>spread_jobs#</tt><em>job number spread</em>
</itemize>
<p>
These options are usually LPD specific.
For example,
the <tt>ipv6</tt> specifies that the IPV6 protocol,
rather than IPV4 will be used.
In future versions,  this may not be necessary.
<p>
The <tt>lockfile</tt> specifies the location of the
lock file used by the <tt>lpd</tt> server.
This file has the <tt/lpd_port/ value appended to form a unique
lock file name.
<p>
The <tt>spool_dir_perms</tt> and <tt>spool_file_perms</tt>
(default 0700 and 0600 respectively)
values are the (numeric) permissions for the spool directory and
spool files.
<p>
The <tt>spread_jobs</tt> option is obsolete.
The <tt> spread_jobs</tt> option was a desperation fix to handle
difficulties with the arrival of a large number of jobs with the same or
close job number.  The LPD server would fork children,
each of whom tried to lock the job files.  The spread value randomly
chose a new number in the range about the original job number.
However,
it is still preserved for legacy systems which still have problems with
file locking.
<p>
The <tt>report_server_as</tt> option allows an administrator to
masquerade a server with another name.
This could be useful if various load sharing activities are
being carried out,  or if there are problems reconfiguring DNS
to cause the correct server name to be reported.
<sect1>Legacy Compatibility
<p>
The following arguments have been provided for compatibility with
legacy systems.
<sect2>The allow_duplicate_args Option
<label id="allowduplicateargs">
<p>
Options used:
<itemize>
<item> <tt>allow_duplicate_args</tt><em>&nbsp;&nbsp;allow lpr to have duplicate arguments </em>
</itemize>
<p>
Some users would like duplicate LPR and LPRM command line
arguments to override earlier ones,
i.e. -
<tt>lpr -a x -a y </tt> should be equivalent to
<tt>lpr -a y</tt>
<p>
The <tt>allow_duplicate_args</tt> option
allows the various client programs to have duplicate arguments.
The last specified argument on the command line will override
previous values.
<sect2>The class_in_status Options
<label id="classinstatus">
<p>
Options used:
<itemize>
<item> <tt>class_in_status</tt><em>&nbsp;&nbsp;show class name in status</em>
</itemize>
<p>
Setting the <tt>class_in_status</tt> option causes the class name rather
than priority to be displayed in the status information.
<sect2>The reverse_lpq_format Option
<label id="reverselpqformat">
<p>
Options used:
<itemize>
<item> <tt>reverse_lpq_format=</tt><em>&nbsp;reverse LPQ status format for specified remote systems</em>
</itemize>
<p>
Various Solaris and other System V implementations support an RFC1179 interface
to remote printers.
Unfortunately,  there is a problem in that when they send a status request,
the status format is reversed.
That is,
when LONG status format is wanted,
they send SHORT,
and vice versa.
<p>
The <tt>reverse_lpq_format=</tt> specifies a list of printers or IP addresses
for which the <tt>lpd</tt> server will return LONG status when SHORT is
requested,
and vice versa.
For example:
<tscreen>
<verb>
reverse_lpq_format=*.eng.com,130.192.0.0/16
</verb>
</tscreen>
<p>
will cause hosts whose Fully Qualified Domain Name (FQDN) ends in
<tt>eng.com</tt> or from subnet <tt>130.192.0.0</tt> to have reversed
status returned.
<sect2>The return_short_status and short_status_length Options
<label id="shortstatuslength">
<label id="returnshortstatus">
<p>
Options used:
<itemize>
<item> <tt>return_short_status=</tt><em>&nbsp;return short LPQ status for specified remote systems</em>
<item> <tt>short_status_length#</tt><em>&nbsp;short LPQ status length in lines</em>
</itemize>
<p>
In order to be compatible with non-LPRng client programs,
some administrators would like <tt>lpd</tt> to return a short or brief
status to normal status queries.
<p>
The <tt>return_short_status=</tt> specifies a list of printers or IP addresses
for which the <tt>lpd</tt> server will return an abbreviated
status when LONG status is requested.
For example:
<tscreen>
<verb>
return_short_status=*.eng.com,130.192.0.0/16
short_status_length#3
</verb>
</tscreen>
<p>
will cause hosts whose Fully Qualified Domain Name (FQDN) ends in
<tt>eng.com</tt> or from subnet <tt>130.192.0.0</tt> to get only
3 lines of detailed status returned.
<sect2>The force_lpq_status Options
<label id="forcelpqstatus">
<p>
Options used:
<itemize>
<item> <tt>force_lpq_status=</tt><em>&nbsp;force LPQ status format for specified remote systems</em>
</itemize>
<p>
In order to be compatible with non-LPRng client programs which
are totally unpredictable,
this allows the administrator to specify the format for LPQ
status when requests arrive.
<p>
The <tt>force_lpq_status=</tt> specifies a list of formats
and printers or IP addresses
for which the <tt>lpd</tt> server will return status
in the specified format.
The entry has the format
<tt/KEY=list;KEY=list.../ where
<tt/KEY/ is
<tt/s/ for short and
<tt/l/ for long format,
and list is a list of hosts or IP addresses.
For example:
<tscreen>
<verb>
force_lpq_status=s=pc*.eng.com,130.192.12.0/24,l=sun*.eng.com
</verb>
</tscreen>
<p>
will cause hosts whose Fully Qualified Domain Name (FQDN) matches
<tt>pc*eng.com</tt> or from subnet <tt>130.192.12.0</tt> to get short
status returned and hosts which match <tt/sun*.eng.com/ get
long status.
<sect2>The ignore_requested_user_priority and force_fqdn_hostname Options
<label id="ignorerequesteduserpriority">
<label id="forcefqdnhostname">
<p>
Options used:
<itemize>
<item><tt>ignore_requested_user_priority</tt><em>prevent users from queue jumping</em>
<item><tt>force_fqdn_hostname</tt><em>force FQDN hostname in control file</em>
</item>
</itemize>
<p>
Some students... um... users... will request a high priority for their job
in order to jump the queue of waiting jobs.
This option will cause the <tt>lpd</tt> server to ignore the
requested user priority.
However, the <tt>topq</tt> operation will still be effective.
<p>
Similarly,  some print spoolers do not put a FQDN host name in their control file.
The <tt>force_fqdn_hostname</tt> flag will cause <tt>lpd</tt> to put a FQDN
host name in the control file.
This option will assume that the domain is where the connection originated from.
<sect2>The lpr_bsd Options
<label id="lprbsd">
<p>
This will force the <tt>lpr -m</tt> (send mail to user)
option not to take an argument, as in the BSD lpr.
<sect>Job Processing
<label id="jobsteps">
<p>
Much of the flexibility of the LPRng software is obtained
from the ability to control the details of each step of job processing.
The following section details each step in the processing of a job,
and explains the printcap options used to control each operation.
<p>
Assume the <tt>pr</tt>
printcap entry has the form:
<tscreen>
<verb>
pr
    :lp=/dev/lp  OR  :lp=rp@rm
    :sd=/var/spool/lpd/pr
    :lf=log
    :of=/usr/local/bin/lpf
    :if=/usr/local/bin/lpf
</verb>
</tscreen>
<p>
Assume that we have used the following command to print
a set of files.
<tscreen>
<verb>
lpr -Ppr file1 file2
</verb>
</tscreen>
<p>
This will create a control file
in the
<tt>/var/spool/lpd/pr</tt>
directory with the following contents (this is an example -
in practice there may be minor differences between the example
and an actual control file):
<tscreen>
<verb>
Hastart4.astart.com
J/tmp/file1 /tmp/file2
CA
Lpapowell
Ppapowell
fdfA002230astart4.astart.com
N/tmp/file1
UdfA002230astart4.astart.com
fdfB002230astart4.astart.com
N/tmp/file2
UdfB002230astart4.astart.com
</verb>
</tscreen>
<p>
<sect1>Opening the Output Device
<label id="achk">
<label id="af">
<label id="as">
<label id="ff">
<label id="fo">
<label id="lk">
<label id="lpdev">
<label id="la">
<label id="ar">
<label id="ld">
<label id="rw">
<label id="connectgrace">
<label id="networkconnectgrace">
<label id="connectinterval">
<label id="connecttimeout">
<label id="connecttry">
<label id="controlfilter">
<label id="nb">
<label id="servertmpdir">
<p>
Options used:
<itemize>
<item> <tt>achk</tt><em>&nbsp;&nbsp;Accounting check at start</em>
<item> <tt>af=</tt><em>Accounting File</em>
<item> <tt>ar</tt><em>&nbsp;&nbsp;Remote printer accounting enabled</em>
<item> <tt>as=</tt><em>Accounting at start</em>
<item> <tt>connect_grace#</tt><em>&nbsp;&nbsp;Time between jobs</em>
<item> <tt>connect_interval#</tt><em>&nbsp;&nbsp;Connection interval</em>
<item> <tt>connect_timeout#</tt><em>&nbsp;&nbsp;Connection timeout</em>
<item> <tt>control_filter=</tt><em>Control file filter</em>
<item> <tt>ff</tt><em>&nbsp;&nbsp;form feed</em>
<item> <tt>fo</tt><em>&nbsp;&nbsp;form feed on open</em>
<item> <tt>la</tt><em>&nbsp;&nbsp;Local printer accounting enabled</em>
<item> <tt>ld=</tt><em>leader on open (initialization string)</em>
<item> <tt>lk</tt><em>&nbsp;&nbsp;Lock IO device</em>
<item> <tt>lp=</tt><em>IO device pathname</em>
<item> <tt>nb</tt><em>&nbsp;&nbsp;Nonblocking device open</em>
<item> <tt>network_connect_grace#</tt><em>&nbsp;&nbsp;Time between jobs</em>
<item> <tt>of=</tt><em>of filter</em>
<item> <tt>retry_econnrefused#</tt><em>&nbsp;&nbsp;Retry if open failed</em>
<item> <tt>retry_nolink#</tt><em>&nbsp;&nbsp;Retry if open failed</em>
<item> <tt>rm</tt><em>&nbsp;&nbsp;the remote machine to send the job to</em>
<item> <tt>rp</tt><em>&nbsp;&nbsp;the remote print queue to send the job to</em>
<item> <tt>rw</tt><em>&nbsp;&nbsp;device opened RW flag</em>
<item> <tt>server_tmp_dir=</tt><em>temporary directory</em>
</itemize>
Sequence of Operations:
<enum>
<item>
During the server operations,
it will try to create temporary files in the print queue spool directory.
If this is not desirable,
it will create them in the <tt>server_tmp_dir</tt> directory.
<item>
If the accounting file specified by
<tt>af</tt>
exists,
it is opened (af_fd) and the af_fd is passed as file descriptor
3 to all filters.
If the <tt>af</tt> value has the form <tt>af=|/program</tt>
then the program is started and the program STDIN is used as af_fd.
If the <tt>af</tt> value has the form <tt>af=host%port</tt>,
then a TCP/IP connection to the corresponding port on the remote host
is made and the port used as af_fd.
In the latter two cases,  the filter STDIN (file descriptor 0)
is actually opened read/write, and is used when information is needed
from the accounting filter or remote server.
See
<ref id="accountingserver" name="Accounting Printcap Options">
for more information on the LPRng accounting support.
<item>
<label id="accountstart">
If <tt>la</tt> (local accounting) is true and we are printing a job
or <tt>ar</tt> (remote accounting) is true and we are transferring a job,
the <tt>as</tt> value is examined.
If it is a filter (program) specification,
then the program is started with its STDIN attached to
<tt>/dev/null</tt>, STDOUT will be read by the print spooler,
STDERR output will be written to the error log,
and file descriptor 3 output will be appended to the accounting file.
The lpd program will wait until the accounting filter program terminates,
and examine the error code for action, as for the filters
(see
<ref id="errorcodes" name="errorcodes"> below).
If the exit status is 0,
(JSUCC) then the printing process will continue,
if JHOLD the job will be held,
if JREMOVE the job will be removed,
if JFAIL the job processing will terminate with a JFAIL indication,
otherwise
the job processing will terminate with a JABORT indication.
<item>
If the accounting filter exited with a JSUCC (no error code)
and the <tt>achk</tt> (accounting check) flag is set, 
the line read from the accounting filter STDOUT will be examined.
This line should be
<tt>accept</tt>,
<tt>hold</tt>,
<tt>fail</tt>,
<tt>remove</tt>,
otherwise the job processing terminates with a JABORT indication.
An <tt>accept</tt> will allow the job to be printed,
<tt>hold</tt> will hold the job,
<tt>fail</tt> will cause the job to fail,
<tt>remove</tt> will cause the job to be removed.
<item>
If the
<tt>connect_grace</tt>
value is non-zero and the server is opening a device or
<tt>network_connect_grace</tt> is non-zero and a network connection
is being made,
the server will pause the specified time.
This is to accommodate devices which need a recovery time between jobs.
<item>
The <tt>lp</tt> option is checked to determine the type of IO device.
<table>
<tabular ca="|l|l|">
Format
|
Meaning
@
<tt>/pathname</tt>
|
Absolute pathname of IO device
@
<tt>pr@host</tt>
|
transfer to <tt>pr</tt> on remote <tt>host</tt>
@
<tt>host%port</tt>
|
open a TCP/IP connection to port on host.  host can be name or IP address
@
<tt>|filter</tt>
|
run the filter program; it STDIN will be used as device
@
</tabular>
</table>
<item>
The IO device specified by
<tt>lp</tt> is opened write-only or read-write if the
<tt>rw</tt>
flag is true, and the resulting file descriptor is io_fd.
If the <tt>nb</tt> flag is set,
a non-blocking open will be done as well.
If the <tt>lk</tt> (lock device) flag is true,
the device will be locked against use by other LPD servers.
<item>
If a <tt>host%port</tt> combination,
a TCP/IP connection will be opened to the remote port and the connection will
be used as io_fd.
<item>
If a filter program is specified,
the filter program will be run and the STDIN of the filter will be
used as the device file descriptor.
<item>
If a <tt>rp@rm</tt> combination,
or none of the above combinations are true and the
<tt>rm</tt> and <tt>rp</tt> values are non-zero,
then the job will be transferred to a remote printer.
The type of operation will be a job transfer,
rather than printing operation.
<item>
If the <tt>connect_timeout</tt> value is non-zero,
a timeout is setup for the device or socket open.
If the device or connection open does not succeed within the timeout,
then the open operation fails.
<item>
If a connection is to a network address
(i.e. - <tt>connect()</tt> system call)
and the connection attempt fails with an <tt>ECONNREFUSED</tt>
error,
if the <tt>retry_econnrefused</tt>
flag is set then the connection attempt is retried,
but this time using an alternative port number.
See
<ref id="rfc1179ref" name="RFC1179"> for details.
This is repeated until all of the possible originating port numbers
are exhausted.
<item>
If the open or connect operation fails,
and the <tt>retry_nolink</tt> flag is set,
then the server will pause for a minimum of
<tt>connect_grace</tt> plus a multiple of
<tt>connect_interval</tt> seconds
based on the number of attempts
before retrying the open operation.
Note that the interval may increase as the number of attempts
increases.
<item>
If printing a job and the
<tt>of</tt> filter is specified,
it is created with its STDOUT (fd 1) attached to the io_fd.
Its stdin (of_fd) will be used in the steps listed below.
If there is no
<tt>of</tt> filter,
then the of_fd value will be the io_fd descriptor.
<item>
If transferring a job and the <tt>control_filter</tt> option is specified,
then the program specified by the <tt>control_filter</tt>
value will be run. It will have its STDIN set to the control file,
and its STDOUT output will be used as the new value of the control file
to transfer to the remote host.
See
<ref id="filtercmd" name="Filter Command Line Flags">
for details of options passed to the control filter,
and
<ref id="errorcodes" name="errorcodes"> for the exit codes of the filter.
<item>
If the operation is a job transfer, the operation proceeds as outlined in
<ref id="rfc1179ref" name="RFC1179">,
and then the
<ref id="normalterm" name="Normal Termination"> operations are
carried out.
<item>
If the operation is a print operation
and the
<tt>ld</tt> (leader on open) value is provided,
the string
is translated (escapes removed)
and written to the of_fd file descriptor.
<item>
If the
<tt>fo</tt> (form feed on open) flag is true, then the
<tt>ff</tt> (form feed) string
is translated (escapes removed)
and written to the of_fd file descriptor.
</enum>
<sect1>Printing Banner At Beginning
<label id="ab">
<label id="hl">
<label id="be">
<label id="bl">
<label id="bp">
<label id="bs">
<label id="sb">
<label id="sh">
<label id="of">
<label id="bannerprinting">
<label id="generatebanner">
<p>
Options used:
<itemize>
<item> <tt>ab</tt><em>&nbsp;&nbsp;Always print banner (default FALSE)</em>
<item> <tt>be=</tt><em>End banner generator program</em>
<item> <tt>bl=</tt><em>Short banner line format</em>
<item> <tt>bp=</tt><em>Banner generator program</em>
<item> <tt>bs=</tt><em>Start banner generator</em>
<item> <tt>generate_banner</tt><em>&nbsp;&nbsp;Generate banner for forwarded jobs</em>
<item> <tt>hl</tt><em>&nbsp;&nbsp;Banner (header) Last</em>
<item> <tt>of=</tt><em>Banner and File Separator Filter</em>
<item> <tt>sb</tt><em>&nbsp;&nbsp;Short banner (default FALSE)</em>
<item> <tt>sh</tt><em>&nbsp;&nbsp;Suppress header (banners) (default FALSE)</em>
</itemize>
<p>
Banner printing is one of the more complicated configuration options
of LPRng.
This is due mainly to historical evolution of the software,
as well as a lack of a well defined standard for
filter responsibilities.
In the original BSD print spoolers,
the philosophy was that banner printing should be delegated to the
filters,
as they were the most aware of the capabilities of the printers.
This required an
<em/out of band/
method to convey banner printing information to the filter,
and resulted in a complicated interface.
The original interface was:
<enum>
<item>
The filter doing banner printing was invoked as a special
<tt/of/ filter,
or passed a special flag.
<item>
The print spooling software would send a special
<bf>single line</bf>
of information telling it what the banner information should be.
Note that this line was never documented except for the source code,
and was inconsistent from version to version.
Also,
there was no indication of what to do with additional lines,
if any.
<item>
The filter would generate the banner,
discard the line,
and then pass other lines to the output device.
</enum>
<p>
Adding to the confusion,
the original print spoolers had a <tt/:sh/ (suppress header or banner)
flag,
which was supposed to suppress banner printing.
It did this by having the print spooler not generate the magic banner
information line.
<p>
A more sophisticated banner printing system would allow the
print spooler software to generate the banner,
and would then have the <tt/of/ filter act as a pass through.
Thus, we need configure the <tt/of/ filter NOT to use the first
line as banner printing information,
and to pass through all information to the device.
<p>
Complicating this whole mess is the
<tt/ld/  (leader option)
and
<tt/tr/  (trailer option)
which is a string sent to the output device (<tt/of/ filter)
when the device (filter) is initialized or terminated.
This can sometimes be interpreted as the banner line,
leading to unexpected results.
<p>
Sequence of Operations:
<enum>
<item>
If the
<tt>sh</tt> (suppress header) flag is true, no banner is
printed,
and the actions in this section are skipped.
No <it/banner information line/
is generated for the <tt/of/ filter,
and no banner printing program is invoked.
If the is an <tt/of/ filter and if it is expecting such a line
and you have <tt/ld/ or <tt/tr/ information
you may get unexpected results
(actually, catastrophic failure is a better term, but I digress).
<item>
If the <tt>hl</tt> (header last) flag is true the banner is printed at the end
of the job
and the actions in this section are done at the end of the job.
<item>
If the user does not want banner pages she can use the
<tt/lpr -h / option.
This will cause the <tt/lpr/ program
to delete the <tt>L</tt> (banner name) line in the control file.
If there is no <tt/L/ line in the control file
and
<tt>ab</tt> (always print a banner) is false
(the default),
then no banner is printed
and the other actions in this section are skipped.
If
<tt>ab</tt> is true
and the <tt/L/ line is missing then the <tt/N/ (user login name) is used;
if it is missing as well,
then ANONYMOUS is used for the user name.
<item>
If a banner printing program is specified by <tt/bp/, tt<tt/bs/,
or <tt/be/ options,
then LPRng will invoke the
program to generate a banner and then send the generated
banner to the printer
via the <tt/of/ filter.
The banner printing program will be invoked using
the standard filter command line flags
(see
<ref id="filtercmd" name="Filter Command Line Flags">
for details),
with is STDIN attached to /dev/null
and STDOUT attached to a file to hold the output banner.
<item>
If no banner printing program is specified
and the
<tt/sb/ (short banner) option is TRUE (default is true),
then the <tt/bl=.../ (banner line) option value
is expanded and sent to the <tt/of_fd/  (<tt/of/ filter or
device.
The default <tt>bl</tt> value is:
<tt>bl=$-'C:$-'n Job: $-'J Date: $-'t</tt>.
Using our example, this will get translated to:
<tscreen>
<verb>
papowell:A Job: file1 file2 Date: Thu Nov 27 23:02:04 PST 1997
</verb>
</tscreen>
<item>
If no banner printing program is specified and we have <tt/sb@/
(no short banner)
then we skip banner generation,
i.e. - we do <em/not/ send a banner generation line
to the output (<tt/of/ filter).
<item>
If the queue is a normal forwarding queue,
then the
<tt>generate_banner</tt>
option will invoke the
<tt/bp/, <tt/bs/ or <tt/be/
program as appropriate to create a banner page file which is then made the
first (default) or last (<tt/hl/ flag or <tt/be=.../ present)
file in a job.
This option has no effect in other types of queues.
See the <tt><ref id="translateformat" name="translate&lowbar;format"></tt>
option as well.
</enum>
<sect1>Printing Job Files
<label id="sendjobrwtimeout">
<label id="sendqueryrwtimeout">
<label id="sf">
<label id="format">
<p>
Options used:
<itemize>
<item> <tt>Xf=</tt><em>Format Filter</em>
<item> <tt>if=</tt><em>Default F Format Filter</em>
<item> <tt>pr=</tt><em>pr formatting program</em>
<item> <tt>send_job_rw_timeout=</tt><em> print job read/write timeout </em>
<item> <tt>send_query_rw_timeout=</tt><em> status query operation read/write timeout </em>
<item> <tt>sf</tt><em>&nbsp;&nbsp;Suppress FF Print File Separators</em>
</itemize>
<p>
Sequence of Operations:
for each job in listed in the control file,
the following operations are done in turn.
<enum>
<item>
If there is an <tt>of</tt> filter present,
the suspend string <tt>\031\001</tt> is written to of_fd
and the no further action is taken until the of filter is suspended.
<item>
The control file line for the job is examined,
and the first letter of the data file specification is used as the format.
<item>
If the format is
<tt>p</tt>,
the job is first processed by the program specified by the
<tt>pr</tt>
program,
and the program output used as the print file.
<item>
If the format is
<tt>f</tt>,
<tt>l</tt>,
or
<tt>p</tt>
then the <tt>if</tt> filter is used,
otherwise the keyword
<tt>Xf</tt> is used.
Note that certain formats such as
<tt>p, a, l</tt>, may not be used as formats.
<item>
The filter program is started with an appropriate set of command line options
(see
<ref id="filtercmd" name="Filter Command Line Flags">),
and with its STDOUT attached to the printing device (io_fd),
STDERR to a pipe which results in the output being written
to the status file,
and file descriptor 3 to the accounting file or program.
If debugging is enabled,
then the STDERR output is also written to the error log file (lf).
<item>
When doing a read/write operation to a device or remote system,
a timeout can be specified.
When doing a print or job transfer operation,
the <tt>send_job_rw_timeout</tt> value is used.
When doing a status or query operation,
the <tt>send_query_rw_timeout</tt> value is used.
If a write or write operation does not complete within
the specified timeout seconds, then we have an error
condition and job processing or the query operation
is terminated with JFAIL status.
If the timeout value is 0, then no timeout is done.
<item>
<label id="errorcodes">
<tt>lpd</tt> will then wait for the filter to exit.
The exit status can be as follows:
<tscreen>
<verb>
Key      Value   Meaning
JSUCC    0       Successful
JFAIL    1, 32   Failed - retry later
JABORT   2, 33   Abort - terminate queue processing
JREMOVE  3, 34   Failed - remove job
JHOLD    6, 37   Failed - hold this job
Other            Abort - terminate queue processing
</verb>
</tscreen>
<item>
If the filter exit status was JSUCC (0), or no error indicated,
then processing will continue otherwise the job termination takes
(see
<ref id="termination" name="Abnormal Termination">).
<item>
If the <tt>of</tt> filter is present,
then it is reactivated with a <tt>kill -CONT</tt> signal.
<item>
If the <tt>sf</tt> (suppress FF print file separators ) is false,
then the
<tt>ff</tt> (form feed) string
will be interpreted and sent to the of_fd.
</enum>
<sect1>Printing Banner At End
<p>
Options used:
<itemize>
<item> <tt>hl</tt><em>&nbsp;&nbsp;Header (Banner) Last</em>
</itemize>
<p>
The actions taken in this step are identical to those for the
<ref id="bp" name="Printing Banner At Beginning">,
with the exception that the
<tt>be</tt> (end banner program) is used to select the banner generation program
rather than the
<tt>bs</tt> (start banner program).
<p>
If we have <tt/hl/ true,
then we print a banner at the end of the job,
rather than start.
<p>
<sect1>Normal Termination
<label id="ae">
<label id="fq">
<label id="savewhendone">
<label id="tr">
<label id="normalterm">
<label id="waitforeof">
<label id="exitlingertimeout">
<p>
Options used:
<itemize>
<item> <tt>fq</tt><em>&nbsp;&nbsp;Form Feed on Close</em>
<item> <tt>la</tt><em>&nbsp;&nbsp;Local Printer Accounting</em>
<item> <tt>tr=</tt><em>Trailer on Close</em>
<item> <tt>ae=</tt><em>Accounting at end</em>
<item> <tt>save_when_done</tt><em>&nbsp;&nbsp;Save when done</em>
<item> <tt>wait_for_eof</tt><em>&nbsp;&nbsp;Wait for EOF before closing device</em>
<item> <tt>exit_linger_timeout</tt><em>&nbsp;&nbsp;connection linger on close timeout</em>
</itemize>
<p>
Sequence of Operations:
<enum>
<item>
If we are printing and the <tt>fq</tt> flag is set and the
<tt>sf</tt> (suppress interfile FF) flag is set,
then the
<tt>ff</tt> (form feed) string
will be interpreted and sent to the of_fd.
<item>
If we are printing, the <tt>tr</tt> (trailer) string
will be interpreted and sent to the of_fd.
<item>
If printing and the <tt>la</tt> (local printer accounting) flag is set
or transferring a job and the <tt>ar</tt> (remote accounting) flag is set,
the
<tt>ae</tt> is examined and accounting is done as described
for the
<tt><ref id="accountstart" name="as"> field.</tt>
<item>
If the <tt>of</tt> filter is present,
its STDIN is closed,
and the <tt>lpd</tt> server waits for it to exit.
The exit status is used as described above.
<item>
If the device is a socket or network connection,
the socket linger time is set to
<tt/job_send_rw_timeout/ value if nonzero or the
<tt/exit_linger_timeout/ value if nonzero,
a write <tt/shutdown/ is done,
and if the <tt/wait_for_eof/ option is true (default)
then a read is done on the connection until an EOF is found.
The device (io_fd) is then closed.
<item>
The job is marked as completed in the spool queue.
<item>
If the <tt>save_when_done</tt> flag is not specified,
the job is removed.
</enum>
<sect1>Abnormal Termination
<label id="saveonerror">
<label id="sendtry">
<label id="sendfailureaction">
<label id="mailfrom">
<label id="mailoperatoronerror">
<label id="sendmail">
<label id="stoponabort">
<label id="maxconnectinterval">
<label id="termination">
<p>
Options used:
<itemize>
<item> <tt>mail_from=</tt><em>Mail from user name</em>
<item> <tt>mail_operator_on_error=</tt><em>Mail to operator on error</em>
<item> <tt>send_try#</tt><em>&nbsp;&nbsp;Maximum Print or Transfer Attempts</em>
<item> <tt>save_on_error</tt><em>&nbsp;&nbsp;Do not delete on error</em>
<item> <tt>send_failure_action=</tt><em>Action on Failure</em>
<item> <tt>sendmail=</tt><em>sendmail path name and options</em>
<item> <tt>stop_on_abort</tt><em>&nbsp;&nbsp;Stop processing queue on filter abort</em>
</itemize>
<p>
If the job processing terminates abnormally,
the following sequence of events occurs:
<enum>
<item>
The job is marked as having an error during processing.
<item>
The LPD server will attempt to kill all filters and other associated process
by using a sequence of
<tt>kill -INT</tt>,
<tt>kill -QUIT</tt>,
and finally
<tt>kill -KILL</tt> operations.
<item>
If there is a <tt>mail_operator_on_error</tt> value,
the specified operator will be mailed an error indication.
The <tt>sendmail</tt> option specifies the pathname of the
<em>sendmail</em> program and the options needed to have it read
mail addresses from its standard input.
For example, <tt>sendmail=/usr/sbin/sendmail -oi -t</tt>
is a commonly used set of options.
<item>
The <tt>mail_from</tt> value specifies the user name used for
mail origination.  If not specified, the default is to use the print spool
queue or printer name.
<item>
If there is a <tt>send_failure_action</tt> specified,
then it is decoded and the corresponding action taken.
If the value is
<tt>remove</tt>,
<tt>hold</tt>,
<tt>abort</tt>,
or
<tt>retry</tt>,
then the job is removed, held, aborted, or retried.
If the value is <tt>|/program</tt>,
the program is executed and
the number of attempts are written to the filter STDIN.
The exit status of the filter will be used to determine the consequent actions.
That is, JSUCC (0) will be success, and the standard success action will
be taken;
JFAIL will cause retry,
JREMOVE will cause the job to be removed,
JHOLD will cause the job to be held,
JABORT or other status will abort processing.
<item>
If the status is ABORT and the
<tt>stop_on_abort</tt>
flag is set,
then further processing of jobs is terminated.
The job is not removed from the queue.
<item>
If the error status indicates removal,
and the <tt>save_on_error</tt> flag is clear
then the job is removed from the spool queue.
<item>
If the error status indicates that no further operations should
be performed on the queue,
then the <tt>lpd</tt> server will stop processing jobs.
<item>
If the error code indicated that the job should be retried,
and the
<tt>send_try</tt> value is 0 or the number of attempts is less than
the <tt>send_try</tt> value,
then the job is retried.
Between each attempt to transfer a job to a remote site.
This pause will double after each attempt,
reaching a maximum of <tt>max_connect_interval</tt> seconds.
If <tt>max_connect_interval</tt> is 0, there is no limit on the interval value.
</enum>
<sect1>LPD Spool Queue Processing
<label id="lpdforcepoll">
<label id="lpdpolltime">
<label id="maxserversactive">
<p>
Options used:
<itemize>
<item> <tt>lpd_force_poll=</tt><em>Force LPD to periodically poll print queues </em>
<item> <tt>lpd_poll_time#</tt><em>Time between polls</em>
<item> <tt>max_servers_active#</tt><em>Maximum number of active servers</em>
</itemize>
<p>
When the <tt>lpd</tt> server starts,
it will fork a set of subserver processes,
each which will handle an individual queue.
<p>
If a system has a large number of queues,
then this forking operation may result in the <tt>lpd</tt> server
exhausting the process resources.
To control this,  the
<tt>max_servers_active</tt> value restricts the number of active
children to the specified value.
If this value is 0,
then 50% of the maximum system processes value will be used.
<p>
Due to the limits on the number of processes,
there may be times when a job is placed in a queue,
but the <tt>lpd</tt> server is unable to start handling the job.
When all of the children of the main <tt>lpd</tt> server have
exited,
the server starts a timer.
After <tt>lpd_poll_time</tt> seconds,  it will scan the queues,
looking for jobs to process,
and starts a process to service them.
If it does not find any jobs it remains idle.
<p>
The <tt>lpd_force_poll</tt> flag causes the server to periodically
poll the queues.
This is useful when there is a high possibility that jobs could fail to be
printed due to high loads on the server.
<sect>Filters
<label id="secfilter">
<p>
This section gives an overview of how LPRng uses filter programs,
and gives a detailed discussion of how the printcap options and
filters interact.
<sect1>What are filters?
<p>
Print filters are one of the most powerful tools in BSD-style printer
systems.
<p>
In general UNIX terms, a <em>filter</em> is a program that takes its input
file(s), does something with it, and sends the result to its standard
output. Most UNIX utilities are designed as filters.
(But since you are a system manager, you should already know that :))
<p>
In the context of a BSD-style print spooler (and also LPRng), the term
<em>filter</em> refers to a program that processes file while it is
being transferred to a printer.
<p>
The filter is executed with STDIN reading from the file to be
printed
STDOUT to the printer device or a temporary file.
STDERR (file handle 2) is redirected to the status file,
and file handle&nbsp;3 to an accounting file or program.
<p>
A filter can be as simple as a <tt>LF</tt> to <tt>CR/LF</tt>
translator,
or it can incorporate a complete
accounting system, automatic file type translations,
or even redirect the job to another printing system.
<p>
As part of the LPRng project,
the following filters are supported.
The are many others available for use,
but are currently not supported.
<itemize>
<item> <ref id="lpf" name="lpf">
a very simple CR/LF or passthrough filter.
<item> <ref id="ifhp" name="ifhp">
HP PCL and PJL printer filters <item>
</itemize>
The supported filters and other facilities are available from
<htmlurl url="ftp://ftp.astart.com/pub/LPRng" name="ftp://ftp.astart.com/pub/LPRng">
<sect1>What are print formats?
<label id="if">
<p>
Options used:
<itemize>
<item>
<tt>if</tt>,
<tt>cf</tt>,
<tt>df</tt>,
<tt>gf</tt>,
<tt>nf</tt>,
<tt>of</tt>,
<tt>rf</tt>,
<tt>tf</tt>,
<tt>vf</tt>,
<em>X</em><tt>f</tt>,
<em>&nbsp;&nbsp;Filter programs </em>
</itemize>
<p>
LPRng has inherited a set of so-called `<bf>print formats</bf>' from its
BSD ancestor.
The format was used to specify the type of file that was being printed.
The <tt>lpd</tt> server
used the print format to select the filter for processing the file.
The de<bf/f/ault format is <tt>f</tt>.
<p>
The user can specify the format (i.e., the file type) by giving
the appropriate option to <tt>lpr</tt>:
<p>
<itemize>
<item>
<tt>-b</tt> or <tt>-l</tt>: Binary (literal) file. No processing should
be done.
The
<tt>l</tt> format is recorded as the file format.
</item>
<item><tt>-c</tt>: cifplot(1) output.</item>
<item><tt>-d</tt>: TeX DVI file.</item>
<item><tt>-g</tt>: Output from the plot(3X) routines.</item>
<item><tt>-n</tt> or <tt>-t</tt>: (di)troff output.</item>
<item><tt>-p</tt>: Text file that should be pre-processed by the <tt>pr</tt>
command, and then by the standard text filter.</item>
<item><tt>-v</tt>: Benson Varian raster image.</item>
</itemize>
<p>
Alternatively, one can also use
<tt>-Fx</tt>, where <tt>x</tt> is the format specifier.
(E.g., <tt>-Fc</tt>
instead of <tt>-c</tt>.)
This last form also allows you to use other
(non-standard) format specifiers.
<p>
The filter for format
<tt>X</tt>
is the value for the
<tt>Xf</tt> printcap
option,
with some minor exceptions.
The following
<tt>Xf</tt>
options have a pre-defined meaning.
<p>
<itemize>
<item>
<tt>if</tt>
The <tt>f</tt>
format filter,
i.e. - for the default
<tt>f</tt>
format.
All print jobs are passed
through this one, unless another format is selected.</item>
<item>
<label id="cf">
<tt>cf</tt> Cifplot data filter (for <tt>-c</tt> format).</item>
<item>
<label id="df">
<tt>df</tt> Filter for DVI files (<tt>-d</tt>).</item>
<item>
<label id="gf">
<tt>gf</tt> Graph data filter (<tt>-g</tt>).</item>
<item>
<label id="nf">
<tt>nf</tt> Ditroff data filter (<tt>-n</tt>).</item>
<item><tt>of</tt> This filter is used for processing the (optional)
banner at the start and/or end of the print job,
and also for the interjob separators.
See
<ref id="ofdetails" name="of"> filter for details.
<item>
<label id="rf">
<tt>rf</tt> Filter for Fortran style files (<tt>-r</tt>).</item>
<item>
<label id="tf">
<tt>tf</tt> Troff filter (<tt>-t</tt>).</item>
<item>
<label id="vf">
<tt>vf</tt> (Versatek) raster image filter (<tt>-v</tt>).</item>
</itemize>
<label id="ofdetails">
<sect1>OF Filter
<p>
The
<tt>of</tt>
filter is used to process banners and job separators.
The
<tt>of</tt> filter is responsible for performing appropriate
processing of this information and sending to the printer
for action.
<p>
While the various file filters are invoked on a once per print file basis,
the
<tt>of</tt>
filter is invoked on a once per print job basis.
<p>
This filter is the first one to be started,
and should perform whatever specialized device initialization
is needed.
It should also do whatever accounting procedure is desired
for start of job accounting.
<p>
The
<tt>of</tt>
filter will be given any banner printing or job separation
information for a job.
As part of its operation,
it can detect a specific string,
corresponding to a banner print request,
and generate a banner.
(See the
<ref id="jobsteps" name="Job Processing Steps and Printcap Options">
for details.)
<p>
During operation,
the
<tt>lpd</tt> server will send the special
<bf>stop</bf> sequence of <tt>\031\001</tt> to the
<tt>of</tt> filter.
The filter must then suspend itself using a
<tt>kill -STOP</tt> operation.
The <tt>lpd</tt> server will detect that the
<tt>of</tt> filter has suspended itself and then
will perform other printing operations.
<p>
After the other printing operations have been completed,
the <tt>of</tt> will then be sent a
<tt>kill -CONT</tt> signal.
<p>
This sequence will continue until all information has been printed,
and then the <tt>of</tt> filter's STDIN will be closed.
The filter will then perform whatever cleanup operations are needed,
update accounting or other information,
and exit.
<sect1>LPR -p format
<label id="pr">
<p>
Options used:
<itemize>
<item><tt>pr=</tt><em>pr program for p format</em>
</itemize>
<p>
The <tt>-p</tt> format is requires filtering the
the input files by the <tt>pr</tt> utility
and then passing the result through the
<tt>if</tt> filter.
<p>
This is widely regarded as a kludge and may not be supported
on your print spooler.
<sect1>LPR binary (-l) format
<p>
The binary (or literal) format is <tt>-l</tt>.
The <tt>if</tt> filter
is used to process the file,
and is invoked with the
<tt>-c</tt>
(<tt>c</tt>ancel processing?) flag.
<p>
The filter will not modify the file when sending it to the printer,
but may apply various setups to the printer.
<sect1>Filter Command Line Flags
<label id="bkfilteroptions">
<label id="bkoffilteroptions">
<label id="bkf">
<label id="filteroptions">
<label id="offilteroptions">
<label id="filterldpath">
<label id="filterpath">
<label id="passenv">
<label id="pl">
<label id="pw">
<label id="px">
<label id="py">
<label id="filtercmd">
<p>
Options used:
<itemize>
<item> <tt>bk_filter_options=</tt><em>Backwards Compatible Filter options</em>
<item> <tt>bk_of_filter_options=</tt><em>Backwards Compatible OF Filter options</em>
<item> <tt>bkf</tt><em>&nbsp;&nbsp;Backwards Compatible Filters</em>
<item> <tt>filter_ld_path=</tt><em>Filter LD_LIBRARY_PATH environment</em>
<item> <tt>filter_options=</tt><em>Filter options</em>
<item> <tt>filter_path=</tt><em>Filter PATH environment</em>
<item> <tt>of_filter_options=</tt><em>OF Filter options</em>
<item> <tt>pass_env=</tt><em>Environment variables to copy to Filter environment</em>
<item> <tt>pl#</tt><em>line count for page</em>
<item> <tt>pw#</tt><em>column count for page</em>
<item> <tt>px#</tt><em>pixel width for page</em>
<item> <tt>py#</tt><em>pixel length for page</em>
</itemize>
<p>
A filter (or program) specification in the LPRng printcap database
usually has the form:
<tscreen>
<verb>
:option=| [flags] /path [argument | "argument" | 'argument' ]*
:option=[flags]   /path [argument | "argument" | 'argument' ]*
</verb>
</tscreen>
<p>
The first case is used where the option value can be a string or filter,
and the second where a program is always expected.
The following procedure is used to run a filter program.
Arguments in single or double quotes are passed as a single value,
as for a shell.
No escape (backslash) support is provided.
<p>
The sequence of operations to run a filter is as follows:
<enum>
<item>
The program must be specified with an absolute path name.
<item>
By default, the program is run as the user if invoked from a client
program such as <tt>lpr</tt>, <tt>lpc</tt>, etc.
If invoked from <tt>lpd</tt>,  it is run as the
<tt>server_user</tt>
user
(default <tt>daemon</tt>) configuration entry.
<item>
The
<em>flags</em> control how the program is to be run.
The following flags are supported:
<itemize>
<item><bf>ROOT</bf>
This opens a horrible security loophole,
as it will run the program as ROOT.
To enable this option,
you must set various compilation flags,
and perform other arcane operations.
This is deliberately done to make administrators
read the warnings and admonitions.
<p>
The alternative to ROOT is to have a setuid ROOT executable.
Under NO circumstances should you run a shell script setuid ROOT,
with general execute permissions on it.
<item><bf>-$</bf>
This very odd looking flag is used to suppress the addition of
additional command line arguments
specified by the value of <tt>filter_options</tt>
to the program command line.
</itemize>
<item>If the <bf>-$</bf> flag is not specified,
the arguments determined by the value of the <tt>bkf</tt>
(Berkeley LPD filter compatible flag) flag are added to the
filter command line.
If <tt>bkf</tt> is false the
<tt>filter_options</tt> are added for OF filters and
<tt>of_filter_options</tt>
are added for non-OF filters;
if it is true, then the
<tt>bk_filter_options</tt> and <tt>bk_of_filter_options</tt> are added for
OF and non-OF filters respectively.
<p>
<table>
<tabular ca="|l|l|">
Option
|
DefaultValue
@
<tt>filter&lowbar;options</tt>
|
$C $F $H $J $L $P $Q $R $Z $a $c $d $e $f $h $i $j $k $l $n $p
$r $s $w $x $y $-a
@
<tt>of&lowbar;filter&lowbar;options</tt>
|
(same as <tt>filter&lowbar;options</tt>)
@
<tt>bk&lowbar;filter&lowbar;options</tt>
|
$P $w $l $x $y $F $c $L $i $J $C $0n $0h $-a
@
<tt>bk&lowbar;of&lowbar;filter&lowbar;options</tt>
|
$w $l $x $y
@
</tabular>
</table>
<p>
<item>
By default,
for programs that are not being invoked as print job file filters,
the
<tt>filter_options</tt>
arguments are added.
For print job filters, if the <tt>bkf</tt> flag is set,
then the
<tt>bk_filter_options</tt>
and
<tt>bk_of_filter_options</tt>
entries are used.
The default <tt>bk</tt> filter options are the same as originally used
with the BSD LPR filters.
For the <tt>of</tt> filter,
either the <tt>of_filter_options</tt>
or <tt>bk_of_filter_options</tt> arguments will be added.
<item>
The program arguments will then be scanned and interpreted.
Arguments of the form <tt>$</tt><em>letter</em> will be
translated into values from the
print job control file and/or printcap entry.
The letters have the following meaning:
<table>
<tabular ca="|l|l|">
Letter
|
TranslatedValue
@
<tt>a </tt>
|
printcap <tt>af</tt> (accounting file name)
@
<tt>b </tt>
|
job size (in K bytes)
@
<tt>c </tt>
|
binary file (<tt>l</tt> format for print file)
@
<tt>d </tt>
|
printcap <tt>cd</tt> or <tt>sd</tt> entry
@
<tt>e </tt>
|
print job data file name (currently being processed)
@
<tt>f </tt>
|
print job original name when spooled for printing (N info from control file)
@
<tt>h </tt>
|
print job originating host (H info from control file)
@
<tt>i </tt>
|
indent request (I info from control file)
@
<tt>j </tt>
|
job number in spool queue
@
<tt>k </tt>
|
print job control file name
@
<tt>l </tt>
|
printcap <tt>pl</tt> (page length)
@
<tt>m </tt>
|
printcap <tt>co</tt>
@
<tt>n </tt>
|
user name (L info from control file)
@
<tt>p </tt>
|
remote printer (when processing for bounce queue)
@
<tt>r </tt>
|
remote host (when processing for bounce queue)
@
<tt>s </tt>
|
printcap <tt>sf</tt> (status file)
@
<tt>t </tt>
|
time in common UNIX format
@
<tt>w </tt>
|
printcap <tt>pw</tt> (page width)
@
<tt>x </tt>
|
printcap <tt>px</tt> (page x dimension)
@
<tt>y </tt>
|
printcap <tt>py</tt> (page y dimension)
@
<tt>F </tt>
|
print file format
@
<tt>P </tt>
|
printer name
@
<tt>S </tt>
|
printcap <tt>cm</tt> (comment field)
@
Capital letter
|
Corresponding line from control file
@
&lcub;key&rcub;
|
printcap value for <tt>key</tt>
@
</tabular>
</table>
<item>
If there is no value for the specified argument,
then the argument is removed from the list.
If there is a value, the actual form of the substitution is
controlled by additional flags as follows.
<table>
<tabular ca="|l|l|">
Form
|
TranslatedValue
@
<tt> $x </tt>
|
<tt>'-x<em>value</em>' </tt>
@
<tt> $-x </tt>
|
<tt> '<em>value</em>' </tt>
@
<tt> $0x </tt>
|
<tt> -x '<em>value</em>' </tt>
@
<tt> $'x </tt>
|
<tt> -x <em>value</em> </tt>
@
</tabular>
</table>
<p>
Each entry in quotes is treated as a single value,
as in /bin/sh.
The <tt>$'x</tt> does not quote the value.
Combinations of the various flags are allowed.  For example,
<tt>$-x</tt> would simply substitute the value for <tt>x</tt>,
and then pass the whitespace separated components as individual arguments.
This last form is useful for adding in additional flags on the command line.
<item>
The command line is parsed,
metacharacters are ruthlessly stripped from all arguments and pathnames
and replaced by <tt>_</tt> (underscores),
and an argument list suitable for the <tt>execve</tt> system call
is formed.
<item>
A sanitized environment is set up for the program execution,
with the following environment variables.
<p>
<table>
<tabular ca="|l|l|">
<tt> USER </tt>
|
User name (client only)
@
<tt> LOGNAME </tt>
|
L control file info
@
<tt> HOME </tt>
|
Home directory (client only)
@
<tt> LOGDIR </tt>
|
Home directory (client only)
@
<tt> PATH </tt>
|
<tt>filter&lowbar;path</tt> configuration information
@
<tt> LD&lowbar;LIBRARY&lowbar;PATH </tt>
|
<tt> filter&lowbar;ld&lowbar;path </tt> configuration information
@
<tt> SHELL </tt>
|
<tt>/bin/sh</tt>
@
<tt> IFS </tt>
|
<tt>" \t"</tt>
@
<tt> TZ </tt>
|
Time zone
@
<tt> SPOOL&lowbar;DIR </tt>
|
<tt>sd</tt> printcap info
@
<tt> CONTROL&lowbar;DIR </tt>
|
<tt>cd</tt> printcap info
@
<tt> PRINTCAP&lowbar;ENTRY </tt>
|
printcap info
@
<tt> CONTROL </tt>
|
control file
@
</tabular>
</table>
<p>
<item>
If the filter is to be run by a client program such as <tt>lpr</tt>,
then the environment variables specified by the
<tt>pass_env</tt> configuration or printcap option will be
extracted from the environment,
have any metacharacters removed,
and then placed in the environment variable list.
Commonly, the
<tt>PGPPASS</tt>,
<tt>PGPPASSFD</tt>,
and <tt>PGPPATH</tt> are specified.
<item>
The program is started,
with STDIN, STDOUT, and STDERR attached to the appropriate files or
file descriptors.
If none is specified, then they are attached to
<tt>/dev/null</tt>.
</enum>
<sect1>LPRng Supported Filters
<p>
There already exists a large library of ready-to-use filters. Some of
them have LPRng-specific versions, which can be found at the
<ref id="secftp" name="LPRng ftp mirror sites">.
<sect2>Filter Distribution Conventions
<p>
By convention,
most filters are either totally standalone (very rare),
or require a set of support files.
There are two types of support files: per print queue configuration information
and global support information.
<p>
Since a print filter will execute with the current directory set to the
spool queue directory,
most filters expect that per print queue configuration information
should be kept in the spool directory.
Most <em>vintage</em> filters insist on having these files <em>hidden</em>
with names such as <bf><tt>.setup</tt></bf>.
This can make it difficult for administrators to determine where the
configuration files are.
<p>
It is strongly recommended that filters and information
be placed in commonly accessible directories such as
<tt><bf>/usr/local/lib/filters</bf></tt>,
and the executables in subdirectories.
This allows the LPRng administrator to set the privileges on these
directories such that only the <tt>lpd</tt> process can
access them.
<p>
Most of the LPRng supported filters can either be used as a
<tt>if</tt> or <tt>of</tt> filter.
The filter will examine the format type passed by the <tt>-F<em>X</em></tt>
command line argument,
and if it is <tt>o</tt> it will perform as an <tt>of</tt> filter.
<p>
Alternatively,
the filter will check the filename in the pathname by which is was invoked.
If the name has the substring <tt>of</tt> in the filename,
then it assumes it is to act as an <tt>of</tt> filter.
This allows symbolic links to be made to a common filter executable,
each of which corresponds to the filter name by which it is to be invoked.
<p>
When a filter is invoked,
it is passed a large number of options,
many of which are totally ignored in filter operation.
However,
for many purposes it is necessary to provide options to the
filters to tailor their operation to the particular spool queue needs.
<p>
By convention,
all LPRng supported filters use the
<tscreen>
<verb>
-Tkey=value[,key=value]
</verb>
</tscreen>
<p>
convention for specifying filter configuration option values.
<sect1>lpf
<label id="lpf">
<p>
Source code:
<ref id="secftp" name="LPRng Distribution">
<p>
This filter is distributed as part of the LPRng source code,
and has a very limited functionality.
By default,
it only translates <tt>\n</tt> to <tt>\r\n</tt>
sequences,
and detects the OF Filter Stop sequence when invoked as an OF filter.
<itemize>
<item>Options:
<newline><tt>-Tcrlf</tt> - suppress <tt>\n</tt> to <tt>\r\n</tt> translation
</itemize>
<sect1>IFHP Filter
<label id="ifhp">
<p>
Source code:
<ref id="secftp" name="LPRng Distribution, ifhp-<em>version</em>.tgz">
<p>
This filter supports a wide variety of <it/smart/ printers,
or to be more specific,
printers which support PostScript, PCL or PJL languages.
<sect2>Printer Capabilities
<p>
As explained in
<ref id="installref" name="Setting Up Your Printer">,
you can have a parallel (unidirectional),
serial (bidirectional),
or network (bidirectional) connection.
When using a bidirectional connection,
you can sometime obtain or gratuitously receive error and/or status
information from the printer.
<p>
Some printers will spontaneously generate error messages when printing
a job on a bidirectional interface.
Usually, though,
it it necessary to force the printer to provide status in a reasonable format.
<p>
Some printers have the capability of printing either PCL or PostScript;
some require special setup commands and some will <em>autosense</em> which
type of job is being printed.
<p>
If you are printing text,
and not using a Page Description Language like PostScript or PCL,
then you may want to download a font to the printer.
This is especially the case when you are trying to print text files
in a non-English font.
<p>
Some printers will provide a <em>hardware</em> page counter value when requested;
however,
the means of requesting differ from model to model.
<p>
Sometimes you want to generate a special banner for a particular printer,
and need to put in some dynamic information.
While this can be done by the <tt>lpd</tt> server using the
<tt>bp</tt> program specification,
it turns out that non-LPRng systems which want to use the <tt>ifhp</tt>
want to have the same facilities.
Thus,  you need to have some way to get the same effect as the <tt>bp</tt>
option,  but at the filter level.
<p>
Having done <tt>lpd</tt> banner generation and printing,
why not have the filter run an accounting script as well?
<p>
At this point,  I suspect that the reader is beginning to suspect that
making a general purpose filter to support all of these possibilities is
difficult.
That is incorrect.  It is <bf>extremely</bf> difficult.
<p>
However,
the <tt/ifhp/ filter greatly simplifies this,
as it uses a simple database together with some printer configuration options.
For details,
see the <tt/ifhp/ documentation for details on using the filter.
For the terminally impatient,
the following is a quick cookbook:
<tscreen>
<verb>
# network connection to jet direct box,
#   no banners, HP compatible
lp
  :lp=ipaddr%9100
  :/usr/local/lib/filters/ifhp
  :sh:sf
#
# banner added
#
lp
  :bp=/usr/local/lib/filters/pclbanner
  :of=/usr/local/lib/filters/ifhp
  :if=/usr/local/lib/filters/ifhp
  :sf
#
# for a parallel port printer or when you want VERY fast
#  throughput, no pagecounts, error messages, etc.  The
#
lp
  :ifhp=status@
  :/usr/local/lib/filters/ifhp
  :sh:sf
</verb>
</tscreen>
<sect1>Using your own filters
<p>
If you already have a working setup, with its own specific filter
programs, you might want to keep them. Or, you might want to write a
set of your own.
<p>
See the source code in the
<ref id="secftp" name="LPRng Distribution, FILTERS_LPRng-&lt;version>.tgz"> files for examples.
<sect>Permissions and Authentication
<label id="lpdpermsref">
<p>
The contents of the <tt>/etc/lpd.perms</tt> file
is used to specify the restrictions on the use
of the LPRng software,
printers,
and other facilities.
The model used for permission granting is similar to packet filters.
An incoming request is tested against a list of rules,
and the first match found determines the action to be taken.
The action is either <tt/ACCEPT/ or the request is granted,
or <tt/REJECT/ and the request is denied.
You can also establish a default action.
<p>
The following is a sample <tt>lpd.perms</tt> file.
<p>
<tscreen>
<verb>
# allow root on server to control jobs
ACCEPT SERVICE=C SERVER REMOTEUSER=root
REJECT SERVICE=C
#
# allow same user on originating host to remove a job
ACCEPT SERVICE=M SAMEHOST SAMEUSER
# allow root on server to remove a job
ACCEPT SERVICE=M SERVER REMOTEUSER=root
REJECT SERVICE=M
# all other operations allowed
DEFAULT ACCEPT
</verb>
</tscreen>
<p>
A rule will ACCEPT or REJECT a request
if all of the patterns specified in the rule match.
If there is a match failure,
the next rule in sequence will be applied.
If all of the rules are exhausted,
then the last specified default authorization will be used.
<p>
The sense of a pattern match can be inverted using the NOT keyword.
For example,
the rules with
<tt>ACCEPT NOT REMOTEUSER=john,bill</tt>
succeeds only if the REMOTEUSER value is defined and
is not <tt>john</tt> or <tt>bill</tt>.
<p>
The following patterns and matching are applied.
<p>
<table>
<tabular ca="|l|l|">
Keyword
|
Match
@
<tt>DEFAULT</tt>
|
default result
@
<tt>SERVICE</tt>
|
lpC, lpR, lprM, lpQ requests, and Printing jobs
@
<tt>USER</tt>
|
user name in print job.
This check will always succeed when checking for spool queue permissions,
and only be done when checking for job permissions.
@
<tt>REMOTEUSER</tt>
|
user making request
@
<tt>HOST</tt>
|
host name in print job.
This check will always succeed when checking for spool queue permissions,
and only be done when checking for job permissions.
@
<tt>REMOTEHOST</tt>
|
host making request
@
<tt>IP</tt>
|
IP address and mask of host in print job
This check will always succeed when checking for spool queue permissions,
and only be done when checking for job permissions.
@
<tt>REMOTEIP</tt>
|
IP address and mask of host making request
@
<tt>PORT</tt>
|
TCP/IP port of host making request
@
<tt>SAMEUSER</tt>
|
USER and REMOTEUSER same
@
<tt>SAMEHOST</tt>
|
HOST and REMOTEHOST same
@
<tt>SERVER</tt>
|
request originates on lpd server
@
<tt>FORWARD</tt>
|
destination of job is not host
@
<tt>GROUP</tt>
|
USER is in the specified group
@
<tt>LPC</tt>
|
LPC command in the LPC request.
This must be preceeded by SERVICE=C clause.
@
<tt>REMOTEGROUP</tt>
|
REMOTEUSER is in the specified group
@
<tt>CONTROLLINE</tt>
|
match a line in control file
@
<tt>AUTH</tt>
|
authentication type
@
<tt>AUTHUSER</tt>
|
authenticated user
@
<tt>AUTHFROM</tt>
|
authenticated forwarder
@
<tt>AUTHJOB</tt>
|
authenticated job in queue
@
</tabular>
</table>
<p>
Most of the patterns can be lists of alternative values to match,
and can even contain wild cards.
The full details of the rules and keywords are detailed in
the <tt>lpd.conf(5)</tt> man page.
<sect1>Information for matching
<p>
In order to do matching,
the <tt>lpd</tt> server obtains and sets up the following information:
<enum>
<item>
If the request is coming over a network connection,
then the IP address (REMOTEIP)
port (PORT) of the source of the connection and
FQDN of the remote host (REMOTEHOST) are obtained
and the indicated values are set.
To be specific,
the IP address of the remote host is obtained using
<tt>getpeername()</tt>.
The <tt>gethostbyaddr()</tt> is used to look up the
host's fully qualified domain name,
which is then assigned to the REMOTEHOST value.
The REMOTEIP value is the
<em>set</em> or <em>list</em> of IP addresses that could be
used by this host.
This is possible in the IPV6 environment.
<item>
If the request contains the name of the user,
then REMOTEUSER is assigned the name.
<item>
If the request contains the name of the printer,
then PRINTER is assigned the name.
<item>
If permissions checking is to be done for a particular
job in a spool queue,
then the USER, HOST, IP, and PRINTER are set to the
user name, host, and printer information in the control file for the
print job.
The HOST entry in the control file is used by
<tt>gethostbyname()</tt> to get the fully qualified domain name of the host.
The IP value is assigned a 
<em>set</em> or <em>list</em> of IP addresses that could be
used by this host.
<item>
If one of the optional authentication methods is being used,
(see
<ref id="authref" name="Authentication and Encryption">),
then AUTH is true and 
AUTHTYPE is set to the type of authentication used.
AUTHUSER to the authenticated originating user of the request
and AUTHFROM is when the originating program is a server.
The AUTHSAMEUSER will be true when the remote client authentication information
matches the authentication information used to create the job on the server.
The AUTHJOB will be true when checking for job permissions and the job
has been authenticated.
</enum>
<sect1>Permission Checks
<p>
When a connection is made to the <tt>lpd</tt> server,
the originating site's IP address and hostname are determined,
and a check with <tt>SERVICE=X</tt>
and valid REMOTEHOST,
REMOTEIP,
and PORT information is done.
<p>
If the connection was not rejected,
then the request information is read
and the
SERVICE,
REMOTEUSER,
REMOTEHOST,
REMOTEIP,
PORT,
PRINTER,
and other authentication values will be defined.
The SERVICE value will be Q, R, M, or C for
<tt/lpq/,
<tt/lpr/,
<tt/lprm/,
or
<tt/lpc/ respectively.
The permissions file will be scanned to determine if the
request should be immediately discarded based on the print queue
it is for.
During this stage of processing,
permissions checks which require information from jobs in spool queues
will be ignored and treated as though a match had succeeded.
<p>
If the request is not rejected,
then it will be processed or carried out.
If the request is for an operation on one or more user jobs in
a spool queue,
then the spool queue for the jobs are scanned and permissions are
again checked against individual jobs.
At this stage in the processing,
the
USER and
HOST 
information obtained from the job file will be used in permissions checking.
This two levels of checks are necessary in order to allow
find control over individual jobs and users.
<p>
There is a problem with permissions checking for <tt/lpq/ (SERVICE=Q)
requests.
Since the user name is not passed as part of the request,
it is impossible to use the REMOTEUSER clause to restrict <tt/lpq/
operations.
<p>
The <tt>SERVICE=R</tt> and <tt>SERVICE=P</tt>
facilities are provided to handle problems with print spoolers that
do not recognize a <it>lack of permission</it> error code,
and will indefinately retry sending a job to the <tt>lpd</tt> server.
If this is the case,
then the <tt>SERVICE=R</tt> clause can be used to accept jobs,
and then the <tt>SERVICE=P</tt> clause will cause the <tt>lpd</tt>
server to remove of the job when it is scheduled for printing.
<sect1>Match Procedure
<p>
<tscreen>
<verb>
key=pattern                         substring match
key=pattern1,pattern2,pattern3,...  glob and exact
key=IP1/mask1,IP2/mask2,...         IP address
</verb>
</tscreen>
<p>
Each of the indicated values is matched against a list of patterns.
The following types of matches are used:
<enum>
<item>
substring match.
The indicated entry is present as a substring in the pattern.
<item>
GLOB matches.
The pattern is interpreted as a GLOB style pattern,
where * matches 0 or more characters,
and ? matches a single character,
and
<tt/[L-H]/
specifies a range of characters from
<tt/L/ to <tt/H/,
in ASCII order.
<item>IP address match.  The address must be specified in the
standard <tt>nn.nn.nn.nn</tt> format.
The mask must be either an integer number
corresponding to the number of significant bits,
or in the standard <tt>nn.nn.nn.nn</tt> format.
Addresses are compared by doing
<tscreen>
<verb>
( IPaddr XOR IP ) AND mask
</verb>
</tscreen>
<p>
If the result is 0, then a match results.
Note that there may be one or more addresses being checked for;
this can occur when a host may have multiple IP addresses assigned to it.
<item>integer range match.
The pattern has the form <tt>low-high</tt>,
where low and high are integer numbers.
The match succeeds if the value is in the specified range.
<item>Same IP Address Match.
This compares two lists of IP addresses;
a match is found when there is one or more common addresses.
</enum>
<sect2>DEFAULT
<p>
<tscreen>
<verb>
DEFAULT ACCEPT
DEFAULT REJECT
</verb>
</tscreen>
<p>
The DEFAULT rule specifies the default if no rule matches.
Normally,
there is one DEFAULT entry in a permissions file.
<sect2>SERVICE
<p>
Match type: substring
<p>
The SERVICE key is based on the type of request.
<table>
<tabular ca="|l|l|">
Key
|
Request
@
<tt>C</tt>
|
LPC Control Request
@
<tt>M</tt>
|
LPRM Removal Request
@
<tt>P</tt>
|
Job Printing
@
<tt>Q</tt>
|
LPQ Status Request
@
<tt>R</tt>
|
LPR Job Transfer
@
<tt>X</tt>
|
Connection Request
@
</tabular>
</table>
<p>
Each of the above codes corresponds either directly to the user command,
or a set of subcommands.
<p>
If you have an LPC request,
you can add an <tt>LPC=xxx</tt> clause to refine the
permissions checking to allow or disallow
<tt/lpc/ commands such as <tt>lpc status, printcap, active, </tt>.
<sect2>USER
<p>
Match type: GLOB
<p>
The USER information is taken from the <tt>P</tt> (person or logname)
information in the print job control file.
<sect2>REMOTEUSER
<p>
Match type: GLOB
<p>
The REMOTEUSER information is taken from the user information sent
with a service request.
<p>
Note that one of the flaws of
<ref id="rfc1179" name="RFC1179">
is that an LPQ (print status)
request does not provide a REMOTEUSER name.
<sect2>HOST
<p>
Match type: GLOB
<p>
The HOST information is taken from the <tt>H</tt> (host)
information in the print job control file.
<sect2>REMOTEHOST
<p>
Match type: GLOB
<p>
The REMOTEHOST information is obtained by doing a reverse IP name lookup
on the remote host address.
If there is no FQDN available,
then the IP address in text form will be used.
<sect2>PORT
<p>
Match type: integer range
<p>
The PORT value is obtained from the originating port of the TCP/IP
connection.
The match succeeds if it is in the specified range.
<sect2>IP
<p>
Match type: IPaddr
<p>
The IP information is obtained by doing a DNS lookup on the
H (host) information in the control file.
If there is no host information, the IP address is undefined.
Note that for a single host name there may be multiple IP addresses;
address matches are performed against the list of addresses and succeeds
if there is one or more individual address matches.
<sect2>REMOTEIP
<p>
Match type: IPaddr
<p>
The REMOTEIP information is the IP address of the host making the
service request.
Note that the REMOTEIP value is obtained by using the
<tt>gethostbyaddr</tt> lookup to obtain the DNS information for the
remote host.  This information may include multiple IP addresses;
address matches are performed against the list of addresses and succeeds
if there is one or more individual address matches.
<sect2>LPC
<p>
Match type: GLOB
<p>
If you are doing an LPC command,
this matches the command.
This allows the following permissions line to be used:
<tscreen>
<verb>
#allow remoteuser admin on server to use LPC topq and hold
ACCEPT LPC=topq,hold SERVER REMOTEUSER=x
</verb>
</tscreen>
<p>
<sect2>SAMEUSER
<p>
Match type: exact string match
<p>
Both the REMOTEUSER and USER information must be present and identical.
<sect2>SAMEHOST
<p>
Match type: Same IP Address
<p>
The REMOTEHOST and HOST address lists are checked;
if there is a common value the match succeeds.
<sect2>SERVER
<p>
Match type: Same IP Address
<p>
One of the REMOTEHOST addresses 
must be the same as one of the addresses of the <tt>lpd</tt> server host,
or must be one of the addresses found by looking up the <tt>localhost</tt>
name using <tt>gethostbyname()</tt>.
<sect2>FORWARD
<p>
Match type: Address Match
<p>
The list of REMOTEHOST and HOST addresses must not have a common entry.
This is identical to NOT SAMEHOST.
This is usually the case when a remote <tt>lpd</tt> server is forwarding
jobs to the <tt>lpd</tt> server.
<sect2>GROUP
<p>
Match type: modified GLOB
<p>
If the pattern does not start with a <tt>@</tt> character,
then the USER information must be present
and the USER must be present in
one of the groups in <tt>/etc/group</tt> or whatever permissions mechanism is used
to determine group ownership
which matches the GLOB pattern.
<p>
If the pattern starts with a <tt>@</tt> character,
then the USER information must be present
and the user must be in the specified <tt>netgroup</tt>.
This match will be performed only if the <tt>netgroup</tt>
mechanism is supported on the system and the specified netgroup
exists.
No wildcard match will be done for netgroups.
<sect2>REMOTEGROUP
<p>
The same rules as for GROUP,
but using the REMOTEUSER value.
<sect2>CONTROLLINE
<p>
Match type: GLOB
<p>
A <tt>CONTROLLINE</tt> pattern has the form
<tscreen>
<verb>
X=pattern1,pattern2,...
</verb>
</tscreen>
<p>
X is a single upper case letter.
The corresponding line must be present in a control file,
and the pattern is applied to the line contents.
<p>
This pattern can be used to select only files with specific control
file information for printing.
<sect2>AUTH
<p>
Match type: GLOB
<p>
The AUTH value can be NONE,
indicating that no authentication was done.
If authentication was done,
then AUTH=USER checks to see if there was user information,
and AUTH=FWD checks to see if there was forwarding system identification.
<sect2>AUTHUSER
<p>
Match type: GLOB
<p>
If AUTH=USER check succeeds,
the AUTHUSER rule will check to see if the user identification
matches the pattern.
<sect2>FWDUSER
<p>
Match type: GLOB
<p>
If AUTH=FWD check succeeds,
the FWDUSER rule will check to see if the forwarding system identification
matches the pattern.
<sect2>IFIP
<p>
Match type: IPmatch, but for IPV6 as well as IPV4
<p>
There is a subtle problem with names and IP addresses which are
obtained for 'multi-homed hosts', i.e. - those with multiple
ethernet interfaces,  and for IPV6 (IP Version 6),  in which a host
can have multiple addresses,  and for the normal host which can have
both a short name and a fully qualified domain name.
<p>
The IFIP (interface IP) field can be used to check the IP address
of the origination of the request,  as reported by the information
returned by the accept() system call.  Note that this information may
be IPV4 or IPV6 information,  depending on the origination of the
system.  This information is used by gethostbyaddr() to obtain the
originating host fully qualified domain name (FQDN) and set of IP addresses.
Note that this FQDN will be for the originating interface,  and may
not be the canonical host name.  Some systems which use the Domain Name Server
(DNS) system may add the canonical system name as an alias.
<sect1>Permission File Location
<label id="permspath">
<p>
Options used:
<itemize>
<item> <tt>perms_path=</tt><em> directory path list</em>
</itemize>
<p>
The <tt>perms_path=</tt> configuration variable specifies the
location of the default permissions file.
The default value is:
<tscreen>
<verb>
perms_path=/etc/lpd.perms:/usr/etc/lpd.perms
</verb>
</tscreen>
<p>
The <tt>lpd.perms</tt> file can be obtained by running a program,
in a similar manner to the <tt>/etc/printcap</tt> file.
See
<ref id="secfilter" name="Filters"> for details on how
the program would be invoked.
For example, assume the configuration information specified:
<tscreen>
<verb>
perms_path=|/usr/local/libexec/get_perms
</verb>
</tscreen>
<p>
Then the <tt>get_perms</tt> program would be invoked with STDIN attached
to <tt>/dev/null</tt> and the complete set of permission information
would be read from its STDOUT.
<sect1>Example Permission File
<p>
<tscreen>
<verb>
# allow root on server to control jobs
ACCEPT SERVICE=C SERVER REMOTEUSER=root
REJECT SERVICE=C
#
# allow same user on originating host to remove a job
ACCEPT SERVICE=M SAMEHOST SAMEUSER
# allow root on server to remove a job
ACCEPT SERVICE=M SERVER REMOTEUSER=root
REJECT SERVICE=M
# all other operations allowed
DEFAULT ACCEPT
</verb>
</tscreen>
<p>
In the above sample, we first specify that
lp<tt>C</tt>
commands from user <tt>root</tt> on the lpd server will be accepted.
This is traditionally the way that most lpc commands operate.
<p>
Next,  we reject any other lpc requests.
<p>
We accept
lpr<tt>M</tt>
requests from the host and user that submitted the job,
as well as from root on the server,
and reject any others.
<p>
Finally,
all other types of commands (lpq, lpr) are allowed by default.
<sect1>Complex Permission Checking
<p>
One of the more useful types of permission checking is to
restrict access to your printers from users outside your
networks.
The IP pattern can specify a list of IP addresses and netmasks
to apply to them.
<p>
For example
<tt>IP=10.3.4.0/24</tt> would match all hosts with the IP
addresses
<tt>IP=10.3.4.0</tt> to
<tt>IP=10.3.4.255</tt>.
<p>
Similarly, the HOST pattern can specify a set of hostnames
or patterns to match against based on the GLOB notation.
<p>
For example
<tt>REMOTEHOST=*.astart.com</tt>
would match all hosts with a DNS entry which ended with
<tt>astart.com</tt>.
<p>
The NOT keyword reverses the match sense.  For example
<tt>REJECT NOT REMOTEHOST=*.astart.com,*.murphy.com</tt>
would reject all requests from hosts which did not have a DNS entry
ending in
<tt>astart.com</tt>
or
<tt>murphy.com</tt>.
<sect1>More Examples
<p>
The following is a more complex lpd.perms file.
<tscreen>
<verb>
# All operations allowed except those specifically forbidden
DEFAULT ACCEPT
#Reject connections which do not originate from hosts with an
# address on 130.191.0.0 or from localhost,
# or name is not assigned to Engineering pc's
REJECT SERVICE=X NOT IFIP=130.191.0.0/16,127.0.0.1/32
REJECT SERVICE=X NOT REMOTEHOST=engpc*
#Do not allow anybody but root or papowell on
#astart1.astart.com or the server to use control
#facilities.
ACCEPT SERVICE=C SERVER REMOTEUSER=root
ACCEPT SERVICE=C REMOTEHOST=astart1.astart.com REMOTEUSER=papowell
#Allow root on talker.astart.com to control printer hpjet
ACCEPT SERVICE=C HOST=talker.astart.com PRINTER=hpjet REMOTEUSER=root
#Reject all others
REJECT SERVICE=C
#Do not allow forwarded jobs or requests
REJECT SERVICE=R,C,M FORWARD
# allow same user on originating host to remove a job
ACCEPT SERVICE=M SAMEHOST SAMEUSER
# allow root on server to remove a job
ACCEPT SERVICE=M SERVER REMOTEUSER=root
</verb>
</tscreen>
<sect>Accounting
<label id="accountingref">
<p>
The LPRng method for doing accounting is based on experiences in a
Academic environment,  where avoiding printing accounting procedures
has long been practiced.  While the LPRng procedures are not bombproof,
they do provide a wide range of facilities,  with various degrees
of trust built into them.
<sect1>Printer Accounting Reality Check
<p>
The following was written
by Patrick Powell
<tt>&lt;papowell@astart.com></tt>
in response to the expressions of frustration
that are periodically vented in the
<tt>
<ref id="maillist" name="lprng@lprng.org">
</tt>
mailing list.
While this addresses the use of a particular set of printer filters,
i.e. - the
<ref id="ifhp" name="ifhp">
set,
the comments are appropriate to other issues.
<p>
In Academic institutions, avoiding printing accounting has been
regarded as a challenge,  an ongoing game of fat cat and poor starving
mouse, between the Administration and the downtrodden, poor, over charged
student.  The following is a lighthearted ramble down the dark lane of
printing accounting.
<p>
We will disregard the fact that if most students put as much effort
into their studies as in finding ways to avoid accounting procedures
then they would be Rhodes Scholar material,  but I digress...
<p>
The accounting procedures put into the LPRng and the hpif filters may
appear to be extraordinarily complex,  but believe me, they are not.
Firstly, we make the assumption that the printer has some sort of
non-volatile page counter mechanism that is reliable and impervious to
power on/off cycles.  Without this mechanism the enterprising student
ummm... user will simply turn off the printer.  Software that prescans
jobs for line counts and pages is notoriously unreliable,  given even
the most modest efforts of users to hide these procedures.   The cost
of running a PostScript simulator simply to do accounting has its
flaws; without ensuring that the simulator has all of the interesting
security loopholes closed, such as opening files, etc.,  it can become
a trap door to hell for the system administrator.
<p>
Secondly,  we must make the assumption that the student... uhhh...
user will not be able to tinker with the page counter mechanism, i.e.-
they will not be able to roll back the odometer on the printer, FOR THE
DURATION OF A SINGLE JOB.  I will digress and point out that a student
actually did this for a challenge;  it only took him a couple of weeks
of study and a fully equipped microcontroller lab, and two (2) laser
printers which he ruined in the experiment.  HP was not amused when we
sent them back under warranty,  claiming that this our 'normal lab usage.'
<p>
Lastly,  you should not mind a small amount of pilferage, or a few
pages here and there being charged to the wrong account.
<p>
<bf>How Does It Work?</bf>
<p>
The <tt/ifhp/ filter records the page
counter value at the start and end of each part of a print job. Each
record has the form:
<tscreen>
<verb>
start -ppagecounter -Ff -kjob -uuser -hhost -R... 
end  -ppages -qpagecounter -Ff -kjob -uuser -hhost -R...
</verb>
</tscreen>
<p>
When we use the OF filter and/or banners,  we will see the
individual jobs bracketed by the OF filter records:
<tscreen>
<verb>
start -p100 -Fo -kcfA100taco -uuser -hhost -R...  
start -p101 -Ff -kcfA100taco -uuser -hhost -R...  
end  -p1 -q102 -Ff -kcfA100taco -uuser -hhost -R...  
start -p102 -Ff -kcfA100taco -uuser -hhost -R...
end  -p3 -q105 -Ff -kcfA100taco -uuser -hhost -R...  
end  -p5 -q105 -Fo -kcfA100taco -uuser -hhost -R...
</verb>
</tscreen>
<p>
It should be clear from the above that all we need to do is to add up
the values for the -Fo (OF) filter lines and we are done.
<p>
Unfortunately,  this is too simplistic.  If for some reason the job is
killed or terminates due to error conditions,  the OF filter may not
get to finish its work.  Thus,  we may see the following:
<tscreen>
<verb>
start -p100 -Fo -kcfA100taco -uuser -hhost -R...  
start -p101 -Ff -kcfA100taco -uuser -hhost -R...  
start -p110 -Fo -kcfA101taco -uuser -hhost -R...
</verb>
</tscreen>
<p>
This is a clear indication that the user's job has been terminated.  In
this case we need to use the differences between pagecounters of the start
records to do accounting.
<p>
There is a caveat to all of this;  that is the problem of the last dead
job in the list.  If the last line in the accounting file is:
<tscreen>
<verb>
start -p110 -Fo -kcfA101taco -uuser -hhost -R...
</verb>
</tscreen>
is the last job finished or did it abort?
<p>
<bf>Who Used Up 2000 Pages of Paper Today?</bf>
<p>
Now we move on to the problem of real time accounting.  Due to limited
budgets, etc., many institutions would like to strictly enforce limits
on paper use by students. As jobs are printed their accounts should be
docked for the amount of paper use.  One way to do this is to have an
external accounting procedure update a shared database.  The <tt/ifhp/ filter
has provision for a shell script to be called at the end of print job;
this is done by both the OF and IF filter.  Thus, we can blithely
assume that there is a central database carefully getting updates
from the LPRng software, probably from dozens of different printers,
and updating the accounting information.
<p>
The first question to be asked is simple:  is this worth it?
Perhaps doing accounting as a batch job once an hour/four times
a day/once a day is cheaper than building an running such a database.
If it costs $5K/year for the database software, you might just consider
ignoring the 10,000 pages that get lost in the shuffle and use
a simple set of awk/sed/perl scripts to update a database once
an hour.
<p>
<bf>BAD JOBS - Who Do We Bill?</bf>
<p>
We inevitably run into an interesting question:
what happens if a job does not complete correctly?
<p>
If you use the completion of the OF filter as a success status, I have
to point out that many students... ummm... users soon find ways to send
jobs to the printer that will cause it to lock up after their output
has been printed. These jobs require power cycling of the printer and
restarting the filter; a bit extreme, perhaps, but it has happened.
<p>
I suggest that you simply adopt a 'bill to last user of record'
attitude,  using the pagecount information as follows:
<tscreen>
<verb>
start OF -- starting point for THIS job
start IF --  nice information, but not useful
start IF --
end   OF -- ending point for this job - can record information
start OF --
if no end OF for previous job,  then treat as end OF and
  update accounting.
</verb>
</tscreen>
<p>
Now somebody is sure to complain that they got charged for a bunch of
pages that they did not use.  This is inevitable;  always carry a
can of oil for the squeaky wheels.  I might make the observation that
once is accident, twice is coincidence, but three times is malice;
be wary of the constant complainer and check out not only him or her but
also their co-workers.
<p>
<bf>How Do We Update the Database?</bf>
<p>
I suggest that database update be done as follows:
<p>
You maintain a 'last page reported' counter for each printer in the
database.  When a successful job reports in,  check to see that
<newline>
pagecount + joblength ==  newpagecount;
<p>
If this is not the case,  then you have had a some unsuccessful jobs.
In this case I strongly recommend that you have a means to request the
accounting reporting program to go back through the accounting file and
find the last report for the page counter value and try to backtrack
through the accounting files.  The accounting file is one of the first
things to be attacked by students... Ummm...  users.  It should NOT be
kept on an NFS exported or mounted file system.  It should be
carefully pruned and copied, perhaps on an hourly basis.
<p>
Now some administrators have fallen in love with network based printers;
do not believe ANYTHING that comes over a network connection without
some form of authentication;  PGP has some very nice Public Key
mechanisms for handling this.  This is a major weakness in using a
database for keeping track of accounting - a weak authentication
mechanism may lead to denial of service attacks by students flooding
the database with bogus print usage reports;  suddenly NOBODY can print
and the administrator is driven to turning off accounting.
<p>
Good luck.  I am never surprised when I encounter yet another wrinkle in
this area.
<p>
Patrick ("You call me a Bean Counter?  Guido,  break this kid's fingers
<newline>
&nbsp; &nbsp; &nbsp; &nbsp; with an adding machine!") Powell
<sect1>How HP Printers Implement Page Counters
<p>
The following is from
<htmlurl
url="http://www.hp.com/cposupport/printers/support_doc/bpl02119.html"
name="http://www.hp.com/cposupport/printers/support_doc/bpl02119.html" >
<p>
<bf>HP LaserJet Printer Family - Page Count</bf>
<p>
Description Of The Page Count Feature On HP LaserJet 4 Family
Printers
<p>
All HP LaserJet 4/5/6 family printers have a page count feature
built into the firmware. However, this feature works differently
depending on which HP LaserJet printer is being used. The following
is a description of how the page count feature works for each
printer within the HP LaserJet 4/5/6 printer families.
<tscreen>
<verb>
HP LaserJet 4/4M printers
HP LaserJet 4 Plus/4M Plus printers
HP LaserJet 4P/4MP printers
HP LaserJet 4Si/4Si MX printers
HP LaserJet 4ML printers
HP LaserJet 5P/5MP printers
HP LaserJet 6P/6MP printers
</verb>
</tscreen>
<p>
All of the above printers use the same method for keeping track of
the number of copies. There are really two different page count
values: Primary and Secondary values. Every time a page is printed,
whether it is an internal job (such as a self-test) or a standard
print job, the Secondary page count increases by one. This value
is stored in standard RAM. Once the Secondary page count value
reaches 10, the Primary page count will increase by 10. The Primary
page count value is stored in a type of memory called NVRAM
(Non-Volatile RAM). This is important, since NVRAM is not cleared
when the printer is powered off. Standard RAM, on the other hand,
is cleared when the printer is turned off or reset. Thus, the
Primary page count only increases in increments of 10.
<p>
Example
<p>
You have a brand new HP LaserJet 6P printer and you print a self-test
page. When you look on the test page for the Page Count value, you
will see that it says 1. Next, you decide to print a two page letter
and, after that, another self-test. The page count value now says
4. Internally, the printers Secondary page count (stored in RAM)
has the value of 4 while the Primary page count (stored in NVRAM)
still has the value of 0. Now, you turn the printer off, then back
on, and print another self-test. The page count value again says
1 since the previous value of 4, stored in RAM, was cleared when
the printer was powered off. Finally, print a ten page document
and then turn the printer off. Upon turning the printer back on
and printing out another self test, you see that the page count
value is 11.  Internally, the Secondary page count value is back
at 1 while the Primary page count value (stored in NVRAM) is 10.
Added together, you end up with the resulting value seen on the
self-test page.
<p>
HP LaserJet 4L/5L/6L Printers
<p>
The reason that the page count method for the HP LaserJet 4L/5L/6L
printers differ from that of the other printers is that the HP
LaserJet 4L/5L/6L printers do not have any NVRAM available. Thus,
no way exists for the printer to retain a page count value once
the printer is powered off. The HP LaserJet 4L/5L/6L printers have
only a single page count value that increases in increments of one
until the printer is powered off. At that point, the page count
value is reset and begins from 0 once again.
<p>
<sect1>Accounting Printcap Options
<label id="accountingserver">
<p>
The accounting facilities are controlled and enabled by the following
entries in the printcap file.  The default value is indicated.
<p>
<table>
<tabular ca="|l|l|l|">
Tag
|
Default Value
|
Purpose
@
af
|
NULL
|
accounting file name
@
as
|
"jobstart $H $n $P $k $b $t"
|
accounting info for job start
@
ae
|
"jobend $H $n $P $k $b $t"
|
accounting info for job end
@
accounting&lowbar;server
|
NULL
@
achk
|
FALSE
@
la
|
TRUE
|
do accounting for 'local' printer
@
ar
|
FALSE
|
do accounting for 'remote' transfers
@
</tabular>
</table>
<p>
<sect1>Accounting File
<p>
The most common method of accounting is to record the start and end
times of a job and its size to the accounting file. A typical entry
for the printcap defaults are shown below.
<tscreen>
<verb>
jobstart '-Htaco.astart.com' '-nroot' '-Pps' '-kcfA938taco.astart.com' \
'-b1093' '-tNov  5 19:39:59'
start '-p12942' '-kcfA938taco.astart.com' '-nroot' '-htaco.astart.com' '-Pps' \
'-c0' '-Fo' '-tSun Nov  5 19:39:25 1995'
start '-p12944' '-kcfA938taco.astart.com' '-nroot' '-htaco.astart.com' '-Pps' \
'-c0' '-Ff' '-tSun Nov  5 19:39:27 1995'
end '-p12944' '-kcfA938taco.astart.com' '-nroot' '-htaco.astart.com' '-Pps' \
'-b3' '-c0' '-Ff' '-tSun Nov  5 19:39:58 1995'
end '-p12942' '-kcfA938taco.astart.com' '-nroot' '-htaco.astart.com' '-Pps' \
'-b2' '-c0' '-Fo' '-tSun Nov  5 19:39:59 1995'
jobend '-Htaco.astart.com' '-nroot' '-Pps' '-kcfA938taco.astart.com' \
'-b1093' '-tNov  5 19:39:59'
</verb>
</tscreen>
<p>
The <tt>jobstart</tt> and <tt>jobend</tt> lines are added by the LPD server,  as
specified by the <tt>as</tt> and <tt>ae</tt> printcap options;
the -b (byte count) indicates the numbers of bytes in the job.
<p>
The <tt>start</tt> and <tt>end</tt>
lines are produced by the filters;
the of filter has an -Fo, and the if filter a -Ff entry.
The filters in the LPRng distribution produce the
indicated output format by default.
The -p value is the current value of a page counter device (if any),
and the -b value indicates the total number of pages used.
<p>
It should be clear that a simple AWK or Perl script will be able to
process an accounting file and update accounting information for
accounting purposes;  the usual problems with truncation, time stamps,
etc., are left as an exercise for the system administrator.
However,
for those who are exercise challenged,
the LPRng distribution
<tt>.../LPRng/UTILS/accounting.pl</tt>
file is a template that can be used to process the accounting information.
The printcap for using this file should resemble:
<tscreen>
<verb>
pr:
  :as=|/.../accounting.pl START
  :ae=|/.../accounting.pl END
  :if=/.../ifhp
  :of=/.../ofhp
  # set this to the printing device
  :lp=prdevice
  :sd=/.../%P
</verb>
</tscreen>
<p>
Note that the accounting file must exist and will not be created by the
<tt/lpd/ server.
The accounting file should be periodically truncated.
<sect1>Accounting Using an Accounting Server
<p>
To accommodate even more aggressive and centralized accounting,
a method to make a connection to a print server and send information
to the server has been provided as well.
If <tt>achk</tt> option is set,
it is assumed that the <tt>af</tt> entry specifies a connection to
server on a remote host.
The <tt>lpd</tt> server will send the <tt>as</tt> string to the server,
and then wait for a single line of text from the remote server.
If the first word on the return line is
<tt>accept</tt> or <tt>hold</tt>,
the job will be either accepted for printing or held.
Any other value will cause the job to be deleted.
<p>
At the end of the job the <tt>ae</tt> string will be sent to the server.
No response is expected.  Example:
<p>
<tscreen>
<verb>
:af=accounting.site.com%2300,tcp
:achk
:as=starting
:ae=ending
</verb>
</tscreen>
<p>
The port that the connection originates from will be in the range
set by the configuration or printcap
<tt>
<ref id="originateport" name="originate_port">
</tt>
option.
<sect1>Using Filters For Accounting
<p>
Some sites have expressed interest in using a central accounting
mechanism to check that users have permissions.  This can be done by
using the an alternative form of the as (accounting start) and ae
(accounting end) printcap tags.  If the as and ae are filter
specifications,  then a filter is invoked.  If the as (accounting
start) filter returns a non-zero exit status,  then its value
is used to handle the job as indicated by
the
<ref id="termination" name="Abnormal Termination">
codes for filters.
At the end of the job the :ae: filter will be invoked in a similar manner,
but its exit status is ignored.
<p>
When using an accounting filter,
the STDIN  is attached (read/write) to the accounting file or remote host
specified by the <tt>af</tt> printcap option,
STDOUT to the output device,
and STDERR to the status file.
The filter program would be invoked with the default filter options.
<p>
For example, here is a sample entry to check and update accounting
<tscreen>
<verb>
printer
:as=|/usr/local/lib/filters/accounting.pl start
:ae=|/usr/local/lib/filters/accounting.pl end
</verb>
</tscreen>
<sect1>Accounting Utility accounting.pl
<p>
In order to provide a framework for doing using the outlined accounting
methods,  the LPRng distribution
<tt>UTILS</tt> directory has a <tt>accounting.pl</tt> script.
This script does the following.
<enum>
<item>
It is assumed that the accounting filter is invoked with the
following printcap entry.
The start and end is used by the filter to determine at which point in
the accounting process it is invoked.
<tscreen>
<verb>
printer
:as=|/usr/local/lib/filters/accounting.pl start
:ae=|/usr/local/lib/filters/accounting.pl end
</verb>
</tscreen>
</item>
<item>
It maintains the accounting file as a set of entries in the following format:
<tscreen>
<verb>
START [job identification]
start -pnn ...
...
end -pnn+pagecount ...
END -ppagecount [job identification]
</verb>
</tscreen>
</item>
<item>
Each time the filter is invoked with the <tt>start</tt>
tags,
it will add a <tt>START</tt> record to the end of the accounting file.
</item>
<item>
When it is invoked with the <tt>end</tt> option,
it will update the accounting file and add an <tt>END</tt> entry.
</item>
<item>
It will handle aborted jobs by looking for jobs with have a <tt>START</tt>
entry and a following <tt>start</tt> line and assuming that they
progressed to the point of starting print operations,
i.e. - the printer page counter was accessed and reported.
It will then look for the next <tt>START</tt> entry with a
following <tt>start</tt> line,
and assume that the pages between the two points were used by the
aborted job.
</item>
</enum>
<p>
Administrators can use this script as a starting point for more advanced
accounting.
For example,
rather than just recording the information,
at the job start the script can query either a local database
or a remote server to see if the user has permissions to access the printer.
At the end of the job or when an <tt>END</tt> line is written to the
accounting file,
the local database or remote accounting server can be updated.
<sect>Authentication and Encryption
<label id="authref">
<p>
One of the major problems in a print spooler system is providing
privacy and authentication services for users.  One method is to
construct a specific set of protocols which will be used for
providing the privacy or authentication;  another is to provide a
simple interface to a set of tools that will do the authentication
and/or encryption.
<p>
LPRng provides native support for the LPR extensions used by MIT
and the Kerberos 4 implementation.
In addition,
it provides Kerberos 5 based authentication.
<p>
LPRng also supports the use of the PGP (Pretty Good Privacy) program
and can sign and optionally encrypt command and responses between servers
and clients.
<p>
Finally,
LPRng provide a general purpose interface allowing users to insert their
own authentication methods,
either at the program level or at the code level.
<sect1>Authentication
<p>
A careful study of the authentication problem shows that it should be done
during reception of commands and/or jobs from a remote user and/or
spooler.  At this time the following must be done:
<enum>
<item>
The received command must be checked for consistency,  and the
remote user and host must be determined.
<item>
The remote user and host must be authenticated.
<item>
The command and/or spooling operation must be carried out.
<item>
The results must be returned to the remote system.
</enum>
<p>
<sect1>Identifiers
<p>
When a user logs into a system,  they are assigned a user name
and a corresponding UserID.  This user name is used by the LPRng
software when transferring jobs to identify the user.
<p>
When we look into the problem of authentication,  we will possibly
have a more global user identification to deal with, the
authentication identifier (AuthID).  One way to deal with this problem is to
give LPRng intimate knowledge of the UserID and AuthID relationship.
While this is possible,  it may be difficult to deal with in a
simple and extensible manner.  An alternate solution is to provide
a mapping service,  where the authentication procedure provides
a map between the UserID and AuthID.
<sect1>RFC1179 Protocol Extensions
<p>
The RFC1179 protocol specifies that a LPD server command sent on
a connection has the form:
<tscreen>
<verb>
\nnn[additional fields]\n
</verb>
</tscreen>
<p>
<tt>\nnn</tt> is a one octet (byte) value with the following meaning:
<p>
<tscreen>
<verb>
REQ_START   1    start printer
REQ_RECV    2    transfer a printer job
REQ_DSHORT  3    print short form of queue status
REQ_DLONG   4    print long form of queue status
REQ_REMOVE  5    remove jobs
</verb>
</tscreen>
<p>
The LPRng system extends the protocol with the following additional
types:
<tscreen>
<verb>
REQ_CONTROL 6    do control operation
REQ_BLOCK   7    transfer a block format print job
REQ_SECURE  8    do operation with authentication
REQ_VERBOSE 9    verbose status information
REQ_LPSTAT 10    lpstat simulation
</verb>
</tscreen>
<p>
The REQ_CONTROL allows a remote user to send LPC commands to the
server.  The REQ_BLOCK provides an alternate method to transfer a
job.  Rather than transferring the control and data files individually,
this format transfers one file.  The REQ_AUTH provides a mechanism
for providing an authentication mechanism and is described in this
document.
<sect1>Client Operations for Client To lpd Server Authentication
<label id="auth">
<label id="authclientfilter">
<label id="authserverid">
<p>
Options used:
<itemize>
<item> <tt>auth=</tt><em>client to server authentication type</em>
<item> <tt>auth_client_filter=</tt><em>client to server transfer program</em>
<item> <tt>auth_forward=</tt><em>server to server authentication type</em>
<item> <tt>auth_forward_filter=</tt><em>server to server transfer program</em>
<item> <tt>auth_forward_id=</tt><em>Server identification</em>
<item> <tt>auth_receive_filter=</tt><em>server to server transfer program</em>
<item> <tt>auth_server_id=</tt><em>server identification</em>
</itemize>
<p>
This section describes the general purpose interface used for
client to server authentication.
<p>
The LPRng client will generate a set of commands and place them in a file.
The file is then encrypted and/or signed by the appropriate authentication
method,
and is transferred to the server.
The server will then decrypt and/or check the signature,
perform the requested actions,
and in turn generate a file of status information.
This file is encrypted and/or signed by the server,
and sent to the client,
where it is in turn decrypted and/or checked for correct signature.
These activities are controlled by the following printcap or configuration
options.
<enum>
<item>
The <tt> auth </tt> option specifies the authentication type to be used
for client to server transfers.
For example,
<tt/auth=pgp/ would specify PGP authentication,
<tt/auth=kerberos5/ would specify Kerberos 5 authentication,
<tt/auth=kerberos4/ would specify Kerberos 4 authentication,
and
<tt/auth=user/ would specify using user provided filters for authentication.
<item>
For client to server operations,
the server id is the value of the
<tt>auth_server_id</tt> option.
<item>
The <tt/auth_forward/> option specifies the authentication type to be used
for server to server transfers.
<item>
For server to server operations,
the id of the originating server
is specified by
<tt>auth_server_id</tt>.
and the remote server by
<tt>auth_forward_id</tt>.
<item>
When doing client to server transfers,
the originating user is determined by using the current UID
of the program as the search value for <tt>getpwuid()</tt>.
</enum>
<p>
The LPRng client will open a connection to the server
and send a command with the following format:
<tscreen>
<verb>
\008printer C userid auth\n         - for commands
\008printer C userid auth jobsize\n - for print jobs
</verb>
</tscreen>
<p>
Note that \008 is a one byte code indicating an authenticated
transfer.  Printer is the spool queue name, C in the character 'C'
indicating a client request, userid is the login id of the user,
auth is the the value of the <tt/auth/ option,
and jobsize is the size of the job file to be printed.
<p>
On reception of this command,  the server will send a one byte
success code.
If an error is indicated by a non-zero response,
additional error status may follow
the non-zero success code byte.  At the end of this information
the connection will be terminated.
The values used by LPRng are:
<tscreen>
<verb>
ACK_SUCCESS 0   success
ACK_STOP_Q  1   failed; no spooling to the remote queue
ACK_RETRY   2   failed; retry later
ACK_FAIL    3   failed; job rejected, no retry
</verb>
</tscreen>
<p>
If the success code is zero,
client will use the <tt>auth_client_filter</tt> to encrypt and/or sign
a data file to be transferred to the server.
The authentication program will have the following IO assignments:
<tscreen>
<verb>
FD  Options Purpose
0  R/W     connection to remote host
1  W       output for returned status
2  W       errors
</verb>
</tscreen>
<p>
Command line arguments:
<tscreen>
<verb>
program -C -Pprinter -nuser -Aauth -Rauth_server_id -Ttempfile
</verb>
</tscreen>
<p>
The <tt> tempfile </tt> will contain either a command line as would be
transferred using the standard RFC1179 protocol,
or a print job in block format.
See
<ref id="rfc1179ref" name="RFC1179 Protocol"> for details.
The client authenticator program will open and transfer
the contents of <tt>tempfile</tt> to the server authenticator,
using FD 0
and a format compatible with the underlying authentication mechanism.
<p>
If the transfer fails the client
authenticator will log error information on FD 2 and then exit
with error code JFAIL.
<p>
The server will send the client authentication program
any error or logging information over the FD 0 connection,
in a form appropriate to the authentication operation.
The client authenticator will write this information to FD 1.
If data transfer or authentication fails,  the authenticator
will write an error message to FD 2 and exit with error code
JFAIL.
<p>
If no error has occurred the client authenticator will
then exit with error code JSUCC.

<sect1>Server Operations for Client To lpd Server Authentication
<label id="authreceivefilter">
<label id="authforwardfilter">
<p>
Options used:
<itemize>
<item> <tt>auth_receive_filter=</tt><em>Server (lpd) authentication program</em>
<item> <tt>auth_server_id=</tt><em>Server identification</em>
</itemize>
<p>
When an authentication command arrives at the server,
it has the following form:
<tscreen>
<verb>
\008printer C userid auth\n          - for commands
\008printer C userid auth jobsize\n - for print jobs
</verb>
</tscreen>
<p>
The server will attempt to find the printcap for the specified printer.
For some operations this printer will be a dummy entry;
this will simply cause the following operations to use the default
information in the <tt>lpd</tt> configuration.
<p>
If a print job is being performed and the spool queue does not exist,
then the job will be rejected.
A non-zero error code will be written to the connection and the operation
will terminate.
<p>
The <tt/auth/ value is used to set the
AUTHTYPE permission checking value.
If the AUTHTYPE is not built in,
and the <tt>auth</tt> value does not match the
printcap or configuration
<tt/auth/ option value then authentication will fail.
An error message will be logged to the server log file,
and a non-zero error code and message will be written to the connection
to the remote client program.
<p>
Many authentication programs require that the
users provide some form of key or identification.
The <tt>userid</tt> option is used for this purpose.
<p>
The server will start the server authenticator program and provide the
following open file descriptors for it.  The program
will run as the same UID as the <tt>lpd</tt> server.
If this is a print job transfer,
the current directory will be the spool directory of the print queue.
<tscreen>
<verb>
FD  Options Purpose
0  R/W     socket connection to remote host (R/W)
1  W       pipe or file descriptor,  for information for server
2  W       error log
3  R       pipe or file descriptor,  for responses to client
</verb>
</tscreen>
<p>
Command line arguments:
<tscreen>
<verb>
program -S -PPRINTER -nserver_auth_id -aAUTHTYPE -RUSERID -Ttempfile
</verb>
</tscreen>
<p>
The
<tt/PRINTER/,
<tt/USER/,
and
<tt/AUTHTYPE/,
are obtained from the command sent to the server,
and are the
<tt/printer/,
<tt/user/,
and
<tt/authtype/
values sent.
The
<tt/server_auth_id/
is obtained from the printcap or configuration information for this
printer,
and should be identical to the value used by the sending program to
when it invoked the authenticator program.
<p>
The authentication filter will read the file transferred by the
client authenticator,
decrypt it,
and place the decrypted values in the tempfile.
It will then write
a
<tt/from_id/
string to FD 1,
which will be read by the LPD server
and used as the identification of the originating end of the connection.
<p>
If the originating program is an LPRng client,
then the <tt/from_id/ value will be the user identification for the authentication protocol;
if the originating program is an LPRng server,
this value will be the server identification for the authentication protocol.
<p>
After writing this value,
the transfer program will close FD 1.
At this point the LPD server will use the contents of the tempfile to perform
the various requested actions.
<p>
If the transfer step or authentication fails,  then the server
authenticator
will write an error message to FD 2 and exit with error code
JFAIL.
<p>
The <tt>lpd</tt> server will record the
authentication information returned by the server in the
AUTHUSER permissions key.
<p>
The <tt>lpd</tt> server will perform the usual permissions checks,
with the addition of the indicated permission keys and associated values.
During this process,
any error messages or logging information normally returned to client
programs will be written to the authentication program FD 3.
<p>
The <tt>lpd</tt> server will carry out either the commands or
print job specified in the temporary file.
During this process,
any error messages or logging information normally returned to client
programs will be written to the authentication program FD 3.
<p>
At the end of the operations,
the FD 3 file descriptor will be closed and the <tt>lpd</tt> server
will wait for the authentication process to exit.
<p>
The server authentication process will read
input from FD 3 until the end of input,
and then transfer the received information to the client
side authenticator.
It may use the tempfile to hold the information during the
reading and transfer process.
<p>
If the transfer of the logging information fails,
then the authenticator process will exit with
error code JFAIL, otherwise it will exit with error code JSUCC.
<sect1>lpd Server to Server Authentication
<label id="authforwardid">
<label id="authforward">
<p>
Options used:
<itemize>
<item> <tt>auth_forward=</tt><em>Server to server authentication type</em>
<item> <tt>auth_forward_id=</tt><em>Destination server authentication id</em>
</itemize>
<p>
The Server to Server authentication procedure is used by one server
to forward jobs or commands to another server.  It should be noted
that this forwarding operation puts an implicit trust in the security
of the client to server to server chain.
The <tt>lpd</tt> server will perform an authenticated transfer to
another server when it either needs to transfer a job to a remote printer
or when it needs to propagate a
<tt>lpq</tt>,
<tt>lprm</tt>,
or
<tt>lprc</tt> operation.
<p>
The procedure used to by the server to send commands and/or jobs
is identical to that used by a client,
with the minor modification that the server is identified as the
originating endpoint of the connection,
and the client authentication information is transferred in the file.
<p>
When propagating a command,
the server uses the authentication information provided for the remote
user by the client to server authentication program.
When propagating or forwarding a job,
the server will use the authentication information stored in the job
control or hold file.
This information will be represented as AUTHUSER in the following discussion.
<p>
The
<tt/auth_forward/ option value specifies the type of authentication
to be used to forward authentication,
and the sending server uses the <tt>auth_server_id</tt> as its identification,
and the <tt/auth_forward_id/ as the identification of the remote server.
If there is no user authentication information,
then a normal, non-authenticated transfer will be done.
<p>
The <tt>auth_forward_filter</tt> will be used for the forwarding
operation.
<p>
The sending server takes the part of the client, and will
transfer a job acting similar to a client.  The initial information
transfer from the sending server will have the format:
<tscreen>
<verb>
\008printer F local_server_id authtype \n     - for commands
\008printer F local_server_id authtype size\n - for print jobs
</verb>
</tscreen>
<p>
The sending server will invoke its authenticator with the arguments:
<tscreen>
<verb>
auth_forward_filter -F -Pprinter -nlocal_server_id -aauthtype \
-Rremote_server_id -Ttempfile
</verb>
</tscreen>
<p>
The tempfile containing the job or command information to be sent
will have the form:
<tscreen>
<verb>
user_authentication_info\n
<normal file contents>
</verb>
</tscreen>
That is,
the user authentication information is placed in the tempfile.
<p>
The tempfile will be transferred to the remote server in the same fashion
as for a user job.
Any error or logging information returned will either be written to the
<tt>lpd</tt> log file or to the previous <tt>lpd</tt> process in
the transfer chain.
<p>
On the destination server the same operations
for receiving an authentication request from a client
is performed.
The AUTHUSER, AUTHFROM, and AUTHTYPE permission
checking values will be the derived from the
authentication request as for the client.
The AUTHSAMEUSER will compare the remote client authentication
information and the authentication information used to create the job.
<p>
When the remote server receives the authentication request,
it will carry out the same actions as for a client to server transfer,
modified as follows:
<enum>
<item>
The <tt>lpd</tt> server will remove the first line of the transferred file,
which contains the user authentication information,
and set
AUTHUSER to this value.
<item>
Authentication is performed using the indicated values.
<item>
If authentication succeeds,
then the command line or print job control file is processed
in the normal manner.
This might now add more permissions values to tags,
but the authentication information will not be changed.
</enum>
<sect1>Permission Checking
<p>
The following patterns and values can be used
to check that a particular type of authentication
has been used,
and what the authenticated user information is.
<itemize>
<item>
AUTH - authentication is used
<item>
AUTHTYPE=globmatch
<newline>
<p>
This matches the type of authentication request.
Built in values include
<tt/kerberos4/,
<tt/kerberos5/,
and
<tt/pgp/.
<item>
AUTHUSER=globmatch
<newline>
<p>
The originating auth_user_id value.
<item>
AUTHFROM=globmatch
<newline>
<p>
When a command received from a server (i.e.- forwarded by a server),
the value is the the forwarding servers authentication information,
otherwise it is NULL.
<item>
AUTHSAMEUSER
<newline>
<p>
The originating auth_user_id value is compared to the value
used to create the job.
If they are identical,  the match succeeds.
</itemize>
<p>
For example,  to reject non-authenticated operations, the following
line could be put in the permissions file.
<tscreen>
<verb>
REJECT NOT AUTH
</verb>
</tscreen>
<p>
To reject server forwarded authentication as well, we use the following.
Note that the <tt/?/  forces a value to be present.
<tscreen>
<verb>
REJECT AUTH AUTHFROM=?*
</verb>
</tscreen>
<p>
If a remote server has id information FFEDBEEFDEAF,  then the
following will accept only forwarded jobs from this server.  Note
that AUTHFROM will only match on authenticated transfers;
FWDUSER will only match on forwarded transfers.
<tscreen>
<verb>
ACCEPT AUTH AUTHFROM=FFEDBEEFDEAF
REJECT AUTH
REJECT NOT AUTH
</verb>
</tscreen>
<p>
To allow only authenticated users to remove jobs you can use:
<tscreen>
<verb>
ACCEPT AUTH SERVICE=R,M,L,P AUTHSAMEUSER
REJECT AUTH
REJECT NOT AUTH
</verb>
</tscreen>
<sect1>Using PGP for Authentication
<p>
PGP is a well known encryption and authentication program.
For more details see the web site
<htmlurl url="http://www.pgp.net" name="http://www.pgp.net">
or the ftp site
<htmlurl url="ftp://ftp.pgp.net" name="ftp://ftp.pgp.net">.
<p>
LPRng has greatly simplified the use of PGP for authentication
by building in support as follows.
<p>
The LPD server usually runs as user <tt/daemon/,
and opens files as
<tt/daemon/.
The system administrator should establish a home directory for daemon,
and use the PGP key generation facility to create a public and private key
for the <tt/daemon/ user.
By default,
the PGP program puts the public and secret key rings in the
<tt>$HOME/.pgp/</tt> directory,
and sets them to be readable only by the user.
You should log in temporarily as
<tt/daemon/,
run the
<tt/pgp -kg/
command,
and then disable logins for <tt/daemon/.
<p>
The user id chosen for the LPD server should be easily used to identify
the server.
For example,
<tt/lpr@hostname/,
where hostname is the fully qualified domain name of the server is useful.
<p>
The next step is to place the passphrase in a file that is only readable by
<tt/daemon/,
say
<tt>~daemon/.pgp/serverkey</tt>,
with owned by <tt/daemon/,
and with <tt/600/ permissions (read/write only by <tt/daemon/).
This is extremely important,
as if any other users can read this file then security will be severely compromised.
<p>
The next step is to distribute the <tt/lpr@hostname/ public key to all users of the
LPRng server,
and to place the public keys of LPRng users in the <tt/daemon/ public key ring.
This can be done using:
<tscreen>
<verb>
pgp -kxa userid destfile keyfile

Example:
> pgp -kxa lpr@astart /tmp/lprkey ~daemon/.pgp/pubring.pgp
Key for user ID: lpr@astart
512-bit key, key ID BB261B89, created 1999/01/01

Transport armor file: /tmp/lprkey.asc
Key extracted to file '/tmp/lprkey.asc'.
</verb>
</tscreen>
<p>
User can add the <tt/lpr@astart/ key to their public key rings using:
<tscreen>
<verb>
pgp -ka /tmp/lprkey.asc
</verb>
</tscreen>
<p>
Finally,  the administrator will need to add users public keys to the
<tt/daemon/ users public key ring.  This can most easily be done by
copying all the keys (in ASCII text form) to a single file
(<tt>/tmp/keyfile</tt>)and using:
<tscreen>
<verb>
pgp -ka /tmp/keyfile ~daemon/.pgp/pubring.pgp
</verb>
</tscreen>
<sect2>PGP Configuration
<label id="pgppath">
<label id="pgppassphrase">
<label id="pgpserverkey">
<p>
Options used:
<itemize>
<item><tt>pgp_path=</tt><em>path to PGP program</em>
<item><tt>pgp_server_key=</tt><em>path to server passphrase file</em>
<item><tt>pgp_passphrasefile=</tt><em>user passphrase file in PGPPATH or $HOME/.pgp</em>
</itemize>
<p>
The <tt/pgp_path/ option is the path to the PGP program.
<p>
The <tt/pgp_server_key/ is the path to the file containing the server passphrase.
This file will be read by <tt/lpd/ to get the passphrase to unlock the server's
keyring.
<p>
The LPRng client software will check to see if the
<tt/pgp_passphrasefile/  value (default <tt/clientkey/) file in
<tt/$PGPPATH/, and if not present,
then in <tt>$HOME/.pgp</tt>.
By default, the <tt/pass_env/ option is <tt/pass_env=PGPPASS,PGPPATH,PGPPASSFD/
and will pass the values of the PGPPATH, PGPPASS,
and PGPPASSFD environment variables.  See below for a method to use these.
<p>
Example printcap entry:
<tscreen>
<verb>
pr: 
    :lp=pr@wayoff
    :auth=pgp
    :auth_server_id=lpr@wayoff.com
    :pgp_path=/usr/local/bin/pgp
    :pgp_passphrasefile=.mypass
</verb>
</tscreen>
<p>
One problem with using PGP is the need to have users input their
passphrases.
If the user is daring,  then the pass phrase can be put in the file:
<tt>  ~/.pgp/clientkey </tt>.  This file will be read by the
LPRng client program the contents passed to PGP as the passphrase.
This file MUST have 0400 permissions (read only by user)
and MUST owned by the user.
<p>
A more subtle solution is to use the <tt/PGPPASSFD/ environment variable
facility.
This causes PGP to read the passphrase from a file descriptor.
If the user puts his passphrase in a file,  say
<tt>$(HOME)/.pgp/.hidden</tt>,
then the following shell script can be used.
<tscreen>
<verb>
#!/bin/sh
#  /usr/local/bin/pgplpr script - passphrase in $(HOME)/.pgp/.hidden
#
PGPASSFD=3 3<$(HOME)/.pgp/.hidden lpr "$@"
</verb>
</tscreen>
<sect2>Permissions
<p>
If you wish to enforce the use of authentication,  then you
should modify the lpd.perms file.  Here are some examples.
<tscreen>
<verb>
# force authentication
REJECT NO AUTH
REJECT NO AUTHTYPE=pgp
</verb>
</tscreen>
<sect2>Client Configuration
<p>
One problem with using PGP is the need to have users input their
passphrases.
If the user is daring,  then the pass phrase can be put in the file:
<tt>  ~/.pgp/clientkey </tt>.  This file will be read by the
LPRng client program the contents passed to PGP as the passphrase.
This file MUST have 0400 permissions (read only by user)
and MUST owned by the user.
<p>
A more subtle solution is to use the <tt/PGPPASSFD/ environment variable
facility.
This causes PGP to read the passphrase from a file descriptor.
If the user puts his passphrase in a file,  say
<tt>$(HOME)/.pgp/.hidden</tt>,
then the following shell script can be used.
<tscreen>
<verb>
#!/bin/sh
#  /usr/local/bin/pgplpr script - passphrase in $(HOME)/.pgp/.hidden
#
PGPASSFD=3 3<$(HOME)/.pgp/.hidden lpr "$@"
</verb>
</tscreen>
<p>
By using the -V (verbose) flag,  users can see the results of the
PGP interaction.
<sect1>Using Kerberos 5 for Authentication
<p>
LPRng Kerberos 5 authentication is
based on the
Kerberos5-1.0.5 release as of March 28, 1999.  This was obtained
from MIT:
<enum>
<item> ftp to ATHENA-DIST.MIT.EDU (18.159.0.42), login anonymous, password
your_email_address
<item> Change into the directory '/pub/kerberos/
<item> Get the README files and look at the details of using FTP to get
the distribution.  Note that there are also patches available
which you might want to use.
</enum>
<p>
Note that the distribution has only the most superficial documentation.
There are no man pages for any of the support libraries, etc. etc.
<sect2>Kerberos Installation Procedure
<label id="kerberoskeytab">
<label id="kerberoslife">
<label id="kerberosrenew">
<label id="kerberosservice">
<label id="kerberosserverprincipal">
<label id="kerberosforwardprincipal">
<p>
<enum>
<item> Get the Kerberos 5 distribution.
<item> Compile and install the distribution.
<item> Create the /etc/krb5.conf, /usr/local/var/krb5kdc/kdc.conf
files using templates from the src/conf-files subdirectory.
See the Installation notes and the System Administrators Guide.
<item> Don't forget to create the /usr/local/var/krb5kdc/kdc.acl file;
I did and it took me HOURS to figure out what was wrong...
<item> Start up the KDC and KADMIN servers - you might want to put
the following in your rc.local or equivalent file:
<tscreen>
<verb>
if [ -f /etc/krb5.conf -a -f /usr/local/var/krb5kdc/kdc.conf  ]; then
    echo -n ' krb5kdc ';    /usr/local/sbin/krb5kdc;
    echo -n ' kadmind ';    /usr/local/sbin/kadmind;
fi
</verb>
</tscreen>
<item> use kadmin (or kadmin.local) to create principals for your users.
<item> Now you need to create principals for the lprng servers.  I have been
using
<tt>lpr/hostname.REALM</tt>
as a template-
i.e.
<tt>lpr/astart1.astart.com@ASTART.COM</tt>
for an example.
<p>
Do this for all the servers.  You should use fully qualified domain names
for the principals.
<item> Now you need to extract the keytab for each of the servers:
<tscreen>
<verb>
kadmin ...
ktadd -k file_for_host  lpr/hostname.REALM
</verb>
</tscreen>
<p>
The 'file_for_host' contains the keytab information, which is the
equivalent information for the server.
<item> Copy the 'file_for_host' to the server (you might want to encrypt
or use a secure transfer for this).  You need to put this in
<tt>/etc/lpd.keytab</tt>.
Make sure that this file is readable only by user <tt>daemon</tt>,
as it will try to read the file to get its server key.
<tscreen>
<verb>
#> ls -l /etc/lpd.keytab
-rw-------  1 daemon  wheel  128 Jan 16 11:06 /etc/lpd.keytab
</verb>
</tscreen>
<item> Modify (uncomment) the following entries in <tt>/etc/lpd.conf</tt>:
<tscreen>
<verb>
auth=kerberos5
kerberos_keytab=/etc/lpd.keytab
kerberos_service=lpr
# optional - explicit prinicpal name for server, used by clients
#kerberos_server_principal=lpr/hostname@REALM
# optional - forwarding to another server with authentication
# kerberos_forward_principal=lpr/hostname@REALM
</verb>
</tscreen>
<p>
The
<tt/kerberos_keytab/
entry is the location of the keytab file;
kerberos_service is the service that will be used to generate
a server principal name.
This is the
<tt/lpr/
used in the above key generation operations.
<p>
kerberos_life and kerberos_renew determine the lifetime and renewability
of Kerberos tickets.  The lifetime defaults to 10
hours,  and the ticket will be refreshed when it expires
if necessary.
<item>
You might like to check out the authentication using the sclient and
sserver test programs.  These link in the kerberos authentication and
allow you to test it without all of LPD being involved.
<tscreen>
<verb>
cd LPRng/src; make sserver sclient
usage: sserver [-D] [-p port] [-s service] [-S keytab] file
   -D turns debugging on
   1. opens TCP   port 'port' (default 1234)
   2. waits for a connection
   3. when a connection comes in,  uses 'service' to get the principal
       name of the server,  and looks up the key in keytab file.
   4. Goes through the kerberos authentication.
   5. Copies the input from remote server to 'file'
   6. exits.
 usage: sclient [-D] [-p port] [-s service] host file
   -D turns debugging on
   1. opens a connection to port on host (i.e. - host%port)
   2. does the authentication.  You must have done kinit to get
       for your ticket to be valid.
   3. sends the file to remote host.
</verb>
</tscreen>
<p>
To test this, start up sserver on one host/window, then run sclient.
The error messages are pretty straight forward,
and when in doubt,
look at the source code which has more than sufficient information.
</enum>
<sect2>Testing Transfers
<p>
Restart the server,
and then try getting information using LPQ.
<p>
You can turn on tracing at LPQ to see if authentication is being used
and is working:
<tscreen>
<verb>
lpq -Dnetwork,database 
</verb>
</tscreen>
<p>
If the lpq works,
then try send a job and see if the transfer is successful.
<sect2>Explicit Server Principal Name
<p>
If you are using printers in different domains,  then you can
put the explicit principal name of the server in the printcap file,
using the server_principal entry.  For example:
<tscreen>
<verb>
lp_offsite
    :lp=printer@erehwon.org
    :auth=kerberos5
    :auth_server_id=lpr/erehwon.org@BLUESKY.ORG
</verb>
</tscreen>
<sect1>Using Kerberos 4 for Authentication
<p>
LPRng has built-in support for the Project Athena extensions to the
RFC1179 protocol.
These provide an extremely simple authentication protocol
using an initial credential exchange.
After the initial exchange the usual RFC1179 protocol is used.
<p>
To enable Kerberos 4 support,
you must modify the <tt>LPRng/src/Makefile</tt> and recompile
the LPRng code.
You should be aware that this is not a supported extension,
and is provided as a courtesy to MIT and Project Athena.
<sect>Status Monitoring and Logging
<label id="statusref">
<label id="stalledtime">
<p>
Options used:
<itemize>
<item><tt>stalled_time#</tt><em>time after which to report a stalled active job
</em></itemize>
<p>
The most commonly used tool for LPRng status is LPQ.
However,
the LPC command can be used,
and you can also get real time logging of status to a remote host.
<p>
<sect1>LPQ status reporting
<p>
The LPQ status display produced by LPRng has three formats.
<sect1>LPQ Short Format (lpq -s)
<p>
This is one line per spool queue:
<tscreen>
<verb>
% lpq -sa
t1@astart110  (printing disabled) 1 job
t2@astart110  (routed/bounce to t1@astart110.astart.com) 0 jobs
t3@astart110  (forwarding to t3a@astart110.astart.com)
t3a@astart110  (forwarding to t2@astart110.astart.com)
t4@astart110  (subservers t5, t6)  0 jobs
t5@astart110  (serving t4) 0 jobs
t6@astart110  (serving t4) 0 jobs
</verb>
</tscreen>
<p>
Note that the name of the printer/host is first,
followed by optional status information, followed by
the number of jobs.  Only printcap entries with
spool queues have a jobs word in the last position.
The
<tt>-a</tt> option forces status for all queues or the
queues in the <tt>all</tt> printcap entry to be returned.
<p>
The <tt>stalled_time</tt> (default 120 seconds) printcap option can be used to set a
time after which active jobs will be reported as stalled.
<sect1>LPQ Long Format (lpq default, lpq -l, lpq -L)
<p>
This is the default status display.
It is a nicely formatted, extremely verbose format
that is suitable for humble human interpretation. For example:
<tscreen>
<verb>
% lpq -a
Printer: t1@astart110  'Test Printer 1' (printing disabled)
 Queue: 1 printable job
 Server: no server active
 Status: finished operations at 09:44:00
 Rank   Owner/ID                   Class Job  Files               Size Time    
1       papowell@astart110+202228663    A 10663 /tmp/hi               3 20:22:29
Printer: t2@astart110  'Test Printer 2' (routed/bounce to t1@astart110.astart.com)
 Queue: no printable jobs in queue
 Status: finished operations at 16:30:08
Printer: t3@astart110  (forwarding to t3a@astart110.astart.com)
Printer: t3a@astart110  (forwarding to t2@astart110.astart.com)
Printer: t4@astart110  (subservers t5, t6) 
 Queue: no printable jobs in queue
 Status: finished operations at 09:44:06
Server Printer: t5@astart110  (serving t4)
 Queue: no printable jobs in queue
 Status: finished operations at 09:44:06
Server Printer: t6@astart110  (serving t4)
 Queue: no printable jobs in queue
 Status: finished operations at 09:10:00
</verb>
</tscreen>
<p>
The <tt/lpq -l/ (longer information)
option causes more of the status information to be printed.
You can use increasing numbers of <tt/lpq -l/ options
(<tt/ lpq -ll/ also works) to get more status.
Use <tt/ lpq -L/ for the maximum amount of status information.
<sect1>LPQ Verbose Format (lpq -v)
<p>
This uses an extension to the RFC1179 protocol,
and is supported only by LPRng.
The amount of information displayed is the brutal,
and in effect does a total database dump
of the LPD.
This has been developed in order to provide diagnostic
and status information for databases that need to keep track of
job progress through a spool queue.
<tscreen>
<verb>
% lpq -v
Printer: t1@astart110
 Comment: Test Printer 1
 Printing: no
 Spooling: yes
 Queue: 1 printable job
 Server: no server active
 Status: accounting at end 'papowell@astart110+094352860' at 09:44:00
 Status: printing 'papowell@astart110+094352860', closing device at 09:44:00
 Status: printing 'papowell@astart110+094352860', finished  at 09:44:00
 Status: subserver status 'JSUCC' for 'papowell@astart110+094352860' \
            on attempt 1 at 09:44:00
 Status: finished operations at 09:44:00
 Job: papowell@astart110+202228663 status= 1
 Job: papowell@astart110+202228663 CONTROL=
 - Hastart110.astart.com
 - Ppapowell
 - J/tmp/hi
 - CA
 - Lpapowell
 - Apapowell@astart110+202228663
 - Qt1
 - fdfA010663astart110.astart.com
 - N/tmp/hi
 - UdfA010663astart110.astart.com
 Job: papowell@astart110+202228663 HOLDFILE=
 - active 0
 - done 0
 - hold 0
 - move 0
....
</verb>
</tscreen>
<sect1>lpc status
<p>
The LPC status command is used to show the status of the queues
currently being managed by the LPRng server.
Note that this form of the command is supported only by LPRng,
and is not backwards compatible with BSD LPR implementations.
<tscreen>
<verb>
%lpc status all
 Printer           Printing Spooling Jobs  Server   Slave Redirect Status/Debug
lw4@astart4         enabled  enabled    0    none    none
lw5@astart4         enabled  enabled    0    none    none
</verb>
</tscreen>
<p>
The status display has a heading line and summary of the server status.
<sect1>Remote Logger Operation
<p>
Several sites have wanted a way to provide central logging of job
status and/or information.  In order to do this,  the following functionality
is provided with LPRng.
<sect2>Logger Network Communication
<label id="loggerdestination">
<label id="loggerpathname">
<label id="loggertimeout">
<label id="loggermaxsize">
<p>
Options used:
<itemize>
<item><tt>logger_destination=</tt><em>logger information destination</em>
<item><tt>logger_pathname=</tt><em>pathname of temp file for log information</em>
<item><tt>logger_max_size=</tt><em>max size in K of temp file for log information</em>
<item><tt>logger_timeout=</tt><em>time between connection attempts</em>
</itemize>
<p>
The printcap/configuration variable <tt>logger_destination</tt> specifies
a destination in the standard
<tt/host%port/
notation used by LPRng.
Host is the destination host, and can be a name or IP address.
Port is the port on the destination host.
A TCP/IP connection is made to the indicated port.
<p>
Log information is save in a temporary file specified by
<tt/logger_path/,
and up to
<tt/logger_max_size/  K bytes of data will be saved.
<p>
If a connection cannot be made to the
<tt/logger_destination/,
then every
<tt/logger_timeout/ seconds a new connection attempt will be made.
If <tt/logger_timeout/ is 0,
then a connection attempt will be made every time new data arrives to be logged.
<sect2>Logger Messages
<p>
Log messages consist of a single line
terminated with a newline (<tt>\n</tt>) character.
<p>
Each log message reports a system event or status change of the
LPD server.
When the connection is first established,
a complete dump of the status of the LPD server is sent.
After this,
only status update messages are sent.
The remote monitor can force a status dump by simply closing and
reopening the connection.
<sect2>Message Format
<p>
Each message is encoded as a URI escaped string.
That is, non-alphanumeric characters are encoded as the 3 character
sequence <tt/%xx/,  where <tt/xx/ is the hexadecimal value of the character.
The message has the format <tt/key=value/,
where <tt/key/ indicates the message type.
For example:
<tscreen>
<verb>
dump=host=astart4.astart.com%0aprinter=t1%0aprocess=1613%0aupdate_time=1999-03-2
  3-20:32:17.148%0avalue=queue=holdall 0%25250aprinting_aborted=0x0%25250aprinting
  _disabled=0x0%25250aspooling_disabled=0x0%25250a%250a%0a
</verb>
</tscreen>
<p>
The following keys are used:
<enum>
<item>
dump
<newline>
A status dump of the current contents of a print queue.
</enum>
<p>
Each message has a set of headers and a value.
For example,
the decoded dump message from the previous section would be:
<tscreen>
<verb>
host=astart4.astart.com
printer=t1
process=1613
update_time=1999-03-23-20:32:17.148
value=queue=holdall 0%250aprinting_aborted=0x0%250aprinting_disabled=0x0%250aspo
  oling_disabled=0x0%250a%0a
</verb>
</tscreen>
<p>
Each line consists of a key and a value.
The
<tt/host/ key indicates the host name,
<tt/printer/ is the print queue,
<tt/process/ is the process which generated the report or action,
<tt/update_time/ is the time at which the report was generated,
and
<tt/value/ is the value of the report.
<p>
The decoded <tt/value/ of the above report is:
<tscreen>
<verb>
queue='holdall 0%0aprinting_aborted=0x0%0aprinting_disabled=0x0%0aspooling_dis
  abled=0x0%0a
</verb>
</tscreen>
<p>
The <tt/queue/ key provides the current value of the queue control file.
<sect2>Dump Messages
<p>
Dump messages are generated at the start of operations,
and consist of a list of queue status messages.
<sect2>LPD Messages
<p>
These are used to indicate LPD startup or change in operation.
<tscreen>
<verb>
Decode: lpd=host=astart4.astart.com%0aprocess=1672%0aupdate_time=1999-03-23-20:5
1:10.507%0avalue=Starting%0a
host=astart4.astart.com
process=1672
update_time=1999-03-23-20:51:10.507
value=Starting
lpd: 'Starting'
</verb>
</tscreen>
<sect2>Job Status Messages - UPDATE
<p>
Update messages are used to report changes in the queue contents,
such as job arrival.
<tscreen>
<verb>
Decode: update=host=astart4.astart.com%0aidentifier=papowell@astart4+676%0anumber=
 ...
host=astart4.astart.com
identifier=papowell@astart4+676
number=676
printer=t1
process=1677
update_time=1999-03-23-20:51:17.197
value=bnrname=papowell%0acf_esc_image=Apapowell@astart4+676%250aCA%250aD1999-03-
  ...
</verb>
</tscreen>
<p>
This update message reports the arrival of a new job at the queue.
The <tt/value/ field reports the control file contents:
<tscreen>
<verb>
cf_esc_image=Apapowell@astart4+676%0aCA%0aD1999-03-23-20:51:17.151%0aHastart4.as
   tart.com%0aJ/tmp/hi%0aLpapowell%0aPpapowell%0aQt1%0aN/tmp/hi%0afdfA676astart4.as
   tart.com%0aUdfA676astart4.astart.com%0a
class=A
date=1999-03-23-20:51:17.151
file_hostname=astart4.astart.com
fromhost=astart4.astart.com
held=0x0
hf_name=/var/tmp/LPD/t1/hfA676
hold_class=0x0
hold_time=0x0
identifier=papowell@astart4+676
job_time=0x36f86f45
jobname=/tmp/hi
logname=papowell
number=676
priority=A
queuename=t1
size=3
transfername=cfA676astart4.astart.com
update_time=1999-03-23-20:51:17.187
</verb>
</tscreen>
<p>
The <tt/update_time/ field in the section above is the time that the
job information was last updated.
The <tt/cf_esc_image/ value is the URL escaped control file information.
<sect2>Printer Status Messages - PRSTATUS 
<p>
These messages report printing or other activity related to a job.
<tscreen>
<verb>
Decode: prstatus=host=astart4.astart.com%0aidentifier=papowell@astart4+676%0anumber=
676%0aprinter=t1%0aprocess=1692%0aupdate_time=1999-03-23-21:02:04.855%0avalue=
finished 'papowell@astart4+676'%252c status 'JSUCC'%0a

host=astart4.astart.com
identifier=papowell@astart4+676
number=676
printer=t1
process=1692
update_time=1999-03-23-21:02:04.855
value=finished 'papowell@astart4+676'%2c status 'JSUCC'
PRSTATUS: 'finished 'papowell@astart4+676', status 'JSUCC''
</verb>
</tscreen>
<sect1>LPR -mhost%port and user logging support
<label id="allowuserlogging">
<label id="mail">
<p>
The <tt>lpr -m</tt> option is used to request that <tt>lpd</tt>
send mail to the user when a job has completed.
LPRng extends this to allow mail addresses of the form
<tt> host[%port][/(TCP|UPD)]</tt> to request that logging information
be sent to the user as well.
<p>
The administrator should be aware that this is a possible security loophole,
and that the
<tt>allow_user_logging</tt>
flag must be enabled to
allow this operation.
<sect>RFC 1179 - Line Printer Daemon Protocol
<label id="rfc1179ref">
<p>
RFC1179 can be obtained from the LPRng distribution, in the LPRng_DOC/rfc1179 directory,
or from one of many sites which mirror the RFCs.
<p>
This RFC is an <em>informational</em> RFC,
which means that the information in it is meant as a guide to users,
and not as a fixed standard.
In addition,
the RFC tried to document the behavior of the BSD LPD print server,
and left out many details dealing with error recover,
error messages,
extensions to the protocol,
etc.
<p>
In this section,
I will try to explain what RFC1179 specifies as a protocol,
and many of the problems encountered in trying to use it.
<sect1>Ports and Connections
<label id="lpdport">
<label id="originateport">
<label id="reuseaddr">
<label id="retryeconnrefused">
<label id="retrynolink">
<label id="socketlinger">
<p>
Options used:
<itemize>
<item> <tt>lpd_port=</tt><em>Port for LPD to accept connection</em>
<item> <tt>originate_port=</tt><em>Ports to originate connections on</em>
<item> <tt>reuse_addr</tt><em>&nbsp;&nbsp;Set SO_REUSEADDR flag on connection</em>
<item> <tt>retry_econnrefused</tt><em>&nbsp;&nbsp;Retry on connect ECONNREFUSED error</em>
<item> <tt>retry_nolink</tt><em>&nbsp;&nbsp;Retry on device open or connection ffailure</em>
<item> <tt>socket_linger#</tt><em>&nbsp;&nbsp;Linger time for sockets</em>
</itemize>
<p>
RFC1179 requires that the <tt>lpd</tt> server listen for TCP/IP connections
on port 515.
This port is registered with the Internet Naming Authority,
and the <tt>/etc/services</tt> file or TCP/IP services database usually has an entry:
<tscreen>
<verb>
printer     515/tcp     spooler     # line printer spooler
</verb>
</tscreen>
<p>
RFC1179 explicitly states that all connections to port 515 must originate from
ports 721-731.
The reason for this restriction is due to the UNIX concept of <em>reserved</em>
and <em>privileged</em> ports.
By convention,
ports in the range 1-1023 can only <bf>bound</bf> by processes whose Effective User ID (EUID)
is 0 (root).
This,
ordinary users could not originate a connection from the reserved or privileged port range.
<p>
In a UNIX environment,  this means that the user programs
<tt>lpr</tt>,
<tt>lprm</tt>,
<tt>lpq</tt>,
and
<tt>lpc</tt>
would have to be SETUID root.
<p>
As experience has shown, for security purposes,
the fewer programs that need to have privileged status,
the better.
LPRng uses the
<tt>lpd_port=printer</tt> configuration option to set the actual port to be use.
By default, this is port 515, but can be set to other values.
<p>
The restriction of originating ports to 721-731 causes another set of problems.
Part of the TCP/IP protocol is concerned with avoiding communications problems
resulting from the arrival of old or <em>stale</em> packets.
When a connection between
<tt>sourcehost, sourceport</tt> and <tt>desthost, destport</tt>
is made,
a set of sequence numbers is established and used for sending and acknowledgement of data.
When the connection terminates,
the TCP/IP protocol restricts the establishment of a new connection between
<tt>sourcehost, sourceport</tt> and <tt>desthost, destport</tt> for a period long
enough for all <em>stale</em> packets to be removed from the system.
This is approximately 10 minutes long.
<p>
In order to simplify assignments of ports,
timing out connections, and other matters,
many TCP/IP packages do keep track of explicit connections
<em>originating</em> from a port,
but simply prevent the port from being reused for either origination
or reception of a connection.
They do,
however,
keep track of the active connections <bf>to</bf> a port,
and perform timeouts on these.
This is usually much simpler to implement,
as it can be done with a list attached to the port.
<p>
This implementation method creates some problems when
a large number of connections must be originated from a
relatively small number of port numbers.
Observe what happens when host 1 tries to send a large number of jobs to a server 2.
The following connections are established and terminated:
<newline><tt>host 1, port 721</tt> and <tt>host 2, port 515</tt>
<newline><tt>host 1, port 722</tt> and <tt>host 2, port 515</tt>
<newline><tt>host 1, port 723</tt> and <tt>host 2, port 515</tt>
<newline><tt>host 1, port 724</tt> and <tt>host 2, port 515</tt>
<newline><tt>host 1, port 725</tt> and <tt>host 2, port 515</tt>
<newline><tt>host 1, port 726</tt> and <tt>host 2, port 515</tt>
<newline><tt>host 1, port 727</tt> and <tt>host 2, port 515</tt>
<newline><tt>host 1, port 728</tt> and <tt>host 2, port 515</tt>
<newline><tt>host 1, port 729</tt> and <tt>host 2, port 515</tt>
<newline><tt>host 1, port 730</tt> and <tt>host 2, port 515</tt>
<newline><tt>host 1, port 731</tt> and <tt>host 2, port 515</tt>
<p>
Now according to the RFC1179 rules and the TCP/IP protocol,
we will have to wait until one of these connections terminates before we
can make another.
On the originating system,
if the TCP/IP implementation does timeouts on the originating port,
we will have to wait for the timeout to elapse before we can make a new
connection.
Unfortunately,  there is no way to find out what the status of the port
is,  so we will have to try them each in turn until we get
a successful connection.
<p>
The LPRng code has tried to provide several methods to deal with
these problems.
Firstly,
the
<tt>originate_port=512 1023</tt>
option specifies the range
of ports used to originate connections
when the software is running either as ROOT or SETUID root.
By strict RFC1179 rules,
this should be
<tt>originate_port=721 731</tt>,
but it turns out that most BSD LPD based implementations only
check for a <em>reserved</em> originating port.
By using 512 ports we get a greatly reduced rate of errors due
to lack of ports due to pending timeouts.
<p>
However,
on some systems which are acting as servers for a large number of
printers even increasing this port range is insufficient,
and steps need to be taken use the originating port numbers
more efficiently.
The Berkeley TCP/IP implementation
<tt>getsockopt()</tt>
and
<tt>setsockopt()</tt>
allows the user to manipulate some of the underlying timeouts and options
of the TCP/IP network.
When a TCP/IP connection is established,
the
<tt>setsockopt()</tt>
facility can be used to set the
<tt>SO_REUSEADDR</tt>
flag on the connection.
This flag effectively sets the timeout value on the ports
and connections to 0,
allowing immediate reuse of the ports.
When done on an originating end of a connection,
this will allow the originating port number to be reused immediately.
<p>
It would appear that by setting
<tt>SO_REUSEADDR</tt>
on the originating end that we have solved our problems.
However,
unless the destination end of the connection sets its
<tt>SO_REUSEADDR</tt>
flag on the connection,
it will still do a timeout.
Thus when we try to make a connection from a port
that was active within a short period of time to the
same host,
then it will reject the connection until the
timeout is over.
<p>
The
<tt>reuse_addr</tt>
flag (default off) forces
the LPRng software to set the
<tt>SO_REUSEADDR</tt>
flag on originating connections.
As indicated,
this will allow ports to be reused immediately for outgoing connections,
rather than waiting for a timeout.
<p>
While the
<tt>reuse_addr</tt>
flag usually allows us to reuse ports,
there is still the problem of dealing with connections failing due to the
remote site rejecting the connection due to a pending timeout
from a previous connection.
A careful study of the original BSD TCP/IP network code and of some
others indicates that when a connection fails due to a pending timeout,
an ECONNREFUSED error code is returned to a
<tt>connect()</tt> system call.
If this happens and we suspect that the remote site is rejecting
the connection due to a timeout problem,
then we should retry making the connection but from a new port,
and continue retrying until all possible ports are used.
<p>
The <tt>retry_econnrefused</tt> (default on) flag is used to
specify that we retry connections in this manner.
When this is set,
a <tt>connection refused</tt>
error causes the connection to be retried using a new port.
This will be repeated until all available ports have been tried.
<p>
When 
printing a job and the <tt>lpd</tt> server connection to a remote
site or device open fails,
the <tt>retry_nolink</tt> (default on)
will cause the attempt to be retried indefinitely.
The combination of <tt>retry_econnrefused</tt> and <tt>retry_nolink</tt>
will provide robust connection attempts to remote systems.
<p>
While the above problems cause difficulties when making connections,
there are also problems when terminating connections.
After closing a socket,
the TCP/IP software will try to flush any pending data to the destination.
Unfortunately,
on some systems it will only do this while the process is active.
This has caused problems on systems which terminate
a process it has received an abnormal (signal caused) termination.
<p>
The <tt>setsockopt()</tt> SO_LINGER option allows the user to specify
that when a socket is closed normally,
that the process should block until pending data is flushed or
for the <tt>socket_linger</tt> period.
If <tt>socket_linger</tt> is 0,
then no SO_LINGER operation is done.
<p>
In summary, if you experience problems with connection failures due
to port exhaustion,
first try setting the
<tt>reuse_port</tt> flag,
and you should see a reduction.
Check to ensure that the <tt>retry_econnrefused</tt>
and <tt>retry_nolink</tt> flags are set,
and the error code in the log and status files.
If the failures continue,  then the problem is caused by the
remote end having timeout limitations and there is little you
can do except to set a very long <tt>connect_retry</tt>
interval, say <tt>connect_retry=120</tt> (2 minutes).
<sect1>Protocol Requests and Replies
<label id="remotesupport">
<p>
Options used:
<itemize>
<item> <tt>remote_support=</tt><em>Remote operations supported</em>
</itemize>
<p>
After a connection has been established,
a request can be sent to the <tt>lpd</tt>
server.
The request consists of a single octet indicating the request type,
followed by the printer (or print queue) name, followed by
a set of options for the request,
followed by a LF (line feed) character.
<tscreen>
<verb>
\NNNprinter[ options]\n
  NNN    Operation
</verb>
</tscreen>
<p>
<table>
<tabular ca="|l|l|l|l|">
NNN
|
RFC1179
|
Operation
|
program
@
1
|
yes
|
start print
|
<tt>lpc</tt>
@
2
|
yes
|
transfer a printer job
|
<tt>lpr</tt>
@
3
|
yes
|
print short form of queue status
|
<tt>lpq</tt>
@
4
|
yes
|
print long form of queue status
|
<tt>lpq</tt>
@
5
|
yes
|
remove jobs
|
<tt>lprm</tt>
@
6
|
LPRng
|
do control operation
|
<tt>lpc</tt>
@
7
|
LPRng
|
transfer a block format print job
|
<tt>lpr</tt>
@
8
|
LPRng
|
secure command transfer
|
<tt>lpc</tt>
@
9
|
LPRng
|
verbose status information
|
<tt>lpq</tt>
@
</tabular>
</table>
<p>
After the request has been sent,
then a reply will be returned.
In general the reply has the following form:
<tscreen>
<verb>
\000\n    Success
\NNN\n    Failure (NNN is error code)
text\n    Text or status information
</verb>
</tscreen>
<p>
As can be seen,
this protocol is extremely simple,
but there are a set of problems due to the loosely written language of RFC1179.
<enum>
<item>
Firstly,
while RFC1179 sets limits on the lengths of commands,
it does not strictly set limits on the characters set used in the commands.
This can result in problems when trying to print status information,
headers on banners,
and other details.
<item>
The original RFC1179 protocol did not provide any way to do remote control
of queues or LPD servers.
This has been added to the protocol.
As a side effect,
if you try to use
<tt>lpc</tt> to control a non-LPRng printer,
it will not work.
<item>
You can specify that a network printer is non-LPRng by using the
<tt>remote_support=RQVMC</tt> option and specify the operations
supported by the printer.
The letters R, Q, V, M, and C stand for
<tt>lpr</tt>,
<tt>lpq</tt>,
<tt>lpq -v</tt> (verbose),
verbose <tt>lpq</tt>,
<tt>lprm</tt>,
and <tt>lpc</tt> operations respectively,
and indicate that these are supported.
If <tt>remote_support</tt> does not allow a particular operation,
then the LPRng software will not send a corresponding request to the printer.
For example,
<tt/remote_support=R/
would restrict operations to spooling jobs only,
and the LPRng software would not query the printer for status.
</enum>
<sect1>Job Transfer
<label id="senddatafirst">
<label id="longnumber">
<label id="useshorthost">
<p>
Options used:
<itemize>
<item> <tt>longnumber</tt><em>&nbsp;&nbsp;Long job number (6 digits)</em>
<item> <tt>send_data_first</tt><em>&nbsp;&nbsp;Send data files first</em>
<item> <tt>use_shorthost</tt><em>&nbsp;&nbsp;Use short hostname</em>
</itemize>
<p>
A job transfer operation starts with a job transfer request,
followed by several file transfer operations.
At the end of the file transfers,
the connection should be closed.
<p>
A file transfer request has the form:
<table>
<tabular ca="|l|l|l|l|">
Command
|
Purpose
@
\001\n
|
abort
@
\002nnnn cfname
|
control file transfer
@
\003nnnn dfname
|
data file transfer
@
</tabular>
</table>
<p>
The abort operation is used to terminate job transfer and indicate that
the job should not be processed for printing.
The connection will be closed and the partly transferred job
will be discarded.
<p>
The control file and data file transfer commands have a length (in bytes)
of the file and the name of the file to be transferred.
When the command is received,
the server will reply with a status line:
<table>
<tabular ca="|l|l|l|l|">
Status
|
Purpose
@
\000
|
Accepted, proceed
@
\nnn
|
Rejected with error code
@
</tabular>
</table>
<p>
The reply is only a single octet.
Some defective implementations of RFC1179 send a LF after the octet,
which makes life very difficult.
LPRng makes an effort to detect these non-conforming RFC1179 systems
and will accept jobs from them.
However,  it will not send jobs to them.
<p>
If LPRng sends a reject code, as an extension to RFC1179 it also
sends an error message.   Note that the values for error codes
are not defined,
nor are their causes.
LPRng uses the following values for error codes,
which appear to be compatible with many,
but not all, of the BSD LPD based systems:
<table>
<tabular ca="|l|l|l|l|">
Code
|
Error
@
\000
|
Accepted, proceed
@
\001
|
Queue not accepting jobs
@
\002
|
Queue temporarily full, retry later
@
\003
|
Bad job format, do not retry
@
</tabular>
</table>
<p>
When the sender gets the reply indicating success,
it sends the <tt>nnnn</tt> bytes of the control or data file,
followed by a <tt>\000</tt> octet.
The receiver will then reply as above;
a single <tt>\000</tt> octet indicating success.
<p>
The above procedure is carried out until all data files and the control
file of a job are transferred.
<p>
RFC1179 is silent on the following issues:
<enum>
<item>
When sending a job,
do you send the control file first, followed by the data file(s),
or the data files first?
<item>
When sending multiple jobs,
can you send them on a single connection,
or do you have to establish a new connection for each job?
</enum>
<p>
LPRng will <em>accept</em> jobs whether they are sent control or data files
first.
By default,
it sends the control file first,
followed by the data file.
If the destination system requires that the data files
be sent first,
the <tt>send_data_first</tt> printcap option can be used to force
data files to be sent first.
<p>
RFC1179 states that:
<quote>
The name of the control file ... should start with ASCII "cfA", followed by a three
digit job number, followed by the host name which has constructed the
control file.
</quote>
<p>
The <em>should</em> in this wording indicates that this is simply a guideline,
and that other formats are possible.
Some of the major problems with this format are as follows:
<enum>
<item> The restriction to 3 digits means that at most 1000 jobs
can be in a queue.
Strangely,  some systems generate far more than 1000 jobs a day,
and need to archive them on a regular basis.
The <tt>longnumber</tt> option will allow LPRng to use a 6 digit
job number for files in the print queue.
<item>The host name format is not specified.
Some implementations consider that this is the short host name,
while others think it is the fully qualified domain name (FQDN).
LPRng,
by default,
will use the FQDN host name.
However,  the <tt>use_shorthost</tt> option will force it to
use short host names in control and data files.
<item>
The <tt>cfA</tt> control file name was modified to allow the
job priority to be used as the A letter of the control file.
By default,
this is A (lowest, i.e. <tt>cfA</tt>) and
but can range to Z (highest, i.e. <tt>cfZ</tt>).
All known spoolers except LPRng seem to ignore the actual value of
the letter.
</enum>
<sect1>Data File Transfer
<p>
As discussed,
a data file is transferred using the command below.
<table>
<tabular ca="|l|l|l|l|">
Command
|
Purpose
@
\003nnnn dfname
|
data file transfer
@
</tabular>
</table>
<p>
From RFC1179:
<quote>
The data file may contain any 8 bit values at all.  The total number
of bytes in the stream may be sent as the first operand, otherwise
the field should be cleared to 0.  The name of the data file should
start with ASCII "dfA".  This should be followed by a three digit job
number.  The job number should be followed by the host name which has
constructed the data file.  Interpretation of the contents of the
data file is determined by the contents of the corresponding control
file.
</quote>
<p>
There are several surprises in RFC1179.
<enum>
<item>
Apparently a job should only consist of a single data file.
This is a severe limitation,  and in fact the BSD LPR and other
print spoolers process jobs with multiple data files.
By convention, these data files have names of the form
<tt>dfA</tt>,
<tt>dfB</tt>,
...
<tt>dfZ</tt>,
<tt>dfa</tt>,
<tt>dfz</tt>.
<item>
The RFC does not specify that the control file and data file job numbers
must be identical.
Most implementations follow this convention, which simplifies life
tremendously.
<item>
The RFC does not specify that the control file and data file job host names
must be identical.
Most implementations follow this convention, which simplifies life
tremendously.
<item>
A zero length data file does not cause a data transfer to take place.
LPRng modifies this action to be slightly different.
When a zero length data file transfer is indicated,
all of the input until the connection is closed is used as the
contents of the data file.
<p>
When 'piping' into the <tt>lpr</tt> program,
this can be very useful as it eliminates the need to create temporary
files on the senders host.
The <tt>lpr -k</tt> option for details.
Note that some print spoolers do not use this interpretation,
and this option should be used carefully.
</enum>
<sect1>Control File Contents
<p>
The control file consists of a set of lines which either provide
printing information or specify data files to be printed.
The information lines start with upper case letters or digits,
while the data files lines start with lower case letters.
Here is a sample control file:
<tscreen>
<verb>
Hastart4.astart.com
J(stdin)
CA
Lpapowell
Apapowell@astart4+955
Ppapowell
fdfA955astart4.astart.com
N(stdin)
UdfA955astart4.astart.com
</verb>
</tscreen>
<p>
The following are the letters and their meanings in the control file.
<table>
<tabular ca="|l|l|l|l|">
X
|
RFC1179
|
Meaning
@
A
|
LPRng
|
Identifier for job
@
C
|
RFC1179
|
Class for banner page
@
H
|
RFC1179
|
Host name
@
I
|
RFC1179
|
Indent Printing
@
J
|
RFC1179
|
Job name for banner page
@
L
|
RFC1179
|
Print banner page
@
M
|
RFC1179
|
Mail When Printed
@
N
|
RFC1179
|
Name of source file
@
P
|
RFC1179
|
User identification
@
Q
|
LPRng
|
Queue name
@
R
|
LPRng
|
Accounting info
@
S
|
RFC1179
|
Symbolic link data
@
T
|
RFC1179
|
Title for pr
@
U
|
RFC1179
|
Unlink data file
@
W
|
RFC1179
|
Width of output
@
Z
|
LPRng
|
Filter options
@
1
|
RFC1179
|
troff R font
@
2
|
RFC1179
|
troff I font
@
3
|
RFC1179
|
troff B font
@
4
|
RFC1179
|
troff S font
@
c
|
RFC1179
|
Plot CIF file
@
d
|
RFC1179
|
Print DVI file
@
f
|
RFC1179
|
Print formatted file
@
g
|
RFC1179
|
Plot file
@
k
|
RFC1179
|
Reserved for use by Kerberized LPR clients and servers.
@
l
|
RFC1179
|
Print file leaving control characters
@
n
|
RFC1179
|
Print ditroff output file
@
o
|
RFC1179
|
Print Postscript output file
@
p
|
RFC1179
|
Print file with 'pr' format
@
t
|
RFC1179
|
Print troff output file
@
v
|
RFC1179
|
Print raster file
@
z
|
RFC1179
|
Reserved for future use with the Palladium print system.
@
</tabular>
</table>
<p>
The
<tt>A</tt> (Identifier)
line was introduced to record a unique
system wide job identifier for LPRng submitted jobs.
This is basically formed from the user name,
job number, and host at the time of submission.
For example: <tt>papowell@astart4+955</tt>
is job number 995 submitted by papowell from host astart4.
<p>
The
<tt>C</tt> (Class)
line is set by the <tt>lpr -C class</tt> option,
and the value can be used to control printing.
For example,
the <tt>lpc class zone </tt> command would restrict job printing to
only jobs with class <tt>zone</tt>.
<p>
The
<tt>H</tt> (hostname),
<tt>P</tt> (username),
and
<tt>J</tt> (jobname)
fields are used to identify the host and user which sent the job,
and to provide information to be displayed by <tt>lpq</tt>
when reporting job status.
<p>
The
<tt>L</tt> (print banner page) field is one that has caused many
problems for users.
RFC1179 indicates that its presence causes the banner page to be printed,
and its absence suppresses banner pages.
The <tt>lpr -h</tt> option suppresses putting this line into the
control file.
Usually the <tt>L</tt> field is a duplicate of the <tt>P</tt>
field.
<p>
The <tt>M</tt> (mail information)
field supplies a mail address for LPRng to send mail to when
a job is completed.
See
<ref id="mail" name="LPR -m and user logging">
for more details.
<p>
The <tt>N</tt> (file name) field is usually provided to identify
the file name corresponding to the data file.
This can be used to print names on page separators, etc.
LPRng largely ignores this line.
<p>
The
<tt>I</tt> (indent)
and
<tt>W</tt> (width)
fields are supposed to specify a page indent and width for printing.
These fields are passed to filters if they are present.
<p>
The <tt>Q</tt> (queue name)
field is an LPRng extension,
and contains the name of the print queue the job was originally sent to.
See
<ref id="qq" name="qq printcap option"> for details.
<p>
The <tt>R</tt> (accounting info) field was added by LPRng to allow
a specified account to be billed for job printing.
The <tt>lpr -Rname</tt> option can be used to specify the accounting name.
<p>
The
<tt>S</tt> (symbolic link)
and
<tt>U</tt> (unlink after printing)
lines were used by the original BSD LPD print system to control
how it passed files to the print server.
LPRng ignores these lines.
In fact, it will remove <tt>S</tt> lines and force the <tt>U</tt>
lines to refer only to job data files.
This closes a nasty security loophole on non-LPRng print spoolers.
<p>
The <tt>T</tt> (pr job title) is used with the <tt>lpr -p</tt>
operation to supply a banner to the <tt>pr</tt> program.
<p>
The <tt>Z</tt> (filter options) value is specified with
<tt>lpr -Zoption</tt> and is passed to the data file filters
during the printing operation.
See
<ref id="secfilter" name="Filters"> for details on how the
this is used during the printing process.
<p>
All of the lower case letters are reserved for format specifications for
data files.
In the control file, these are followed by the name of the data file
to which they correspond.
While in principle different data files in the control file can have
different formats,
this has not been implemented in any known spooling system.
See
<ref id="secfilter" name="Filters"> for details on how the
data file formats are used during the printing process.
<sect1>LPQ Requests
<p>
The RFC1179 protocol specifies that <tt>lpq</tt> print status
requests can be sent to the <tt>lpd</tt> server.
The lpq requests have the format:
<tscreen>
<verb>
\003printer [id]* \n    short
\004printer [id]* \n    long
\009printer [id]* \n    LPRng extension- verbose
</verb>
</tscreen>
<p>
The <tt>lpd</tt> print server will then return queue status
and close the data connection.
<p>
RFC1179 does not state in any manner what the format of the queue status
should be.
Thus, implementors have been free to augment or change the status as
they like.
Even the BSD LPR status format has been changed from different versions.
<p>
See
<ref id="statusref" name="Status Monitoring and Logging">
for information on the formats returned.
<p>
The <tt>id</tt> values are used to select the jobs to be displayed.
LPRng displays any job whose ID, hostname, or user name information
from the control file
<tt>A</tt>,
<tt>H</tt>,
or
<tt>P</tt> fields match any of the id values.
<p>
Note that since there is no identification of the information requestor,
then restriction of information is almost impossible.
<p>
<sect1>LPRM Requests
<p>
The RFC1179 protocol specifies that <tt>lprm</tt> job removal
requests can be sent to the <tt>lpd</tt> server.
The lpq requests have the format:
<tscreen>
<verb>
\005printer user [id]* \n
</verb>
</tscreen>
<p>
The <tt>lpd</tt> print server will search the specified print queue
and remove any job whose ID, hostname, or user name information
from the control file
<tt>A</tt>,
<tt>H</tt>,
or
<tt>P</tt> fields match any of the id values
and for which the user has permission to perform a removal operation.
See the
<ref id="lpdpermsref" name="/etc/lpd.perms"> file for details on
permissions.
<p>
Most RFC1179 compatible spoolers use the user information in the
request as the name of the user which spooled the job.
However,
in a network environment this is extremely easy to fabricate,
and is at best a weak type of authentication.
<sect1>LPC Requests
<label id="lpcreread">
<p>
LPRng has extended the RFC1179 protocol to allow queue and printer control
commands to be sent to the LPD server.
The format of these commands are:
<p>
<tscreen>
<verb>
\006printer user key [options]
</verb>
</tscreen>
<p>
The following commands are supported.
<table>
<tabular ca="|l|l|l|l|">
Command
|
Operation
@
<tt> active [printer[@host]]</tt>
|
check to see if server accepting connections
@
<tt> abort   (printer[@host] | all)  </tt>
|
terminate server process printing job
@
<tt> disable (printer[@host] | all)  </tt>
|
disable queueing
@
<tt> debug   (printer[@host] | all) debugparms </tt>
|
set debug level for printer
@
<tt> enable  (printer[@host] | all)  </tt>
|
enable  queueing
@
<tt> hold    (printer[@host] | all) (name[@host] | job | all)* </tt>
|
hold job
@
<tt> holdall (printer[@host] | all)  </tt>
|
hold all jobs on
@
<tt> kill    (printer[@host] | all)  </tt>
|
stop and restart server
@
<tt> lpd [printer[@host]]  </tt>
|
get LPD PID for server
@
<tt> lpq (printer[@host] | all) (name[@host] | job | all)*     </tt>
|
invoke LPQ
@
<tt> lprm (printer[@host] | all) (name[@host]|host|job| all)*  </tt>
|
invoke LPRM
@
<tt> move printer (user|jobid)* target </tt>
|
move jobs to new queue
@
<tt> noholdall (printer[@host] | all)  </tt>
|
hold all jobs off
@
<tt> printcap (printer[@host] | all) </tt>
|
report printcap values
@
<tt> quit                            </tt>
|
exit LPC
@
<tt> redirect (printer[@host] | all) (printer@host | off )*    </tt>
|
redirect jobs
@
<tt> release  (printer[@host] | all) (name[@host] | job | all)* </tt>
|
release job
@
<tt> reread [printer[@host]]</tt>
|
LPD reread database information
@
<tt> start   (printer[@host] | all)  </tt>
|
start printing
@
<tt> status  (printer[@host] | all)  </tt>
|
status of printers
@
<tt> stop    (printer[@host] | all)  </tt>
|
stop  printing
@
<tt> topq    (printer[@host] | all) (name[@host] | job | all)* </tt>
|
reorder job
@
<tt> defaultq                         </tt>
|
default queue for LPD server
@
<tt> local    (printer | all)  </tt>
|
client printcap and configuration information
@
<tt> server    (printer | all)  </tt>
|
server printcap and configuration information
@
</tabular>
</table>
<p>
Many of these commands support extremely specialized operations for
print queue management,
However, the following are the most commonly used and are supported by
the BSD LPD print spooling system as well:
<itemize>
<item>
<tt> start, stop, enable, disable </tt>
<newline> Start and stop will start and stop printing for a specified queue.
Enable and disable enable and disable sending and/or accepting jobs
for the queue.
<item>
<tt> abort, kill </tt>
<newline>
Abort will cause the process doing the actual job printing to be terminated.
Kill does an abort, and then restarts the printing process.
These commands are used to restart a queue printing after some disaster.
<item>
<tt> topq </tt>
Places selected jobs at the top of the print queue.
<item>
<tt> status </tt>
<newline>
Shows a status display of the print spools on the server.
</itemize>
<p>
The following commands are extensions to the basic set provided by the
BSD LPD system.
<itemize>
<item>
<tt> lpq, lprm </tt>
<newline>
Invokes the lpq or lprm program from lpc.
Useful when in the interactive mode.
<item>
<tt> hold, holdall, release </tt>
<newline>
The hold command will cause the selected jobs to be held until
released.
The holdall jobs sets all jobs submitted to the queue to be held until
released.
The release command releases jobs for printing.
If a job has had an error and is in the error state,
the release command will cause it to be reprinted.
<item>
<tt> move, redirect </tt>
<newline>
The move command will move selected jobs to the specified spool queue.
The redirect command sends all jobs submitted to the queue to be
sent to the specified queue.
<item>
<tt> active, lpd, reread </tt>
<newline>
The active command will connect to the server for the printer.
This is used to check to see if non-LPRng print servers are active.
The lpd command will connect to the server and
get the process id (PID) of the <tt>lpd</tt> server.
The reread command causes a SIGHUP signal to be sent to the lpd process,
causing it to reread the
<tt>/etc/lpd.conf</tt>,
<tt>/etc/printcap</tt>,
or
<tt>/etc/lpd.perms</tt> files.
This is usually done when some important configuration information has
been modified and the administrator wants to have the server use the
new information.
<item>
<tt> debug </tt>
<newline>
This is a desperation facility for developers that allows dynamic enabling
of debug information generation.
Not normally used in general operation.
<item>
<tt> local, server  </tt>
<newline>
These commands will print out the configuration information in the
local
<tt>/etc/lpd.conf</tt> file,
as well as the printcap information for the specified printers;
<tt/local/
prints what the LPRng clients (<tt/lpr, lpq, .../) would use
while
<tt/server/
prints what the LPRng server (<tt/lpd/) would use if running on this host.
This is an extremely useful diagnostic tool for administrators.
Not normally used in general operation.
</itemize>
<sect1>Block Job Transfer
<label id="sendblockformat">
<label id="blocktransfer">
<p>
Options used:
<itemize>
<item> <tt>send_block_format</tt><em>&nbsp;&nbsp;Transfer job as a block</em>
</itemize>
<p>
In normal job transfer operations,
the sender and receiver have a handshake interaction in order to transfer
a print job.
Each file is sent individually.
The <tt>send_block_format</tt> option forces
a Block Job Transfer operation.
This causes the sender to transfer a single file containing all the
job printing information,
including control file and data files.
<p>
The transfer command line has the form:
<tscreen>
<verb>
\007printer size\n
</verb>
</tscreen>
<p>
The receiver will return any acknowledgement of a single 0 octet,
and then the size bytes of the job will be transferred by the sender.
At the end of the transfer a single 0 octet is added,
and the receiver will indicate success by returning a single 0 octet.
Any other value returned by the receiver indicates an error condition.
<p>
The file transferred by the sender is simply the command lines that it
would have normally sent for job transfer,
followed by the control or data file values.
<sect1>Authenticated Transfer
<p>
RFC1179 does not provide any authentication or encryption mechanism
for the transfer of jobs or commands to the <tt>lpd</tt>
print server.
The Authenticated Transfer operation was added to allow an encrypted
or authenticated transfer of print jobs or commands.
<p>
Since there are various restrictions on the incorporation of authentication
facilities into programs,
LPRng supports authentication by providing a simple interface to
encryption programs.
<p>
The idea is that when authentication is required when sending a job,
LPRng will generate a block transfer job as described for the
<ref id="blocktransfer" name="Block Transfer operation,">
and then invoke a set of programs to encryt and transfer the file,
and encrypt and transfer the returned status.
<p>
Similarly,
when sending a command,
the command information will be placed in a file
and the encrypted file will be transferred.
<p>
This technique means that the programs and support to do encryption
are external to LPRng,
and can use any type of method that they choose to implement the
secure and/or authenticated transfer.
<p>
See
<ref id="authref" name="Authentication and Encryption">
for details on the authentication interface.
<sect>Defective RFC1179 Implementations
<p>
Most printer (or print server box) manufacturers totally ignore the
details of the RFC1179 protocol and simply accept the data files for printing,
disregarding the control file <bf>until they need to print a banner
or provide status information</bf>.
<p>
At this point,
you suddenly discover all sorts of little details
that cause horrible problems.
For example,
the use of non-ASCII characters (i.e. - values are 128-255) in the
J (job) line of a control file has been known to crash one network
interface card in such a manner that a power-up is needed to restart
the printer.
<p>
Also,
if you send one particular RFC1179 compatible print spooler a
control file with a character whose value is 255 (i.e. 0xFF),
the job will never get printed,
and there is a mysterious diagnostic on the console:
<tscreen>
<verb>
unexpected end of input
</verb>
</tscreen>
<p>
This is due to the fact that the 0xFF eight bit value is getting sign
extended to a 16 bit value 0xFFFF,
which just turns out to be -1, or the error indication from a read.
<sect1> OS2 Print Spoolers
<p>
For various reasons,  some versions of the OS/2 <tt>lpd</tt>
print spooler have decided to make the control file and data file names
have different formats.
<p>
In addition,
the OS/2 spooler does not follow RFC1179 correctly,  and truncates
the data and job file protocol exchange.
<sect1>Serious Security Loophole
<p>
There is the subtle and nasty problem with some print filters
that are not
<em>meta-char-escape</em> proof.
For example,
suppose that a user decided to spool a job as follows:
<tscreen>
<verb>
lpr '-J; rm -rf /*;' /tmp/a
</verb>
</tscreen>
<p>
This would create a job file with the line:
<tscreen>
<verb>
J `rm /etc/passwd; echo Job;`
</verb>
</tscreen>
<p>
The job line ends up getting passed to a print filter:
<tscreen>
<verb>
pr:sd=/...
  :if=/usr/local/hack
    ... invoked as:
    /usr/local/hack '-J; rm -rf /*;'

/usr/local/hack is:

#!/bin/sh
while [ -n "$1" ] ; do
        case "$1" in
        -J  )  shift; args="$args -M$1";;
        esac;
        shift;
done;
# reformat the command line
eval /usr/local/realfilter $args

^^^^
</verb>
</tscreen>
<p>
The observant reader will notice that the above line gets expanded to:
<tscreen>
<verb>
eval /usr/local/realfilter -MJ; rm -rf /*;
</verb>
</tscreen>
<p>
<sect>Acknowledgements
<p>
I'd like to thank the proof-readers from the LPRng mailing list,
in particular:
Gordon Haverland (<tt>haverlan@agric.gov.ab.ca</tt>),
Lars Anderson, Bertrand Decouty, Horst Fickenscher,
Philip Griffith, Gordon Haverland, John Perkins, Richard S. Shuford,
James H. Young and the ones I forgot.
<p>
Finally,  Patrick would like to thank all of the LPRng users
who so relentlessly tried the incredible number of permutations and
combiNATIONS Of printers and software,
and made requests for <em>just one more feature</em>.
<sect>Index To All The Configuration and Printcap Options
<label id="index">
<label id="options">
<p>
<!-- START OPTIONS -->
<tt><ref id="ab" name="ab"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  always print banner, ignore lpr -h option <newline>
<tt><ref id="achk" name="achk"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  query accounting server when connected <newline>
<tt><ref id="ae" name="ae"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  accounting at end (see also af, la, ar, as) <newline>
<tt><ref id="af" name="af"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  name of accounting file (see also la, ar) <newline>
<tt><ref id="ah" name="ah"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  automatically hold all jobs <newline>
<tt><ref id="allowduplicateargs" name="allow&lowbar;duplicate&lowbar;args"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  Allow duplicate command line arguments (legacy requirement) <newline>
<tt><ref id="allowgetenv" name="allow&lowbar;getenv"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  Allow use of LPD&lowbar;CONF <newline>
<tt><ref id="allowuserlogging" name="allow&lowbar;user&lowbar;logging"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  allow users to request logging info using lpr -mhost%port <newline>
<tt><ref id="ar" name="ar"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  enable remote transfer accounting (if af is set) <newline>
<tt><ref id="as" name="as"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  accounting at start (see also af, la, ar) <newline>
<tt><ref id="auth" name="use&lowbar;auth"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  authentication type to use <newline>
<tt><ref id="authclientfilter" name="auth&lowbar;client&lowbar;filter"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  client to server authentication transfer program <newline>
<tt><ref id="authforward" name="auth&lowbar;forward"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  server to server authentication method <newline>
<tt><ref id="authforwardfilter" name="auth&lowbar;forward&lowbar;filter"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  server to server authentication transfer program <newline>
<tt><ref id="authreceivefilter" name="auth&lowbar;receive&lowbar;filter"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  server receive authentication program <newline>
<tt><ref id="authserverid" name="auth&lowbar;server&lowbar;id"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  server id for authentication <newline>
<tt><ref id="be" name="be"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  Banner at End Generation Program <newline>
<tt><ref id="bk" name="bk"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  Berkeley LPD job file format <newline>
<tt><ref id="bkfilteroptions" name="bk&lowbar;filter&lowbar;options"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  Berkeley LPD filter options <newline>
<tt><ref id="bkoffilteroptions" name="bk&lowbar;of&lowbar;filter&lowbar;options"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  Berkeley LPD OF filter options <newline>
<tt><ref id="bkf" name="bkf"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  backwards-compatible filters: use simple parameters <newline>
<tt><ref id="bl" name="bl"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  short banner line sent to banner printer <newline>
<tt><ref id="bp" name="bp"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  Banner Generation Program (see bs, be) <newline>
<tt><ref id="bq" name="bq"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  Use filters on bounce queue jobs <newline>
<tt><ref id="bqformat" name="bq_format"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  Format of bounce queue output <newline>
<tt><ref id="br" name="br"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  Serial port bit rate (see ty) <newline>
<tt><ref id="bs" name="bs"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  Banner at Start Generation Program <newline>
<tt><ref id="cd" name="cd"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  control directory <newline>
<tt><ref id="checkfornonprintable" name="check&lowbar;for&lowbar;nonprintable"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  LPR checks for nonprintable file <newline>
<tt><ref id="checkidle" name="check&lowbar;idle"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  program used to check for idle printer <newline>
<tt><ref id="classinstatus" name="class&lowbar;in&lowbar;status"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  Show job class name in <tt>lpq</tt> status information <newline>
<tt><ref id="client" name="client"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  Mark printcap entry for client programs only <newline>
<tt><ref id="cm" name="cm"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  comment identifying printer (LPQ) <newline>
<tt><ref id="configfile" name="config&lowbar;file"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  configuration file <newline>
<tt><ref id="connectgrace" name="connect&lowbar;grace"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  connection control for remote printers <newline>
<tt><ref id="connectinterval" name="connect&lowbar;interval"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  connection control for remote printers <newline>
<tt><ref id="connecttimeout" name="connect&lowbar;timeout"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  connection control for remote printers <newline>
<tt><ref id="connecttry" name="connect&lowbar;try"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  connection control for remote printers <newline>
<tt><ref id="controlfilterbk" name="control&lowbar;filter"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  control file filter <newline>
<tt><ref id="db" name="db"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  debug options for queue <newline>
<tt><ref id="defaultformat" name="default&lowbar;format"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  default job format <newline>
<tt><ref id="defaultpermission" name="default&lowbar;permission"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  default permission for files <newline>
<tt><ref id="defaultprinter" name="default&lowbar;printer"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  default printer <newline>
<tt><ref id="defaultprinterwhenunknown" name="default&lowbar;printer&lowbar;when&lowbar;unknown"></tt><tt>&nbsp;&nbsp;</tt>  used by LPD when printer name not in printcap <newline>
<tt><ref id="defaultpriority" name="default&lowbar;priority"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  default job priority <newline>
<tt><ref id="defaultremotehost" name="default&lowbar;remote&lowbar;host"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  default remote host <newline>
<tt><ref id="defaulttmpdir" name="default&lowbar;tmp&lowbar;dir"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  default directory for temp files <newline>
<tt><ref id="destinations" name="destinations"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  printers that a route filter may return and we should query <newline>
<tt><ref id="exitlingertimeout" name="exit_linger_timeout"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  connection close linger timeout<newline>
<tt><ref id="ff" name="ff"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  string to send for a form feed <newline>
<tt><ref id="filterldpath" name="filter&lowbar;ld&lowbar;path"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  filter LD&lowbar;LIBRARY&lowbar;PATH value <newline>
<tt><ref id="filteroptions" name="filter&lowbar;options"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  filter options <newline>
<tt><ref id="filterpath" name="filter&lowbar;path"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  filter PATH environment variable <newline>
<tt><ref id="fo" name="fo"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  send form feed when device is opened <newline>
<tt><ref id="forcefqdnhostname" name="force&lowbar;fqdn&lowbar;hostname"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  force FQDN hostname value in control file <newline>
<tt><ref id="forcelocalhost" name="force&lowbar;localhost"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  force clients to send all requests to localhost <newline>
<tt><ref id="forcequeuename" name="force&lowbar;queuename"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  force use of this queuename if none provided <newline>
<tt><ref id="fq" name="fq"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  send form feed when device is closed <newline>
<tt><ref id="fulltime" name="full&lowbar;time"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  use extended time format <newline>
<tt><ref id="generatebanner" name="generate&lowbar;banner"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  generate banner page for forwarded jobs<newline>
<tt><ref id="group" name="group"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  Effective Group ID (EGID) for SUID ROOT programs <newline>
<tt><ref id="hl" name="hl"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  Header (banner) last, at end of job <newline>
<tt><ref id="ignorerequesteduserpriority" name="ignore&lowbar;requested&lowbar;user&lowbar;priority"></tt><tt></tt>  Ignore requested user priority <newline>
<tt><ref id="if" name="if"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  default (f, l) filter program <newline>
<tt><ref id="ipv6" name="ipv6"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  using IPV6 conventions <newline>
<tt><ref id="kerberoskeytab" name="kerberos&lowbar;keytab"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  kerberos keytab file location <newline>
<tt><ref id="kerberoslife" name="kerberos&lowbar;life"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  kerberos key lifetime <newline>
<tt><ref id="kerberosrenew" name="kerberos&lowbar;renew"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  kerberos key renewal time <newline>
<tt><ref id="kerberosforwardprincipal" name="kerberos&lowbar;forward&lowbar;principal"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;</tt>  kerberos remote principle name for forwarding <newline>
<tt><ref id="kerberosserverprincipal" name="kerberos&lowbar;server&lowbar;principal"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  kerberos remote server principle name <newline>
<tt><ref id="kerberosservice" name="kerberos&lowbar;service"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  kerberos default service <newline>
<tt><ref id="la" name="la"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  enable local printer accounting (if af is set) <newline>
<tt><ref id="ld" name="ld"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  leader string sent on printer open <newline>
<tt><ref id="lf" name="lf"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  error log file for spool queue <newline>
<tt><ref id="lk" name="lk"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  lock the IO device <newline>
<tt><ref id="lockfile" name="lockfile"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  lpd lock file <newline>
<tt><ref id="loggerdestination" name="logger&lowbar;destination"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  destination for logging information <newline>
<tt><ref id="loggertimeout" name="logger&lowbar;timeout"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  intervals between connection attempts <newline>
<tt><ref id="loggerpathname" name="logger&lowbar;pathname"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  temp file for log information <newline>
<tt><ref id="loggermaxsize" name="logger&lowbar;max&lowbar;size"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  max size in Kbytes of temp file for log information <newline>
<tt><ref id="longnumber" name="longnumber"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  use long job number when a job is submitted <newline>
<tt><ref id="lp" name="lp"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  printer device name or specification <newline>
<tt><ref id="lpdbounce" name="lpd&lowbar;bounce"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  force lpd to filter job before forwarding <newline>
<tt><ref id="lpdforcepoll" name="lpd&lowbar;force&lowbar;poll"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  force lpd to poll idle printers <newline>
<tt><ref id="lpdpolltime" name="lpd&lowbar;poll&lowbar;time"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  interval between lpd printer polls <newline>
<tt><ref id="lpdport" name="lpd&lowbar;port"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  lpd listening port <newline>
<tt><ref id="lpdprintcappath" name="lpd&lowbar;printcap&lowbar;path"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  lpd printcap path <newline>
<tt><ref id="lprbounce" name="lpr&lowbar;bounce"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  lpr does filtering as in bounce queue <newline>
<tt><ref id="lprbsd" name="lpr&lowbar;bsd"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  lpr does filtering as in bounce queue <newline>
<tt><ref id="mailfrom" name="mail&lowbar;from"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  mail user from user name <newline>
<tt><ref id="mailoperatoronerror" name="mail&lowbar;operator&lowbar;on&lowbar;error"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  mail to this operator on error <newline>
<tt><ref id="maxconnectinterval" name="max&lowbar;connect&lowbar;interval"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  maximum time between connection attempts <newline>
<tt><ref id="maxlogfilesize" name="max&lowbar;log&lowbar;file&lowbar;size"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  maximum size (in K) of spool queue log file <newline>
<tt><ref id="maxserversactive" name="max&lowbar;servers&lowbar;active"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  maximum number of lpd queue servers that can be active <newline>
<tt><ref id="maxstatusline" name="max&lowbar;status&lowbar;line"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  maximum length of status line <newline>
<tt><ref id="maxstatussize" name="max&lowbar;status&lowbar;size"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  maximum size (in K) of status file <newline>
<tt><ref id="mc" name="mc"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  maximum copies allowed <newline>
<tt><ref id="minlogfilesize" name="min&lowbar;log&lowbar;file&lowbar;size"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  minimum size (in K) of spool queue log file <newline>
<tt><ref id="minstatussize" name="min&lowbar;status&lowbar;size"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  minimum size to reduce status file to <newline>
<tt><ref id="minfree" name="minfree"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  minimum amount of free space needed <newline>
<tt><ref id="ml" name="ml"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  minimum number of printable characters for printable check <newline>
<tt><ref id="mstimeresolution" name="ms&lowbar;time&lowbar;resolution"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  millisecond time resolution <newline>
<tt><ref id="mx" name="mx"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  maximum job size (1Kb blocks, 0 = unlimited) <newline>
<tt><ref id="nb" name="nb"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  use nonblocking device open <newline>
<tt><ref id="networkconnectgrace" name="network&lowbar;connect&lowbar;grace"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  pause between transferring jobs to remote printer <newline>
<tt><ref id="nline_after_file" name="nline&lowbar;after&lowbar;file"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  N line after file name <newline>
<tt><ref id="of" name="of"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  banner output filter <newline>
<tt><ref id="offilteroptions" name="of&lowbar;filter&lowbar;options"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  OF filter options <newline>
<tt><ref id="oh" name="oh"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  Printcap entry valid only on these hosts <newline>
<tt><ref id="originateport" name="originate&lowbar;port"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  originate connections from these ports <newline>
<tt><ref id="passenv" name="pass&lowbar;env"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  clients pass these environment variables to filters <newline>
<tt><ref id="permspath" name="perms&lowbar;path"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  lpd.perms files <newline>
<tt><ref id="pl" name="pl"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  page length (in lines) <newline>
<tt><ref id="pr" name="pr"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  pr program for p format <newline>
<tt><ref id="printcappath" name="printcap&lowbar;path"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  /etc/printcap files <newline>
<tt><ref id="ps" name="ps"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  printer status file name <newline>
<tt><ref id="pw" name="pw"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  page width (in characters) <newline>
<tt><ref id="px" name="px"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  page width in pixels (horizontal) <newline>
<tt><ref id="py" name="py"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  page length in pixels (vertical) <newline>
<tt><ref id="queue_lock_file" name="queue_lock_file"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>queue lock file name<newline>
<tt><ref id="queue_control_file" name="queue_control_file"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>queue control file name<newline>
<tt><ref id="queue_status_file" name="queue_status_file"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>queue status file name<newline>
<tt><ref id="qq" name="qq"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  put queue name in control file <newline>
<tt><ref id="remotesupport" name="remote&lowbar;support"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  operations allowed to remote host <newline>
<tt><ref id="reportserveras" name="report&lowbar;server&lowbar;as"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  server name for status reports <newline>
<tt><ref id="retryeconnrefused" name="retry&lowbar;econnrefused"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  Retry on connect ECONNREFUSED errors <newline>
<tt><ref id="retrynolink" name="retry&lowbar;nolink"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  Retry device open or connect failures <newline>
<tt><ref id="returnshortstatus" name="return&lowbar;short&lowbar;status"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  return short lpq status when request arrives from specified host <newline>
<tt><ref id="reuseaddr" name="reuse&lowbar;addr"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  set SO&lowbar;REUSEADDR on outgoing ports <newline>
<tt><ref id="reverselpqformat" name="reverse&lowbar;lpq&lowbar;format"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  reverse lpq format when request arrives from specified host <newline>
<tt><ref id="rg" name="rg"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  clients allow only users in this group access to printer <newline>
<tt><ref id="rm" name="rm"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  remote machine (hostname) (with rp) <newline>
<tt><ref id="router" name="router"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  routing filter, returns destinations <newline>
<tt><ref id="rp" name="rp"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  remote printer name (with rm) <newline>
<tt><ref id="rw" name="rw"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  open printer for reading and writing <newline>
<tt><ref id="safechars" name="safe&lowbar;chars"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  additional safe characters in control file lines <newline>
<tt><ref id="saveonerror" name="save&lowbar;on&lowbar;error"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  save job when an error <newline>
<tt><ref id="savewhendone" name="save&lowbar;when&lowbar;done"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  save job when done <newline>
<tt><ref id="sb" name="sb"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  short banner (one line only) <newline>
<tt><ref id="sd" name="sd"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  spool directory pathname <newline>
<tt><ref id="sendblockformat" name="send&lowbar;block&lowbar;format"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  send block of data, rather than individual files <newline>
<tt><ref id="senddatafirst" name="send&lowbar;data&lowbar;first"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  send data files first in job transfer <newline>
<tt><ref id="sendfailureaction" name="send&lowbar;failure&lowbar;action"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  failure action to take after send&lowbar;try attempts failed <newline>
<tt><ref id="sendjobrwtimeout" name="send&lowbar;job&lowbar;rw&lowbar;timeout"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  print job read/write timeout <newline>
<tt><ref id="sendqueryrwtimeout" name="send&lowbar;query&lowbar;rw&lowbar;timeout"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  status query operation read/write timeout <newline>
<tt><ref id="sendtry" name="send&lowbar;try"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  maximum number of times to try sending job <newline>
<tt><ref id="sendmail" name="sendmail"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  sendmail program <newline>
<tt><ref id="server" name="server"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  Mark printcap entry for lpd server program only <newline>
<tt><ref id="servertmpdir" name="server&lowbar;tmp&lowbar;dir"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  server temporary file directory <newline>
<tt><ref id="sf" name="sf"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  suppress form feeds separating data files in job <newline>
<tt><ref id="sh" name="sh"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  suppress header (banner) pages <newline>
<tt><ref id="short_status_date" name="short&lowbar;status&lowbar;date"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  short (hh:mm) timestamp format for status <newline>
<tt><ref id="shortstatuslength" name="short&lowbar;status&lowbar;length"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  short lpq status length in lines <newline>
<tt><ref id="socketlinger" name="socket&lowbar;linger"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  set the SO&lowbar;LINGER socket option <newline>
<tt><ref id="spooldirperms" name="spool&lowbar;dir&lowbar;perms"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  spool directory permissions <newline>
<tt><ref id="spoolfileperms" name="spool&lowbar;file&lowbar;perms"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  spool file permissions <newline>
<tt><ref id="spreadjobs" name="spread&lowbar;jobs"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  amount to spread jobs to avoid collisions <newline>
<tt><ref id="ss" name="ss"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  name of queue that server serves (with sv) <newline>
<tt><ref id="stalledtime" name="stalled&lowbar;time"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  time after which to report active job stalled <newline>
<tt><ref id="stoponabort" name="stop&lowbar;on&lowbar;abort"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  stop processing queue on filter abort <newline>
<tt><ref id="stty" name="stty"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  stty commands to set output line characteristics <newline>
<tt><ref id="sv" name="sv"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  names of servers for queue (with ss) <newline>
<tt><ref id="syslogdevice" name="syslog&lowbar;device"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  name of syslog device <newline>
<tt><ref id="tc" name="tc"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  Include indicated printcap entries in current entry<newline>
<tt><ref id="tr" name="tr"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  trailer string to send before closing printer <newline>
<tt><ref id="translateformat" name="translate&lowbar;format"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  translate data format in control file <newline>
<tt><ref id="usedate" name="use&lowbar;date"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  force date in control file <newline>
<tt><ref id="useidentifier" name="use&lowbar;identifier"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  force identifier in control file <newline>
<tt><ref id="useinfocache" name="use&lowbar;info&lowbar;cache"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  read and cache information <newline>
<tt><ref id="usequeuename" name="use&lowbar;queuename"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  put queue name in control file (alias for qq) <newline>
<tt><ref id="useshorthost" name="use&lowbar;shorthost"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  Use short hostname for lpr control and data file names <newline>
<tt><ref id="user" name="user"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  Effective User ID (EUID) for SUID ROOT programs <newline>
<tt><ref id="waitforeof" name="wait_for_eof"></tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>  Wait for EOF on connection <newline>
<!-- END OPTIONS -->
<!-- LPRng-HOWTO SGML format -->
</article>
