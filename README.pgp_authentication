       Using PGP with LPRng for Authentication
                    Patrick Powell
            Original Sun Dec  8 10:13:57 PST 1996
             Update Tue Dec 24 08:31:29 PST 1996

A sample authenticator program is supplied to assist with the development
of authenticated transfers.

PGP Keys and Server PGP Keys

The LPRng/src/AUTHENTICATOR/authenticate_pgp.sh script is provided to
do PGP authentication.  It depends on the following key organization.

1. Each user should have a private keyring in their home directory,
   in the ~/.pgp directory, i.e. - the default used by PGP.
   The users public key identification should have the format:
     User Name <userid@host> <userid1@host> ...
   userid must be the SAME as the userid that they will submit
   jobs using.  Note that that different userids can be put
   into the key string as long as there is one entry for
   each uniq id that the user has.  For example,  suppose that
   user John Smith has several accounts on different hosts:
   john, jsmith, jsmith1. Then his key should have in it:
     John Smith <john@whereever> <jsmith@nowhere> <jsmith1@whatever> ...

   If the user is daring,  then the pass phrase can be put in the file:
     ~/.pgp/clientkey

   This file MUST have 0400 permissions (read only by user)
   and MUST owned by the user.  This is very dangerous;
   but so is setting the PGPPASS environment variable.

2. Each server must have a private keyring for user daemon,
   or whatever you run the LPD server as.  This must be in the
   in the ~daemon/.pgp directory, i.e. - the default used by PGP.
   The daemon public key identification should have the format:
     daemon_hostname daemon <daemon_hostname@hostname>

   In addition,  the pass phrase for the daemon user must be
   put in the file ~daemon/.pgp/serverkey.

   Note: you may have one daemon user with the same key for ALL
   servers, or you may have different ones for different servers.

3. Each user who wants to send jobs to the server must have the
   daemons public key on their public keyring.  The server must
   have their public key on its public keyring.

4. When a job is submitted,  the server will search for the users
   public key using the username submitted by the LPRng client.
   This will be the same as their login name.

5. The LPRng software searches the printcap database for the tag
   to be used for the server key lookup.  The :server_user:
   value is checked for first;  if it is not found the configuration
   user value (default 'daemon') is used.

Installing authenticate_pgp

By default, the authenticate_pgp script and several helper
programs,  readfilecount and removeoneline,  will be installed
by the Makefile install entry.  Check this file for the default
destinations.

Printcap/Configuration Modifications:

You must set the following printcap and/or configuration
variable to on.  Note that the printcap keys override the
configuration keys.

   :Printcap:/
   Configuration     Purpose/Recommended Value

   :server_user:     key lookup for server key.  If you
                     have same secret key for all servers,
                     set configuration key to daemon.
   :user_auth:       Clients use authentication when sending job/request
                     to server.
   :user_auth_command: command to be used by clients (i.e. - user
                     interface programs such as LPR, LPQ, etc., when
                     sending authenticated requests and jobs to server.
   :server_auth:     Servers use authentication when sending job/request
                     to other servers.
   :server_auth_command: command to be used by server when receiving
                     authenticated transfers from clients or other servers.
   :pass_env:        Client programs pass these environment variabless
                     values to the authenticator program.

Example:
   configuration file:

server_auth_command     /usr/local/libexec/authenticate_pgp
client_auth_command     /usr/local/libexec/authenticate_pgp
user_auth           yes
server_auth         yes
server_user         daemon
pass_env            PGPPASS,PGPPATH

Example:
    printcap entry:

pr: 
    :lp=pr@wayoff
	:server_user=daemon_wayoff
   

Permissions Modifications:

1. If you wish to enforce the use of authentication,  then you
   should modifiy the lpd.perms file.  Here are some examples.

   # force authentication
   REJECT AUTH=NONE

   # in addition to above,
   # do not accept forwarded authentication
   REJECT AUTH=FWD

   # if the above is too strong,  you can
   # reject forwarded authentication unless from specified server
   # note: U1, U2, etc. are the userids of the remote server

   REJECT AUTH=FWD NOT FWDUSER=U1@*,U2@*,U3@*

   # you can be paranoid and also check to see that that host
   # agrees with the userid reported.

   REJECT AUTH=FWD FWDUSER=U1@host1

Client/User Configuration

The user should either have the PGPPASS environment variable defined,
or have in his home directory the file ~/.pgp/clientkey.  This file will
be read by the script and used for the value of the PGPPASS
environment variable.  If neither of these is available,  then the
pgp program will interactively request this information.

Checking authenticate_pgp Operation

1. In order to use the script in debug mode, you must first create
   the user 'daemon' private keys on your private keyring for
   testing purposes.

   i.e. 
     pgp -kg
       User ID: daemon_test <daemon_test@host>
       Pass phrase: daemon_test
     pgp -kg
       User ID: user_test <user_test@host>
       Pass phrase: user_test

2. Put the pass phrases for daemon_test in ~/.pgp/serverkey

      echo user_test >~/.pgp/serverkey

   Put the pass phrases for user_test in ~/.pgg/clientkey

      echo user_test >~/.pgp/clientkey

3.  The first test will ensure that you have the pgp software
    installed in an accessible manner.  Execute the script as a user:
    sh authenticate_pgp -D -nuser_test -Rdaemon_test

   The output should resemble:

    server PGPPASS daemon_test
    ORIGKEY PRaTACFJGcQV92TE6bX72W2JHNNGPRIR7
    SERVER AUTH TRANSFERFILE temp.str
    398
    -----BEGIN PGP MESSAGE-----
    Version: 2.6.3i

    ...

    -----END PGP MESSAGE-----
    client PGPPASS user_test

    If there is an error, an error message will be printed.

4.  The next test will make sure that the daemon user can access its
    public and secret keyring when running as user daemon.

4.1 As a user, extract your user public key.  As the user do:
    pgp -kxa userid userid_public_key

4.2 The /var/spool directory is most likely a suitable home directory for
    user daemon.  Create the ~daemon/.pgp directory,  and make sure that
    it has 0700 permissions.

4.3 Use the SU command,  or temporarily log in as user daemon.
	Note: some SU commands do not update the home directory information
    correctly.  Check to make sure that the $HOME environment variable
    accesses the ~daemon home directory.  If not, do:

    export HOME=`eval echo ~daemon`

    This will get the HOME directory of user daemon.

4.4 Create a pgp key for the daemon.  As user daemon do:

    pgp -kg
       User ID: daemon_host <daemon_host@host>
       Pass phrase: daemon_host

    host should be the hostname of the server.
    (you will probably want to make this the permanent daemon PGP key).

4.5 Extract the public key for daemon_host.   As user daemon do:
    pgp -kxa daemon_host daemon_public_key

4.6 Add the user's public key to the user daemon public key ring.
    As user daemon do:

    pgp -ka userid_public_key  (from step 4.1 above).

4.7 Add the daemon's publike key to the user public key ring.
    As user do:
    pgp -ka daemon_public_key  (from step 4.5 above).

4.8 At this point you might want to sign and encrypt a message as
    user and check to see if it can be decoded by daemon.  As user:

    echo hi >/tmp/msg
    pgp -seat msg daemon_host -u userid -o /tmp/msg.pgp
	chmod 777 /tmp/msg.pgp

4.9 As user daemon, check to see if you can decode this message.

    pgp /tmp/msg.pgp -o /tmp/msg.dec

    diff /tmp/msg /tmp/msg.dec

4.10 As user daemon, encode a message for user.

    pgp -seat /tmp/msg.dec userid -o /tmp/msg.pgp -u daemon_host
	chmod 777 /tmp/msg.pgp

4.11 As user, decode the message for user.

    pgp /tmp/msg.pgp -o /tmp/msg.dec2

    diff /tmp/msg.dec2 /tmp/msg

5.  Testing the authenticate_pgp script with full permissions.
    This test will simulate the actual authentication process.

5.1 Compile the setupauth program.  Note that this is not
    an installed part of the LPRng distribution, but is a
    accessory:
      cd LPRng/src
      make setupauth
      cp setupauth /tmp/setupauth

    setupauth has the command line:

      setupauth clientid 'client command' serverid 'servercommand'

    For example:

	/tmp/setupauth \
	   papowell "/bin/ksh -c 'echo CLIENT; printenv ;'" \
	   papowell "/bin/ksh -c 'echo SERVER; printenv ;'"

    This would display the environment variables set up by
    the setupauth program.  This are similar to those used
    by LPRng.

5.2 The LPRng/src/AUTHENTICATE/testauth script has some simple
    tests you might want to run.  Uncomment out the
    appropriate ones and substitute the appropriate user
	name for papowell and daemon.

#!/bin/sh
# '$Id: README.pgp_authentication,v 1.1 1997/01/27 20:01:33 papowell Exp $'
user=${USER:-`whoami`}
# show environment variables
#/tmp/setupauth \
# 	"${user}" "/bin/ksh -c 'echo CLIENT; printenv ;'" \
# 	"${user}" "/bin/ksh -c 'echo SERVER; printenv ;'"
#
#exit 0;
#
# check birectionality of data transfer
#  /tmp/setupauth \
# 	"${user}" "/bin/ksh -c 'echo CLIENT STARTING SENDING 1>&2; echo hi 1>&0;'" \
# 	"${user}" "/bin/ksh -c 'echo SERVER READING; cat ;'" \
# sleep 3;
#  /tmp/setupauth \
# 	"${user}" "/bin/ksh -c 'echo CLIENT STARTING READING; cat '" \
# 	"${user}" "/bin/ksh -c 'echo SERVER SENDING 1>&2; echo hi 1>&0'"
# 
# check the authenticate pgp operation
#  Note: you can also use
#  'sh -x ./authenticate_pcp ...' to see the detailed actions.
#  Note: you must be root to run the next test.
#
rm /tmp/tempc /tmp/temps
echo Hi $$ >/tmp/tempc
chmod 777 /tmp/tempc
/tmp/setupauth \
	"${user}" './authenticate_pgp -C -n"${user}" -R"${user}" -T/tmp/tempc' \
	"${user}" './authenticate_pgp -S -n"${user}" -R"${user}" -T/tmp/temps'
rm /tmp/tempc /tmp/temps
echo Hi $$ >/tmp/tempc
chmod 777 /tmp/tempc
/tmp/setupauth \
	"${user}" './authenticate_pgp -C -n"${user}" -Rdaemon -T/tmp/tempc' \
	daemon './authenticate_pgp -S -n"${user}" -Rdaemon -T/tmp/temps'

5.3 As root, execute the testauth script.  Set the USER environment
    variable to the user you desire to simulate.  If you encounter
    difficulties,  then try using:

	"${user}" '/bin/sh -x ./authenticate_pgp -C ...'

    This will produce a trace of the execution of the program.

5.4 Install the authenticate_pgp script in the appropriate directory.
    This should have world execute permissions.  The location is
    assumed to be /usr/local/bin/authenticate_pgp

6. Testing the authentication

6.1 Add the following lines to one of the printcap entries:

    :user_auth:
    :user_authentication_command=/usr/local/lib/authenticate_pgp
    :server_auth:
    :server_authentication_command=/usr/local/lib/authenticate_pgp

6.2 restart the server, using  lpc lpd, to force it to read the
    new printcap information.

6.3 test the authentication facilities by using lpr to send a job
    to the appropriate spool queue.

6. Key distribution
    You can distribute the daemon PGP public key fairly easily -
    see the PGP documentation for key server information.

    Each daemon must have the user's PGP key installed,  or must
    in some way get the key from a trusted server.  This is
	very site dependent and needs to be done by each site administrator.
